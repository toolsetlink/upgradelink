// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"upgradelink-admin-upgrade/ent/fmscloudfile"
	"upgradelink-admin-upgrade/ent/predicate"
	"upgradelink-admin-upgrade/ent/sysuser"
	"upgradelink-admin-upgrade/ent/upgradeapk"
	"upgradelink-admin-upgrade/ent/upgradeapkupgradestrategy"
	"upgradelink-admin-upgrade/ent/upgradeapkupgradestrategyflowlimitstrategy"
	"upgradelink-admin-upgrade/ent/upgradeapkupgradestrategygraystrategy"
	"upgradelink-admin-upgrade/ent/upgradeapkversion"
	"upgradelink-admin-upgrade/ent/upgradeappdownloadreportlog"
	"upgradelink-admin-upgrade/ent/upgradecompanyincome"
	"upgradelink-admin-upgrade/ent/upgradecompanytrafficpacket"
	"upgradelink-admin-upgrade/ent/upgradeconfiguration"
	"upgradelink-admin-upgrade/ent/upgradeconfigurationupgradestrategy"
	"upgradelink-admin-upgrade/ent/upgradeconfigurationupgradestrategyflowlimitstrategy"
	"upgradelink-admin-upgrade/ent/upgradeconfigurationupgradestrategygraystrategy"
	"upgradelink-admin-upgrade/ent/upgradeconfigurationversion"
	"upgradelink-admin-upgrade/ent/upgradedev"
	"upgradelink-admin-upgrade/ent/upgradedevgroup"
	"upgradelink-admin-upgrade/ent/upgradedevgrouprelation"
	"upgradelink-admin-upgrade/ent/upgradedevmodel"
	"upgradelink-admin-upgrade/ent/upgradeelectron"
	"upgradelink-admin-upgrade/ent/upgradeelectronupgradestrategy"
	"upgradelink-admin-upgrade/ent/upgradeelectronupgradestrategyflowlimitstrategy"
	"upgradelink-admin-upgrade/ent/upgradeelectronupgradestrategygraystrategy"
	"upgradelink-admin-upgrade/ent/upgradeelectronversion"
	"upgradelink-admin-upgrade/ent/upgradefile"
	"upgradelink-admin-upgrade/ent/upgradefileupgradestrategy"
	"upgradelink-admin-upgrade/ent/upgradefileupgradestrategyflowlimitstrategy"
	"upgradelink-admin-upgrade/ent/upgradefileupgradestrategygraystrategy"
	"upgradelink-admin-upgrade/ent/upgradefileversion"
	"upgradelink-admin-upgrade/ent/upgradetauri"
	"upgradelink-admin-upgrade/ent/upgradetauriupgradestrategy"
	"upgradelink-admin-upgrade/ent/upgradetauriupgradestrategyflowlimitstrategy"
	"upgradelink-admin-upgrade/ent/upgradetauriupgradestrategygraystrategy"
	"upgradelink-admin-upgrade/ent/upgradetauriversion"
	"upgradelink-admin-upgrade/ent/upgradetrafficpacket"
	"upgradelink-admin-upgrade/ent/upgradeurl"
	"upgradelink-admin-upgrade/ent/upgradeurlupgradestrategy"
	"upgradelink-admin-upgrade/ent/upgradeurlupgradestrategyflowlimitstrategy"
	"upgradelink-admin-upgrade/ent/upgradeurlupgradestrategygraystrategy"
	"upgradelink-admin-upgrade/ent/upgradeurlversion"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFmsCloudFile                                         = "FmsCloudFile"
	TypeSysUser                                              = "SysUser"
	TypeUpgradeApk                                           = "UpgradeApk"
	TypeUpgradeApkUpgradeStrategy                            = "UpgradeApkUpgradeStrategy"
	TypeUpgradeApkUpgradeStrategyFlowLimitStrategy           = "UpgradeApkUpgradeStrategyFlowLimitStrategy"
	TypeUpgradeApkUpgradeStrategyGrayStrategy                = "UpgradeApkUpgradeStrategyGrayStrategy"
	TypeUpgradeApkVersion                                    = "UpgradeApkVersion"
	TypeUpgradeAppDownloadReportLog                          = "UpgradeAppDownloadReportLog"
	TypeUpgradeCompanyIncome                                 = "UpgradeCompanyIncome"
	TypeUpgradeCompanyTrafficPacket                          = "UpgradeCompanyTrafficPacket"
	TypeUpgradeConfiguration                                 = "UpgradeConfiguration"
	TypeUpgradeConfigurationUpgradeStrategy                  = "UpgradeConfigurationUpgradeStrategy"
	TypeUpgradeConfigurationUpgradeStrategyFlowLimitStrategy = "UpgradeConfigurationUpgradeStrategyFlowLimitStrategy"
	TypeUpgradeConfigurationUpgradeStrategyGrayStrategy      = "UpgradeConfigurationUpgradeStrategyGrayStrategy"
	TypeUpgradeConfigurationVersion                          = "UpgradeConfigurationVersion"
	TypeUpgradeDev                                           = "UpgradeDev"
	TypeUpgradeDevGroup                                      = "UpgradeDevGroup"
	TypeUpgradeDevGroupRelation                              = "UpgradeDevGroupRelation"
	TypeUpgradeDevModel                                      = "UpgradeDevModel"
	TypeUpgradeElectron                                      = "UpgradeElectron"
	TypeUpgradeElectronUpgradeStrategy                       = "UpgradeElectronUpgradeStrategy"
	TypeUpgradeElectronUpgradeStrategyFlowLimitStrategy      = "UpgradeElectronUpgradeStrategyFlowLimitStrategy"
	TypeUpgradeElectronUpgradeStrategyGrayStrategy           = "UpgradeElectronUpgradeStrategyGrayStrategy"
	TypeUpgradeElectronVersion                               = "UpgradeElectronVersion"
	TypeUpgradeFile                                          = "UpgradeFile"
	TypeUpgradeFileUpgradeStrategy                           = "UpgradeFileUpgradeStrategy"
	TypeUpgradeFileUpgradeStrategyFlowLimitStrategy          = "UpgradeFileUpgradeStrategyFlowLimitStrategy"
	TypeUpgradeFileUpgradeStrategyGrayStrategy               = "UpgradeFileUpgradeStrategyGrayStrategy"
	TypeUpgradeFileVersion                                   = "UpgradeFileVersion"
	TypeUpgradeTauri                                         = "UpgradeTauri"
	TypeUpgradeTauriUpgradeStrategy                          = "UpgradeTauriUpgradeStrategy"
	TypeUpgradeTauriUpgradeStrategyFlowLimitStrategy         = "UpgradeTauriUpgradeStrategyFlowLimitStrategy"
	TypeUpgradeTauriUpgradeStrategyGrayStrategy              = "UpgradeTauriUpgradeStrategyGrayStrategy"
	TypeUpgradeTauriVersion                                  = "UpgradeTauriVersion"
	TypeUpgradeTrafficPacket                                 = "UpgradeTrafficPacket"
	TypeUpgradeUrl                                           = "UpgradeUrl"
	TypeUpgradeUrlUpgradeStrategy                            = "UpgradeUrlUpgradeStrategy"
	TypeUpgradeUrlUpgradeStrategyFlowLimitStrategy           = "UpgradeUrlUpgradeStrategyFlowLimitStrategy"
	TypeUpgradeUrlUpgradeStrategyGrayStrategy                = "UpgradeUrlUpgradeStrategyGrayStrategy"
	TypeUpgradeUrlVersion                                    = "UpgradeUrlVersion"
)

// FmsCloudFileMutation represents an operation that mutates the FmsCloudFile nodes in the graph.
type FmsCloudFileMutation struct {
	config
	op                              Op
	typ                             string
	id                              *string
	created_at                      *time.Time
	updated_at                      *time.Time
	state                           *bool
	name                            *string
	url                             *string
	size                            *uint64
	addsize                         *int64
	file_type                       *uint8
	addfile_type                    *int8
	user_id                         *string
	cloud_file_storage_providers    *uint64
	addcloud_file_storage_providers *int64
	clearedFields                   map[string]struct{}
	done                            bool
	oldValue                        func(context.Context) (*FmsCloudFile, error)
	predicates                      []predicate.FmsCloudFile
}

var _ ent.Mutation = (*FmsCloudFileMutation)(nil)

// fmscloudfileOption allows management of the mutation configuration using functional options.
type fmscloudfileOption func(*FmsCloudFileMutation)

// newFmsCloudFileMutation creates new mutation for the FmsCloudFile entity.
func newFmsCloudFileMutation(c config, op Op, opts ...fmscloudfileOption) *FmsCloudFileMutation {
	m := &FmsCloudFileMutation{
		config:        c,
		op:            op,
		typ:           TypeFmsCloudFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFmsCloudFileID sets the ID field of the mutation.
func withFmsCloudFileID(id string) fmscloudfileOption {
	return func(m *FmsCloudFileMutation) {
		var (
			err   error
			once  sync.Once
			value *FmsCloudFile
		)
		m.oldValue = func(ctx context.Context) (*FmsCloudFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FmsCloudFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFmsCloudFile sets the old FmsCloudFile of the mutation.
func withFmsCloudFile(node *FmsCloudFile) fmscloudfileOption {
	return func(m *FmsCloudFileMutation) {
		m.oldValue = func(context.Context) (*FmsCloudFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FmsCloudFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FmsCloudFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FmsCloudFile entities.
func (m *FmsCloudFileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FmsCloudFileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FmsCloudFileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FmsCloudFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FmsCloudFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FmsCloudFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FmsCloudFileMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[fmscloudfile.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FmsCloudFileMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[fmscloudfile.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FmsCloudFileMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, fmscloudfile.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FmsCloudFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FmsCloudFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FmsCloudFileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[fmscloudfile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FmsCloudFileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[fmscloudfile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FmsCloudFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, fmscloudfile.FieldUpdatedAt)
}

// SetState sets the "state" field.
func (m *FmsCloudFileMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *FmsCloudFileMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *FmsCloudFileMutation) ClearState() {
	m.state = nil
	m.clearedFields[fmscloudfile.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *FmsCloudFileMutation) StateCleared() bool {
	_, ok := m.clearedFields[fmscloudfile.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *FmsCloudFileMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, fmscloudfile.FieldState)
}

// SetName sets the "name" field.
func (m *FmsCloudFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FmsCloudFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FmsCloudFileMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *FmsCloudFileMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FmsCloudFileMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FmsCloudFileMutation) ResetURL() {
	m.url = nil
}

// SetSize sets the "size" field.
func (m *FmsCloudFileMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FmsCloudFileMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldSize(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *FmsCloudFileMutation) AddSize(u int64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FmsCloudFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FmsCloudFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetFileType sets the "file_type" field.
func (m *FmsCloudFileMutation) SetFileType(u uint8) {
	m.file_type = &u
	m.addfile_type = nil
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *FmsCloudFileMutation) FileType() (r uint8, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldFileType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// AddFileType adds u to the "file_type" field.
func (m *FmsCloudFileMutation) AddFileType(u int8) {
	if m.addfile_type != nil {
		*m.addfile_type += u
	} else {
		m.addfile_type = &u
	}
}

// AddedFileType returns the value that was added to the "file_type" field in this mutation.
func (m *FmsCloudFileMutation) AddedFileType() (r int8, exists bool) {
	v := m.addfile_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileType resets all changes to the "file_type" field.
func (m *FmsCloudFileMutation) ResetFileType() {
	m.file_type = nil
	m.addfile_type = nil
}

// SetUserID sets the "user_id" field.
func (m *FmsCloudFileMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FmsCloudFileMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FmsCloudFileMutation) ResetUserID() {
	m.user_id = nil
}

// SetCloudFileStorageProviders sets the "cloud_file_storage_providers" field.
func (m *FmsCloudFileMutation) SetCloudFileStorageProviders(u uint64) {
	m.cloud_file_storage_providers = &u
	m.addcloud_file_storage_providers = nil
}

// CloudFileStorageProviders returns the value of the "cloud_file_storage_providers" field in the mutation.
func (m *FmsCloudFileMutation) CloudFileStorageProviders() (r uint64, exists bool) {
	v := m.cloud_file_storage_providers
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudFileStorageProviders returns the old "cloud_file_storage_providers" field's value of the FmsCloudFile entity.
// If the FmsCloudFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FmsCloudFileMutation) OldCloudFileStorageProviders(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudFileStorageProviders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudFileStorageProviders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudFileStorageProviders: %w", err)
	}
	return oldValue.CloudFileStorageProviders, nil
}

// AddCloudFileStorageProviders adds u to the "cloud_file_storage_providers" field.
func (m *FmsCloudFileMutation) AddCloudFileStorageProviders(u int64) {
	if m.addcloud_file_storage_providers != nil {
		*m.addcloud_file_storage_providers += u
	} else {
		m.addcloud_file_storage_providers = &u
	}
}

// AddedCloudFileStorageProviders returns the value that was added to the "cloud_file_storage_providers" field in this mutation.
func (m *FmsCloudFileMutation) AddedCloudFileStorageProviders() (r int64, exists bool) {
	v := m.addcloud_file_storage_providers
	if v == nil {
		return
	}
	return *v, true
}

// ClearCloudFileStorageProviders clears the value of the "cloud_file_storage_providers" field.
func (m *FmsCloudFileMutation) ClearCloudFileStorageProviders() {
	m.cloud_file_storage_providers = nil
	m.addcloud_file_storage_providers = nil
	m.clearedFields[fmscloudfile.FieldCloudFileStorageProviders] = struct{}{}
}

// CloudFileStorageProvidersCleared returns if the "cloud_file_storage_providers" field was cleared in this mutation.
func (m *FmsCloudFileMutation) CloudFileStorageProvidersCleared() bool {
	_, ok := m.clearedFields[fmscloudfile.FieldCloudFileStorageProviders]
	return ok
}

// ResetCloudFileStorageProviders resets all changes to the "cloud_file_storage_providers" field.
func (m *FmsCloudFileMutation) ResetCloudFileStorageProviders() {
	m.cloud_file_storage_providers = nil
	m.addcloud_file_storage_providers = nil
	delete(m.clearedFields, fmscloudfile.FieldCloudFileStorageProviders)
}

// Where appends a list predicates to the FmsCloudFileMutation builder.
func (m *FmsCloudFileMutation) Where(ps ...predicate.FmsCloudFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FmsCloudFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FmsCloudFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FmsCloudFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FmsCloudFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FmsCloudFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FmsCloudFile).
func (m *FmsCloudFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FmsCloudFileMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, fmscloudfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fmscloudfile.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, fmscloudfile.FieldState)
	}
	if m.name != nil {
		fields = append(fields, fmscloudfile.FieldName)
	}
	if m.url != nil {
		fields = append(fields, fmscloudfile.FieldURL)
	}
	if m.size != nil {
		fields = append(fields, fmscloudfile.FieldSize)
	}
	if m.file_type != nil {
		fields = append(fields, fmscloudfile.FieldFileType)
	}
	if m.user_id != nil {
		fields = append(fields, fmscloudfile.FieldUserID)
	}
	if m.cloud_file_storage_providers != nil {
		fields = append(fields, fmscloudfile.FieldCloudFileStorageProviders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FmsCloudFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fmscloudfile.FieldCreatedAt:
		return m.CreatedAt()
	case fmscloudfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case fmscloudfile.FieldState:
		return m.State()
	case fmscloudfile.FieldName:
		return m.Name()
	case fmscloudfile.FieldURL:
		return m.URL()
	case fmscloudfile.FieldSize:
		return m.Size()
	case fmscloudfile.FieldFileType:
		return m.FileType()
	case fmscloudfile.FieldUserID:
		return m.UserID()
	case fmscloudfile.FieldCloudFileStorageProviders:
		return m.CloudFileStorageProviders()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FmsCloudFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fmscloudfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fmscloudfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fmscloudfile.FieldState:
		return m.OldState(ctx)
	case fmscloudfile.FieldName:
		return m.OldName(ctx)
	case fmscloudfile.FieldURL:
		return m.OldURL(ctx)
	case fmscloudfile.FieldSize:
		return m.OldSize(ctx)
	case fmscloudfile.FieldFileType:
		return m.OldFileType(ctx)
	case fmscloudfile.FieldUserID:
		return m.OldUserID(ctx)
	case fmscloudfile.FieldCloudFileStorageProviders:
		return m.OldCloudFileStorageProviders(ctx)
	}
	return nil, fmt.Errorf("unknown FmsCloudFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmsCloudFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fmscloudfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fmscloudfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fmscloudfile.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case fmscloudfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case fmscloudfile.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case fmscloudfile.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case fmscloudfile.FieldFileType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case fmscloudfile.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case fmscloudfile.FieldCloudFileStorageProviders:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudFileStorageProviders(v)
		return nil
	}
	return fmt.Errorf("unknown FmsCloudFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FmsCloudFileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, fmscloudfile.FieldSize)
	}
	if m.addfile_type != nil {
		fields = append(fields, fmscloudfile.FieldFileType)
	}
	if m.addcloud_file_storage_providers != nil {
		fields = append(fields, fmscloudfile.FieldCloudFileStorageProviders)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FmsCloudFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fmscloudfile.FieldSize:
		return m.AddedSize()
	case fmscloudfile.FieldFileType:
		return m.AddedFileType()
	case fmscloudfile.FieldCloudFileStorageProviders:
		return m.AddedCloudFileStorageProviders()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FmsCloudFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fmscloudfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case fmscloudfile.FieldFileType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileType(v)
		return nil
	case fmscloudfile.FieldCloudFileStorageProviders:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCloudFileStorageProviders(v)
		return nil
	}
	return fmt.Errorf("unknown FmsCloudFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FmsCloudFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fmscloudfile.FieldCreatedAt) {
		fields = append(fields, fmscloudfile.FieldCreatedAt)
	}
	if m.FieldCleared(fmscloudfile.FieldUpdatedAt) {
		fields = append(fields, fmscloudfile.FieldUpdatedAt)
	}
	if m.FieldCleared(fmscloudfile.FieldState) {
		fields = append(fields, fmscloudfile.FieldState)
	}
	if m.FieldCleared(fmscloudfile.FieldCloudFileStorageProviders) {
		fields = append(fields, fmscloudfile.FieldCloudFileStorageProviders)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FmsCloudFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FmsCloudFileMutation) ClearField(name string) error {
	switch name {
	case fmscloudfile.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case fmscloudfile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case fmscloudfile.FieldState:
		m.ClearState()
		return nil
	case fmscloudfile.FieldCloudFileStorageProviders:
		m.ClearCloudFileStorageProviders()
		return nil
	}
	return fmt.Errorf("unknown FmsCloudFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FmsCloudFileMutation) ResetField(name string) error {
	switch name {
	case fmscloudfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fmscloudfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fmscloudfile.FieldState:
		m.ResetState()
		return nil
	case fmscloudfile.FieldName:
		m.ResetName()
		return nil
	case fmscloudfile.FieldURL:
		m.ResetURL()
		return nil
	case fmscloudfile.FieldSize:
		m.ResetSize()
		return nil
	case fmscloudfile.FieldFileType:
		m.ResetFileType()
		return nil
	case fmscloudfile.FieldUserID:
		m.ResetUserID()
		return nil
	case fmscloudfile.FieldCloudFileStorageProviders:
		m.ResetCloudFileStorageProviders()
		return nil
	}
	return fmt.Errorf("unknown FmsCloudFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FmsCloudFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FmsCloudFileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FmsCloudFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FmsCloudFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FmsCloudFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FmsCloudFileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FmsCloudFileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FmsCloudFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FmsCloudFileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FmsCloudFile edge %s", name)
}

// SysUserMutation represents an operation that mutates the SysUser nodes in the graph.
type SysUserMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	status           *uint8
	addstatus        *int8
	deleted_at       *time.Time
	username         *string
	password         *string
	nickname         *string
	description      *string
	home_path        *string
	mobile           *string
	email            *string
	avatar           *string
	department_id    *uint64
	adddepartment_id *int64
	company_id       *uint64
	addcompany_id    *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*SysUser, error)
	predicates       []predicate.SysUser
}

var _ ent.Mutation = (*SysUserMutation)(nil)

// sysuserOption allows management of the mutation configuration using functional options.
type sysuserOption func(*SysUserMutation)

// newSysUserMutation creates new mutation for the SysUser entity.
func newSysUserMutation(c config, op Op, opts ...sysuserOption) *SysUserMutation {
	m := &SysUserMutation{
		config:        c,
		op:            op,
		typ:           TypeSysUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSysUserID sets the ID field of the mutation.
func withSysUserID(id string) sysuserOption {
	return func(m *SysUserMutation) {
		var (
			err   error
			once  sync.Once
			value *SysUser
		)
		m.oldValue = func(ctx context.Context) (*SysUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SysUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSysUser sets the old SysUser of the mutation.
func withSysUser(node *SysUser) sysuserOption {
	return func(m *SysUserMutation) {
		m.oldValue = func(context.Context) (*SysUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SysUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SysUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SysUser entities.
func (m *SysUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SysUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SysUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SysUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SysUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SysUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SysUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SysUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SysUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SysUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *SysUserMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SysUserMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *SysUserMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SysUserMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SysUserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[sysuser.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SysUserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SysUserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, sysuser.FieldStatus)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SysUserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SysUserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SysUserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sysuser.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SysUserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SysUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sysuser.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *SysUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *SysUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *SysUserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *SysUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *SysUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *SysUserMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *SysUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *SysUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *SysUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetDescription sets the "description" field.
func (m *SysUserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SysUserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SysUserMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[sysuser.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SysUserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SysUserMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, sysuser.FieldDescription)
}

// SetHomePath sets the "home_path" field.
func (m *SysUserMutation) SetHomePath(s string) {
	m.home_path = &s
}

// HomePath returns the value of the "home_path" field in the mutation.
func (m *SysUserMutation) HomePath() (r string, exists bool) {
	v := m.home_path
	if v == nil {
		return
	}
	return *v, true
}

// OldHomePath returns the old "home_path" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldHomePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomePath: %w", err)
	}
	return oldValue.HomePath, nil
}

// ResetHomePath resets all changes to the "home_path" field.
func (m *SysUserMutation) ResetHomePath() {
	m.home_path = nil
}

// SetMobile sets the "mobile" field.
func (m *SysUserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *SysUserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *SysUserMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[sysuser.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *SysUserMutation) MobileCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *SysUserMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, sysuser.FieldMobile)
}

// SetEmail sets the "email" field.
func (m *SysUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SysUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SysUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[sysuser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SysUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SysUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, sysuser.FieldEmail)
}

// SetAvatar sets the "avatar" field.
func (m *SysUserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *SysUserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *SysUserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[sysuser.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *SysUserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *SysUserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, sysuser.FieldAvatar)
}

// SetDepartmentID sets the "department_id" field.
func (m *SysUserMutation) SetDepartmentID(u uint64) {
	m.department_id = &u
	m.adddepartment_id = nil
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *SysUserMutation) DepartmentID() (r uint64, exists bool) {
	v := m.department_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldDepartmentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// AddDepartmentID adds u to the "department_id" field.
func (m *SysUserMutation) AddDepartmentID(u int64) {
	if m.adddepartment_id != nil {
		*m.adddepartment_id += u
	} else {
		m.adddepartment_id = &u
	}
}

// AddedDepartmentID returns the value that was added to the "department_id" field in this mutation.
func (m *SysUserMutation) AddedDepartmentID() (r int64, exists bool) {
	v := m.adddepartment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *SysUserMutation) ClearDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	m.clearedFields[sysuser.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *SysUserMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *SysUserMutation) ResetDepartmentID() {
	m.department_id = nil
	m.adddepartment_id = nil
	delete(m.clearedFields, sysuser.FieldDepartmentID)
}

// SetCompanyID sets the "company_id" field.
func (m *SysUserMutation) SetCompanyID(u uint64) {
	m.company_id = &u
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *SysUserMutation) CompanyID() (r uint64, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the SysUser entity.
// If the SysUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SysUserMutation) OldCompanyID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds u to the "company_id" field.
func (m *SysUserMutation) AddCompanyID(u int64) {
	if m.addcompany_id != nil {
		*m.addcompany_id += u
	} else {
		m.addcompany_id = &u
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *SysUserMutation) AddedCompanyID() (r int64, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompanyID clears the value of the "company_id" field.
func (m *SysUserMutation) ClearCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
	m.clearedFields[sysuser.FieldCompanyID] = struct{}{}
}

// CompanyIDCleared returns if the "company_id" field was cleared in this mutation.
func (m *SysUserMutation) CompanyIDCleared() bool {
	_, ok := m.clearedFields[sysuser.FieldCompanyID]
	return ok
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *SysUserMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
	delete(m.clearedFields, sysuser.FieldCompanyID)
}

// Where appends a list predicates to the SysUserMutation builder.
func (m *SysUserMutation) Where(ps ...predicate.SysUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SysUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SysUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SysUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SysUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SysUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SysUser).
func (m *SysUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SysUserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, sysuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sysuser.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, sysuser.FieldStatus)
	}
	if m.deleted_at != nil {
		fields = append(fields, sysuser.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, sysuser.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, sysuser.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, sysuser.FieldNickname)
	}
	if m.description != nil {
		fields = append(fields, sysuser.FieldDescription)
	}
	if m.home_path != nil {
		fields = append(fields, sysuser.FieldHomePath)
	}
	if m.mobile != nil {
		fields = append(fields, sysuser.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, sysuser.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, sysuser.FieldAvatar)
	}
	if m.department_id != nil {
		fields = append(fields, sysuser.FieldDepartmentID)
	}
	if m.company_id != nil {
		fields = append(fields, sysuser.FieldCompanyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SysUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sysuser.FieldCreatedAt:
		return m.CreatedAt()
	case sysuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case sysuser.FieldStatus:
		return m.Status()
	case sysuser.FieldDeletedAt:
		return m.DeletedAt()
	case sysuser.FieldUsername:
		return m.Username()
	case sysuser.FieldPassword:
		return m.Password()
	case sysuser.FieldNickname:
		return m.Nickname()
	case sysuser.FieldDescription:
		return m.Description()
	case sysuser.FieldHomePath:
		return m.HomePath()
	case sysuser.FieldMobile:
		return m.Mobile()
	case sysuser.FieldEmail:
		return m.Email()
	case sysuser.FieldAvatar:
		return m.Avatar()
	case sysuser.FieldDepartmentID:
		return m.DepartmentID()
	case sysuser.FieldCompanyID:
		return m.CompanyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SysUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sysuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sysuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sysuser.FieldStatus:
		return m.OldStatus(ctx)
	case sysuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sysuser.FieldUsername:
		return m.OldUsername(ctx)
	case sysuser.FieldPassword:
		return m.OldPassword(ctx)
	case sysuser.FieldNickname:
		return m.OldNickname(ctx)
	case sysuser.FieldDescription:
		return m.OldDescription(ctx)
	case sysuser.FieldHomePath:
		return m.OldHomePath(ctx)
	case sysuser.FieldMobile:
		return m.OldMobile(ctx)
	case sysuser.FieldEmail:
		return m.OldEmail(ctx)
	case sysuser.FieldAvatar:
		return m.OldAvatar(ctx)
	case sysuser.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case sysuser.FieldCompanyID:
		return m.OldCompanyID(ctx)
	}
	return nil, fmt.Errorf("unknown SysUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SysUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sysuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sysuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sysuser.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sysuser.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sysuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case sysuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case sysuser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case sysuser.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case sysuser.FieldHomePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomePath(v)
		return nil
	case sysuser.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case sysuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case sysuser.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case sysuser.FieldDepartmentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case sysuser.FieldCompanyID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	}
	return fmt.Errorf("unknown SysUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SysUserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, sysuser.FieldStatus)
	}
	if m.adddepartment_id != nil {
		fields = append(fields, sysuser.FieldDepartmentID)
	}
	if m.addcompany_id != nil {
		fields = append(fields, sysuser.FieldCompanyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SysUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sysuser.FieldStatus:
		return m.AddedStatus()
	case sysuser.FieldDepartmentID:
		return m.AddedDepartmentID()
	case sysuser.FieldCompanyID:
		return m.AddedCompanyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SysUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sysuser.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case sysuser.FieldDepartmentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartmentID(v)
		return nil
	case sysuser.FieldCompanyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	}
	return fmt.Errorf("unknown SysUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SysUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sysuser.FieldStatus) {
		fields = append(fields, sysuser.FieldStatus)
	}
	if m.FieldCleared(sysuser.FieldDeletedAt) {
		fields = append(fields, sysuser.FieldDeletedAt)
	}
	if m.FieldCleared(sysuser.FieldDescription) {
		fields = append(fields, sysuser.FieldDescription)
	}
	if m.FieldCleared(sysuser.FieldMobile) {
		fields = append(fields, sysuser.FieldMobile)
	}
	if m.FieldCleared(sysuser.FieldEmail) {
		fields = append(fields, sysuser.FieldEmail)
	}
	if m.FieldCleared(sysuser.FieldAvatar) {
		fields = append(fields, sysuser.FieldAvatar)
	}
	if m.FieldCleared(sysuser.FieldDepartmentID) {
		fields = append(fields, sysuser.FieldDepartmentID)
	}
	if m.FieldCleared(sysuser.FieldCompanyID) {
		fields = append(fields, sysuser.FieldCompanyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SysUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SysUserMutation) ClearField(name string) error {
	switch name {
	case sysuser.FieldStatus:
		m.ClearStatus()
		return nil
	case sysuser.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sysuser.FieldDescription:
		m.ClearDescription()
		return nil
	case sysuser.FieldMobile:
		m.ClearMobile()
		return nil
	case sysuser.FieldEmail:
		m.ClearEmail()
		return nil
	case sysuser.FieldAvatar:
		m.ClearAvatar()
		return nil
	case sysuser.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case sysuser.FieldCompanyID:
		m.ClearCompanyID()
		return nil
	}
	return fmt.Errorf("unknown SysUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SysUserMutation) ResetField(name string) error {
	switch name {
	case sysuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sysuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sysuser.FieldStatus:
		m.ResetStatus()
		return nil
	case sysuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sysuser.FieldUsername:
		m.ResetUsername()
		return nil
	case sysuser.FieldPassword:
		m.ResetPassword()
		return nil
	case sysuser.FieldNickname:
		m.ResetNickname()
		return nil
	case sysuser.FieldDescription:
		m.ResetDescription()
		return nil
	case sysuser.FieldHomePath:
		m.ResetHomePath()
		return nil
	case sysuser.FieldMobile:
		m.ResetMobile()
		return nil
	case sysuser.FieldEmail:
		m.ResetEmail()
		return nil
	case sysuser.FieldAvatar:
		m.ResetAvatar()
		return nil
	case sysuser.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case sysuser.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	}
	return fmt.Errorf("unknown SysUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SysUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SysUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SysUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SysUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SysUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SysUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SysUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SysUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SysUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SysUser edge %s", name)
}

// UpgradeApkMutation represents an operation that mutates the UpgradeApk nodes in the graph.
type UpgradeApkMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	name          *string
	package_name  *string
	description   *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeApk, error)
	predicates    []predicate.UpgradeApk
}

var _ ent.Mutation = (*UpgradeApkMutation)(nil)

// upgradeapkOption allows management of the mutation configuration using functional options.
type upgradeapkOption func(*UpgradeApkMutation)

// newUpgradeApkMutation creates new mutation for the UpgradeApk entity.
func newUpgradeApkMutation(c config, op Op, opts ...upgradeapkOption) *UpgradeApkMutation {
	m := &UpgradeApkMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeApk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeApkID sets the ID field of the mutation.
func withUpgradeApkID(id int) upgradeapkOption {
	return func(m *UpgradeApkMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeApk
		)
		m.oldValue = func(ctx context.Context) (*UpgradeApk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeApk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeApk sets the old UpgradeApk of the mutation.
func withUpgradeApk(node *UpgradeApk) upgradeapkOption {
	return func(m *UpgradeApkMutation) {
		m.oldValue = func(context.Context) (*UpgradeApk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeApkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeApkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeApk entities.
func (m *UpgradeApkMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeApkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeApkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeApk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeApkMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeApkMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeApkMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeApkMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeApkMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeApkMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeApkMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeApkMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UpgradeApkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeApkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeApkMutation) ResetName() {
	m.name = nil
}

// SetPackageName sets the "package_name" field.
func (m *UpgradeApkMutation) SetPackageName(s string) {
	m.package_name = &s
}

// PackageName returns the value of the "package_name" field in the mutation.
func (m *UpgradeApkMutation) PackageName() (r string, exists bool) {
	v := m.package_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageName returns the old "package_name" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldPackageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageName: %w", err)
	}
	return oldValue.PackageName, nil
}

// ResetPackageName resets all changes to the "package_name" field.
func (m *UpgradeApkMutation) ResetPackageName() {
	m.package_name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeApkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeApkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeApkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeapk.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeApkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeapk.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeApkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeapk.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeApkMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeApkMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeApkMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeApkMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeApkMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeApkMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeApkMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeApkMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeapk.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeApkMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapk.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeApkMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeapk.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeApkMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeApkMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeApk entity.
// If the UpgradeApk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeApkMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeapk.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeApkMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapk.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeApkMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeapk.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeApkMutation builder.
func (m *UpgradeApkMutation) Where(ps ...predicate.UpgradeApk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeApkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeApkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeApk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeApkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeApkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeApk).
func (m *UpgradeApkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeApkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.company_id != nil {
		fields = append(fields, upgradeapk.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradeapk.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, upgradeapk.FieldName)
	}
	if m.package_name != nil {
		fields = append(fields, upgradeapk.FieldPackageName)
	}
	if m.description != nil {
		fields = append(fields, upgradeapk.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeapk.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeapk.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeapk.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeApkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeapk.FieldCompanyID:
		return m.CompanyID()
	case upgradeapk.FieldKey:
		return m.Key()
	case upgradeapk.FieldName:
		return m.Name()
	case upgradeapk.FieldPackageName:
		return m.PackageName()
	case upgradeapk.FieldDescription:
		return m.Description()
	case upgradeapk.FieldIsDel:
		return m.IsDel()
	case upgradeapk.FieldCreateAt:
		return m.CreateAt()
	case upgradeapk.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeApkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeapk.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeapk.FieldKey:
		return m.OldKey(ctx)
	case upgradeapk.FieldName:
		return m.OldName(ctx)
	case upgradeapk.FieldPackageName:
		return m.OldPackageName(ctx)
	case upgradeapk.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeapk.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeapk.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeapk.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeApk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeapk.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeapk.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradeapk.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeapk.FieldPackageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageName(v)
		return nil
	case upgradeapk.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeapk.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeapk.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeapk.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeApkMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeapk.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeapk.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeApkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeapk.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeapk.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeapk.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeapk.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeApkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeapk.FieldDescription) {
		fields = append(fields, upgradeapk.FieldDescription)
	}
	if m.FieldCleared(upgradeapk.FieldCreateAt) {
		fields = append(fields, upgradeapk.FieldCreateAt)
	}
	if m.FieldCleared(upgradeapk.FieldUpdateAt) {
		fields = append(fields, upgradeapk.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeApkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeApkMutation) ClearField(name string) error {
	switch name {
	case upgradeapk.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeapk.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeapk.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeApkMutation) ResetField(name string) error {
	switch name {
	case upgradeapk.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeapk.FieldKey:
		m.ResetKey()
		return nil
	case upgradeapk.FieldName:
		m.ResetName()
		return nil
	case upgradeapk.FieldPackageName:
		m.ResetPackageName()
		return nil
	case upgradeapk.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeapk.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeapk.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeapk.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeApkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeApkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeApkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeApkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeApkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeApkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeApkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeApkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApk edge %s", name)
}

// UpgradeApkUpgradeStrategyMutation represents an operation that mutates the UpgradeApkUpgradeStrategy nodes in the graph.
type UpgradeApkUpgradeStrategyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	company_id              *int
	addcompany_id           *int
	enable                  *int32
	addenable               *int32
	name                    *string
	description             *string
	apk_id                  *int
	addapk_id               *int
	apk_version_id          *int
	addapk_version_id       *int
	begin_datetime          *time.Time
	end_datetime            *time.Time
	upgrade_type            *int32
	addupgrade_type         *int32
	prompt_upgrade_content  *string
	upgrade_dev_type        *int32
	addupgrade_dev_type     *int32
	upgrade_dev_data        *string
	upgrade_version_type    *int32
	addupgrade_version_type *int32
	upgrade_version_data    *string
	is_gray                 *int32
	addis_gray              *int32
	gray_data               *string
	is_flow_limit           *int32
	addis_flow_limit        *int32
	flow_limit_data         *string
	is_del                  *int32
	addis_del               *int32
	create_at               *time.Time
	update_at               *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*UpgradeApkUpgradeStrategy, error)
	predicates              []predicate.UpgradeApkUpgradeStrategy
}

var _ ent.Mutation = (*UpgradeApkUpgradeStrategyMutation)(nil)

// upgradeapkupgradestrategyOption allows management of the mutation configuration using functional options.
type upgradeapkupgradestrategyOption func(*UpgradeApkUpgradeStrategyMutation)

// newUpgradeApkUpgradeStrategyMutation creates new mutation for the UpgradeApkUpgradeStrategy entity.
func newUpgradeApkUpgradeStrategyMutation(c config, op Op, opts ...upgradeapkupgradestrategyOption) *UpgradeApkUpgradeStrategyMutation {
	m := &UpgradeApkUpgradeStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeApkUpgradeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeApkUpgradeStrategyID sets the ID field of the mutation.
func withUpgradeApkUpgradeStrategyID(id int) upgradeapkupgradestrategyOption {
	return func(m *UpgradeApkUpgradeStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeApkUpgradeStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeApkUpgradeStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeApkUpgradeStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeApkUpgradeStrategy sets the old UpgradeApkUpgradeStrategy of the mutation.
func withUpgradeApkUpgradeStrategy(node *UpgradeApkUpgradeStrategy) upgradeapkupgradestrategyOption {
	return func(m *UpgradeApkUpgradeStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeApkUpgradeStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeApkUpgradeStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeApkUpgradeStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeApkUpgradeStrategy entities.
func (m *UpgradeApkUpgradeStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeApkUpgradeStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeApkUpgradeStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetEnable sets the "enable" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetName sets the "name" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeApkUpgradeStrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeapkupgradestrategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeapkupgradestrategy.FieldDescription)
}

// SetApkID sets the "apk_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetApkID(i int) {
	m.apk_id = &i
	m.addapk_id = nil
}

// ApkID returns the value of the "apk_id" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) ApkID() (r int, exists bool) {
	v := m.apk_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApkID returns the old "apk_id" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldApkID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApkID: %w", err)
	}
	return oldValue.ApkID, nil
}

// AddApkID adds i to the "apk_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddApkID(i int) {
	if m.addapk_id != nil {
		*m.addapk_id += i
	} else {
		m.addapk_id = &i
	}
}

// AddedApkID returns the value that was added to the "apk_id" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedApkID() (r int, exists bool) {
	v := m.addapk_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetApkID resets all changes to the "apk_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetApkID() {
	m.apk_id = nil
	m.addapk_id = nil
}

// SetApkVersionID sets the "apk_version_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetApkVersionID(i int) {
	m.apk_version_id = &i
	m.addapk_version_id = nil
}

// ApkVersionID returns the value of the "apk_version_id" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) ApkVersionID() (r int, exists bool) {
	v := m.apk_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApkVersionID returns the old "apk_version_id" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldApkVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApkVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApkVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApkVersionID: %w", err)
	}
	return oldValue.ApkVersionID, nil
}

// AddApkVersionID adds i to the "apk_version_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddApkVersionID(i int) {
	if m.addapk_version_id != nil {
		*m.addapk_version_id += i
	} else {
		m.addapk_version_id = &i
	}
}

// AddedApkVersionID returns the value that was added to the "apk_version_id" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedApkVersionID() (r int, exists bool) {
	v := m.addapk_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetApkVersionID resets all changes to the "apk_version_id" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetApkVersionID() {
	m.apk_version_id = nil
	m.addapk_version_id = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetUpgradeType sets the "upgrade_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetUpgradeType(i int32) {
	m.upgrade_type = &i
	m.addupgrade_type = nil
}

// UpgradeType returns the value of the "upgrade_type" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) UpgradeType() (r int32, exists bool) {
	v := m.upgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeType returns the old "upgrade_type" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldUpgradeType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeType: %w", err)
	}
	return oldValue.UpgradeType, nil
}

// AddUpgradeType adds i to the "upgrade_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddUpgradeType(i int32) {
	if m.addupgrade_type != nil {
		*m.addupgrade_type += i
	} else {
		m.addupgrade_type = &i
	}
}

// AddedUpgradeType returns the value that was added to the "upgrade_type" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedUpgradeType() (r int32, exists bool) {
	v := m.addupgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeType resets all changes to the "upgrade_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetUpgradeType() {
	m.upgrade_type = nil
	m.addupgrade_type = nil
}

// SetPromptUpgradeContent sets the "prompt_upgrade_content" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetPromptUpgradeContent(s string) {
	m.prompt_upgrade_content = &s
}

// PromptUpgradeContent returns the value of the "prompt_upgrade_content" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) PromptUpgradeContent() (r string, exists bool) {
	v := m.prompt_upgrade_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptUpgradeContent returns the old "prompt_upgrade_content" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldPromptUpgradeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptUpgradeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptUpgradeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptUpgradeContent: %w", err)
	}
	return oldValue.PromptUpgradeContent, nil
}

// ClearPromptUpgradeContent clears the value of the "prompt_upgrade_content" field.
func (m *UpgradeApkUpgradeStrategyMutation) ClearPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	m.clearedFields[upgradeapkupgradestrategy.FieldPromptUpgradeContent] = struct{}{}
}

// PromptUpgradeContentCleared returns if the "prompt_upgrade_content" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) PromptUpgradeContentCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategy.FieldPromptUpgradeContent]
	return ok
}

// ResetPromptUpgradeContent resets all changes to the "prompt_upgrade_content" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	delete(m.clearedFields, upgradeapkupgradestrategy.FieldPromptUpgradeContent)
}

// SetUpgradeDevType sets the "upgrade_dev_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetUpgradeDevType(i int32) {
	m.upgrade_dev_type = &i
	m.addupgrade_dev_type = nil
}

// UpgradeDevType returns the value of the "upgrade_dev_type" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) UpgradeDevType() (r int32, exists bool) {
	v := m.upgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevType returns the old "upgrade_dev_type" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldUpgradeDevType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevType: %w", err)
	}
	return oldValue.UpgradeDevType, nil
}

// AddUpgradeDevType adds i to the "upgrade_dev_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddUpgradeDevType(i int32) {
	if m.addupgrade_dev_type != nil {
		*m.addupgrade_dev_type += i
	} else {
		m.addupgrade_dev_type = &i
	}
}

// AddedUpgradeDevType returns the value that was added to the "upgrade_dev_type" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedUpgradeDevType() (r int32, exists bool) {
	v := m.addupgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeDevType resets all changes to the "upgrade_dev_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetUpgradeDevType() {
	m.upgrade_dev_type = nil
	m.addupgrade_dev_type = nil
}

// SetUpgradeDevData sets the "upgrade_dev_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetUpgradeDevData(s string) {
	m.upgrade_dev_data = &s
}

// UpgradeDevData returns the value of the "upgrade_dev_data" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) UpgradeDevData() (r string, exists bool) {
	v := m.upgrade_dev_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevData returns the old "upgrade_dev_data" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldUpgradeDevData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevData: %w", err)
	}
	return oldValue.UpgradeDevData, nil
}

// ResetUpgradeDevData resets all changes to the "upgrade_dev_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetUpgradeDevData() {
	m.upgrade_dev_data = nil
}

// SetUpgradeVersionType sets the "upgrade_version_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetUpgradeVersionType(i int32) {
	m.upgrade_version_type = &i
	m.addupgrade_version_type = nil
}

// UpgradeVersionType returns the value of the "upgrade_version_type" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) UpgradeVersionType() (r int32, exists bool) {
	v := m.upgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionType returns the old "upgrade_version_type" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldUpgradeVersionType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionType: %w", err)
	}
	return oldValue.UpgradeVersionType, nil
}

// AddUpgradeVersionType adds i to the "upgrade_version_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddUpgradeVersionType(i int32) {
	if m.addupgrade_version_type != nil {
		*m.addupgrade_version_type += i
	} else {
		m.addupgrade_version_type = &i
	}
}

// AddedUpgradeVersionType returns the value that was added to the "upgrade_version_type" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedUpgradeVersionType() (r int32, exists bool) {
	v := m.addupgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeVersionType resets all changes to the "upgrade_version_type" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetUpgradeVersionType() {
	m.upgrade_version_type = nil
	m.addupgrade_version_type = nil
}

// SetUpgradeVersionData sets the "upgrade_version_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetUpgradeVersionData(s string) {
	m.upgrade_version_data = &s
}

// UpgradeVersionData returns the value of the "upgrade_version_data" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) UpgradeVersionData() (r string, exists bool) {
	v := m.upgrade_version_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionData returns the old "upgrade_version_data" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldUpgradeVersionData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionData: %w", err)
	}
	return oldValue.UpgradeVersionData, nil
}

// ResetUpgradeVersionData resets all changes to the "upgrade_version_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetUpgradeVersionData() {
	m.upgrade_version_data = nil
}

// SetIsGray sets the "is_gray" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetIsGray(i int32) {
	m.is_gray = &i
	m.addis_gray = nil
}

// IsGray returns the value of the "is_gray" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) IsGray() (r int32, exists bool) {
	v := m.is_gray
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGray returns the old "is_gray" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldIsGray(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGray: %w", err)
	}
	return oldValue.IsGray, nil
}

// AddIsGray adds i to the "is_gray" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddIsGray(i int32) {
	if m.addis_gray != nil {
		*m.addis_gray += i
	} else {
		m.addis_gray = &i
	}
}

// AddedIsGray returns the value that was added to the "is_gray" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedIsGray() (r int32, exists bool) {
	v := m.addis_gray
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsGray resets all changes to the "is_gray" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetIsGray() {
	m.is_gray = nil
	m.addis_gray = nil
}

// SetGrayData sets the "gray_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetGrayData(s string) {
	m.gray_data = &s
}

// GrayData returns the value of the "gray_data" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) GrayData() (r string, exists bool) {
	v := m.gray_data
	if v == nil {
		return
	}
	return *v, true
}

// OldGrayData returns the old "gray_data" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldGrayData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrayData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrayData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrayData: %w", err)
	}
	return oldValue.GrayData, nil
}

// ResetGrayData resets all changes to the "gray_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetGrayData() {
	m.gray_data = nil
}

// SetIsFlowLimit sets the "is_flow_limit" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetIsFlowLimit(i int32) {
	m.is_flow_limit = &i
	m.addis_flow_limit = nil
}

// IsFlowLimit returns the value of the "is_flow_limit" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) IsFlowLimit() (r int32, exists bool) {
	v := m.is_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlowLimit returns the old "is_flow_limit" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldIsFlowLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlowLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlowLimit: %w", err)
	}
	return oldValue.IsFlowLimit, nil
}

// AddIsFlowLimit adds i to the "is_flow_limit" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddIsFlowLimit(i int32) {
	if m.addis_flow_limit != nil {
		*m.addis_flow_limit += i
	} else {
		m.addis_flow_limit = &i
	}
}

// AddedIsFlowLimit returns the value that was added to the "is_flow_limit" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedIsFlowLimit() (r int32, exists bool) {
	v := m.addis_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFlowLimit resets all changes to the "is_flow_limit" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetIsFlowLimit() {
	m.is_flow_limit = nil
	m.addis_flow_limit = nil
}

// SetFlowLimitData sets the "flow_limit_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetFlowLimitData(s string) {
	m.flow_limit_data = &s
}

// FlowLimitData returns the value of the "flow_limit_data" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) FlowLimitData() (r string, exists bool) {
	v := m.flow_limit_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowLimitData returns the old "flow_limit_data" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldFlowLimitData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowLimitData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowLimitData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowLimitData: %w", err)
	}
	return oldValue.FlowLimitData, nil
}

// ResetFlowLimitData resets all changes to the "flow_limit_data" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetFlowLimitData() {
	m.flow_limit_data = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeApkUpgradeStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeApkUpgradeStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeapkupgradestrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeapkupgradestrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeApkUpgradeStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeApkUpgradeStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeApkUpgradeStrategy entity.
// If the UpgradeApkUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeApkUpgradeStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeapkupgradestrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeApkUpgradeStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeapkupgradestrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeApkUpgradeStrategyMutation builder.
func (m *UpgradeApkUpgradeStrategyMutation) Where(ps ...predicate.UpgradeApkUpgradeStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeApkUpgradeStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeApkUpgradeStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeApkUpgradeStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeApkUpgradeStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeApkUpgradeStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeApkUpgradeStrategy).
func (m *UpgradeApkUpgradeStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeApkUpgradeStrategyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.company_id != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldCompanyID)
	}
	if m.enable != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldDescription)
	}
	if m.apk_id != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldApkID)
	}
	if m.apk_version_id != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldApkVersionID)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldEndDatetime)
	}
	if m.upgrade_type != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeType)
	}
	if m.prompt_upgrade_content != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.upgrade_dev_type != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeDevType)
	}
	if m.upgrade_dev_data != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeDevData)
	}
	if m.upgrade_version_type != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeVersionType)
	}
	if m.upgrade_version_data != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeVersionData)
	}
	if m.is_gray != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldIsGray)
	}
	if m.gray_data != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldGrayData)
	}
	if m.is_flow_limit != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldIsFlowLimit)
	}
	if m.flow_limit_data != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldFlowLimitData)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeApkUpgradeStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkupgradestrategy.FieldCompanyID:
		return m.CompanyID()
	case upgradeapkupgradestrategy.FieldEnable:
		return m.Enable()
	case upgradeapkupgradestrategy.FieldName:
		return m.Name()
	case upgradeapkupgradestrategy.FieldDescription:
		return m.Description()
	case upgradeapkupgradestrategy.FieldApkID:
		return m.ApkID()
	case upgradeapkupgradestrategy.FieldApkVersionID:
		return m.ApkVersionID()
	case upgradeapkupgradestrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeapkupgradestrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeapkupgradestrategy.FieldUpgradeType:
		return m.UpgradeType()
	case upgradeapkupgradestrategy.FieldPromptUpgradeContent:
		return m.PromptUpgradeContent()
	case upgradeapkupgradestrategy.FieldUpgradeDevType:
		return m.UpgradeDevType()
	case upgradeapkupgradestrategy.FieldUpgradeDevData:
		return m.UpgradeDevData()
	case upgradeapkupgradestrategy.FieldUpgradeVersionType:
		return m.UpgradeVersionType()
	case upgradeapkupgradestrategy.FieldUpgradeVersionData:
		return m.UpgradeVersionData()
	case upgradeapkupgradestrategy.FieldIsGray:
		return m.IsGray()
	case upgradeapkupgradestrategy.FieldGrayData:
		return m.GrayData()
	case upgradeapkupgradestrategy.FieldIsFlowLimit:
		return m.IsFlowLimit()
	case upgradeapkupgradestrategy.FieldFlowLimitData:
		return m.FlowLimitData()
	case upgradeapkupgradestrategy.FieldIsDel:
		return m.IsDel()
	case upgradeapkupgradestrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeapkupgradestrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeApkUpgradeStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeapkupgradestrategy.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeapkupgradestrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeapkupgradestrategy.FieldName:
		return m.OldName(ctx)
	case upgradeapkupgradestrategy.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeapkupgradestrategy.FieldApkID:
		return m.OldApkID(ctx)
	case upgradeapkupgradestrategy.FieldApkVersionID:
		return m.OldApkVersionID(ctx)
	case upgradeapkupgradestrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeapkupgradestrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeapkupgradestrategy.FieldUpgradeType:
		return m.OldUpgradeType(ctx)
	case upgradeapkupgradestrategy.FieldPromptUpgradeContent:
		return m.OldPromptUpgradeContent(ctx)
	case upgradeapkupgradestrategy.FieldUpgradeDevType:
		return m.OldUpgradeDevType(ctx)
	case upgradeapkupgradestrategy.FieldUpgradeDevData:
		return m.OldUpgradeDevData(ctx)
	case upgradeapkupgradestrategy.FieldUpgradeVersionType:
		return m.OldUpgradeVersionType(ctx)
	case upgradeapkupgradestrategy.FieldUpgradeVersionData:
		return m.OldUpgradeVersionData(ctx)
	case upgradeapkupgradestrategy.FieldIsGray:
		return m.OldIsGray(ctx)
	case upgradeapkupgradestrategy.FieldGrayData:
		return m.OldGrayData(ctx)
	case upgradeapkupgradestrategy.FieldIsFlowLimit:
		return m.OldIsFlowLimit(ctx)
	case upgradeapkupgradestrategy.FieldFlowLimitData:
		return m.OldFlowLimitData(ctx)
	case upgradeapkupgradestrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeapkupgradestrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeapkupgradestrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeApkUpgradeStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkUpgradeStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeapkupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeapkupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeapkupgradestrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeapkupgradestrategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeapkupgradestrategy.FieldApkID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApkID(v)
		return nil
	case upgradeapkupgradestrategy.FieldApkVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApkVersionID(v)
		return nil
	case upgradeapkupgradestrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeapkupgradestrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeType(v)
		return nil
	case upgradeapkupgradestrategy.FieldPromptUpgradeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptUpgradeContent(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevType(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeDevData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevData(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionType(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeVersionData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionData(v)
		return nil
	case upgradeapkupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGray(v)
		return nil
	case upgradeapkupgradestrategy.FieldGrayData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrayData(v)
		return nil
	case upgradeapkupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlowLimit(v)
		return nil
	case upgradeapkupgradestrategy.FieldFlowLimitData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowLimitData(v)
		return nil
	case upgradeapkupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeapkupgradestrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldCompanyID)
	}
	if m.addenable != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldEnable)
	}
	if m.addapk_id != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldApkID)
	}
	if m.addapk_version_id != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldApkVersionID)
	}
	if m.addupgrade_type != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeType)
	}
	if m.addupgrade_dev_type != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeDevType)
	}
	if m.addupgrade_version_type != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpgradeVersionType)
	}
	if m.addis_gray != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldIsGray)
	}
	if m.addis_flow_limit != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldIsFlowLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeapkupgradestrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeApkUpgradeStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkupgradestrategy.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeapkupgradestrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeapkupgradestrategy.FieldApkID:
		return m.AddedApkID()
	case upgradeapkupgradestrategy.FieldApkVersionID:
		return m.AddedApkVersionID()
	case upgradeapkupgradestrategy.FieldUpgradeType:
		return m.AddedUpgradeType()
	case upgradeapkupgradestrategy.FieldUpgradeDevType:
		return m.AddedUpgradeDevType()
	case upgradeapkupgradestrategy.FieldUpgradeVersionType:
		return m.AddedUpgradeVersionType()
	case upgradeapkupgradestrategy.FieldIsGray:
		return m.AddedIsGray()
	case upgradeapkupgradestrategy.FieldIsFlowLimit:
		return m.AddedIsFlowLimit()
	case upgradeapkupgradestrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkUpgradeStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeapkupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeapkupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeapkupgradestrategy.FieldApkID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApkID(v)
		return nil
	case upgradeapkupgradestrategy.FieldApkVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApkVersionID(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeType(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeDevType(v)
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeVersionType(v)
		return nil
	case upgradeapkupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsGray(v)
		return nil
	case upgradeapkupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFlowLimit(v)
		return nil
	case upgradeapkupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeApkUpgradeStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeapkupgradestrategy.FieldDescription) {
		fields = append(fields, upgradeapkupgradestrategy.FieldDescription)
	}
	if m.FieldCleared(upgradeapkupgradestrategy.FieldPromptUpgradeContent) {
		fields = append(fields, upgradeapkupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.FieldCleared(upgradeapkupgradestrategy.FieldCreateAt) {
		fields = append(fields, upgradeapkupgradestrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeapkupgradestrategy.FieldUpdateAt) {
		fields = append(fields, upgradeapkupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeapkupgradestrategy.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeapkupgradestrategy.FieldPromptUpgradeContent:
		m.ClearPromptUpgradeContent()
		return nil
	case upgradeapkupgradestrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeapkupgradestrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeapkupgradestrategy.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeapkupgradestrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeapkupgradestrategy.FieldName:
		m.ResetName()
		return nil
	case upgradeapkupgradestrategy.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeapkupgradestrategy.FieldApkID:
		m.ResetApkID()
		return nil
	case upgradeapkupgradestrategy.FieldApkVersionID:
		m.ResetApkVersionID()
		return nil
	case upgradeapkupgradestrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeapkupgradestrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeType:
		m.ResetUpgradeType()
		return nil
	case upgradeapkupgradestrategy.FieldPromptUpgradeContent:
		m.ResetPromptUpgradeContent()
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeDevType:
		m.ResetUpgradeDevType()
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeDevData:
		m.ResetUpgradeDevData()
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeVersionType:
		m.ResetUpgradeVersionType()
		return nil
	case upgradeapkupgradestrategy.FieldUpgradeVersionData:
		m.ResetUpgradeVersionData()
		return nil
	case upgradeapkupgradestrategy.FieldIsGray:
		m.ResetIsGray()
		return nil
	case upgradeapkupgradestrategy.FieldGrayData:
		m.ResetGrayData()
		return nil
	case upgradeapkupgradestrategy.FieldIsFlowLimit:
		m.ResetIsFlowLimit()
		return nil
	case upgradeapkupgradestrategy.FieldFlowLimitData:
		m.ResetFlowLimitData()
		return nil
	case upgradeapkupgradestrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeapkupgradestrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeapkupgradestrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategy edge %s", name)
}

// UpgradeApkUpgradeStrategyFlowLimitStrategyMutation represents an operation that mutates the UpgradeApkUpgradeStrategyFlowLimitStrategy nodes in the graph.
type UpgradeApkUpgradeStrategyFlowLimitStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	enable        *int32
	addenable     *int32
	begin_time    *string
	end_time      *string
	dimension     *int32
	adddimension  *int32
	_limit        *int
	add_limit     *int
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeApkUpgradeStrategyFlowLimitStrategy, error)
	predicates    []predicate.UpgradeApkUpgradeStrategyFlowLimitStrategy
}

var _ ent.Mutation = (*UpgradeApkUpgradeStrategyFlowLimitStrategyMutation)(nil)

// upgradeapkupgradestrategyflowlimitstrategyOption allows management of the mutation configuration using functional options.
type upgradeapkupgradestrategyflowlimitstrategyOption func(*UpgradeApkUpgradeStrategyFlowLimitStrategyMutation)

// newUpgradeApkUpgradeStrategyFlowLimitStrategyMutation creates new mutation for the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
func newUpgradeApkUpgradeStrategyFlowLimitStrategyMutation(c config, op Op, opts ...upgradeapkupgradestrategyflowlimitstrategyOption) *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation {
	m := &UpgradeApkUpgradeStrategyFlowLimitStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeApkUpgradeStrategyFlowLimitStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeApkUpgradeStrategyFlowLimitStrategyID sets the ID field of the mutation.
func withUpgradeApkUpgradeStrategyFlowLimitStrategyID(id int) upgradeapkupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeApkUpgradeStrategyFlowLimitStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeApkUpgradeStrategyFlowLimitStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeApkUpgradeStrategyFlowLimitStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeApkUpgradeStrategyFlowLimitStrategy sets the old UpgradeApkUpgradeStrategyFlowLimitStrategy of the mutation.
func withUpgradeApkUpgradeStrategyFlowLimitStrategy(node *UpgradeApkUpgradeStrategyFlowLimitStrategy) upgradeapkupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeApkUpgradeStrategyFlowLimitStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeApkUpgradeStrategyFlowLimitStrategy entities.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeApkUpgradeStrategyFlowLimitStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginTime sets the "begin_time" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetBeginTime(s string) {
	m.begin_time = &s
}

// BeginTime returns the value of the "begin_time" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) BeginTime() (r string, exists bool) {
	v := m.begin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "begin_time" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldBeginTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "begin_time" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetBeginTime() {
	m.begin_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDimension sets the "dimension" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetDimension(i int32) {
	m.dimension = &i
	m.adddimension = nil
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Dimension() (r int32, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldDimension(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// AddDimension adds i to the "dimension" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddDimension(i int32) {
	if m.adddimension != nil {
		*m.adddimension += i
	} else {
		m.adddimension = &i
	}
}

// AddedDimension returns the value that was added to the "dimension" field in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedDimension() (r int32, exists bool) {
	v := m.adddimension
	if v == nil {
		return
	}
	return *v, true
}

// ResetDimension resets all changes to the "dimension" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetDimension() {
	m.dimension = nil
	m.adddimension = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeApkUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeApkUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeApkUpgradeStrategyFlowLimitStrategyMutation builder.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Where(ps ...predicate.UpgradeApkUpgradeStrategyFlowLimitStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeApkUpgradeStrategyFlowLimitStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeApkUpgradeStrategyFlowLimitStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeApkUpgradeStrategyFlowLimitStrategy).
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.enable != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.begin_time != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldBeginTime)
	}
	if m.end_time != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldEndTime)
	}
	if m.dimension != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m._limit != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEnable:
		return m.Enable()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.BeginTime()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.EndTime()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldDimension:
		return m.Dimension()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldLimit:
		return m.Limit()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.IsDel()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeapkupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.OldEndTime(ctx)
	case upgradeapkupgradestrategyflowlimitstrategy.FieldDimension:
		return m.OldDimension(ctx)
	case upgradeapkupgradestrategyflowlimitstrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeApkUpgradeStrategyFlowLimitStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldBeginTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.adddimension != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldDimension:
		return m.AddedDimension()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimension(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyFlowLimitStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt) {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt) {
		fields = append(fields, upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyFlowLimitStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldEndTime:
		m.ResetEndTime()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldDimension:
		m.ResetDimension()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeapkupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyFlowLimitStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyFlowLimitStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyFlowLimitStrategy edge %s", name)
}

// UpgradeApkUpgradeStrategyGrayStrategyMutation represents an operation that mutates the UpgradeApkUpgradeStrategyGrayStrategy nodes in the graph.
type UpgradeApkUpgradeStrategyGrayStrategyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	enable         *int32
	addenable      *int32
	begin_datetime *time.Time
	end_datetime   *time.Time
	_limit         *int
	add_limit      *int
	is_del         *int32
	addis_del      *int32
	create_at      *time.Time
	update_at      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UpgradeApkUpgradeStrategyGrayStrategy, error)
	predicates     []predicate.UpgradeApkUpgradeStrategyGrayStrategy
}

var _ ent.Mutation = (*UpgradeApkUpgradeStrategyGrayStrategyMutation)(nil)

// upgradeapkupgradestrategygraystrategyOption allows management of the mutation configuration using functional options.
type upgradeapkupgradestrategygraystrategyOption func(*UpgradeApkUpgradeStrategyGrayStrategyMutation)

// newUpgradeApkUpgradeStrategyGrayStrategyMutation creates new mutation for the UpgradeApkUpgradeStrategyGrayStrategy entity.
func newUpgradeApkUpgradeStrategyGrayStrategyMutation(c config, op Op, opts ...upgradeapkupgradestrategygraystrategyOption) *UpgradeApkUpgradeStrategyGrayStrategyMutation {
	m := &UpgradeApkUpgradeStrategyGrayStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeApkUpgradeStrategyGrayStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeApkUpgradeStrategyGrayStrategyID sets the ID field of the mutation.
func withUpgradeApkUpgradeStrategyGrayStrategyID(id int) upgradeapkupgradestrategygraystrategyOption {
	return func(m *UpgradeApkUpgradeStrategyGrayStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeApkUpgradeStrategyGrayStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeApkUpgradeStrategyGrayStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeApkUpgradeStrategyGrayStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeApkUpgradeStrategyGrayStrategy sets the old UpgradeApkUpgradeStrategyGrayStrategy of the mutation.
func withUpgradeApkUpgradeStrategyGrayStrategy(node *UpgradeApkUpgradeStrategyGrayStrategy) upgradeapkupgradestrategygraystrategyOption {
	return func(m *UpgradeApkUpgradeStrategyGrayStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeApkUpgradeStrategyGrayStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeApkUpgradeStrategyGrayStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeApkUpgradeStrategyGrayStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeApkUpgradeStrategyGrayStrategy entities.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeApkUpgradeStrategyGrayStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeApkUpgradeStrategyGrayStrategy entity.
// If the UpgradeApkUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeApkUpgradeStrategyGrayStrategy entity.
// If the UpgradeApkUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeApkUpgradeStrategyGrayStrategy entity.
// If the UpgradeApkUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeApkUpgradeStrategyGrayStrategy entity.
// If the UpgradeApkUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeApkUpgradeStrategyGrayStrategy entity.
// If the UpgradeApkUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeApkUpgradeStrategyGrayStrategy entity.
// If the UpgradeApkUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeapkupgradestrategygraystrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategygraystrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeapkupgradestrategygraystrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeApkUpgradeStrategyGrayStrategy entity.
// If the UpgradeApkUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeapkupgradestrategygraystrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkupgradestrategygraystrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeapkupgradestrategygraystrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeApkUpgradeStrategyGrayStrategyMutation builder.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) Where(ps ...predicate.UpgradeApkUpgradeStrategyGrayStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeApkUpgradeStrategyGrayStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeApkUpgradeStrategyGrayStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeApkUpgradeStrategyGrayStrategy).
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.enable != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldEnable)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldEndDatetime)
	}
	if m._limit != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkupgradestrategygraystrategy.FieldEnable:
		return m.Enable()
	case upgradeapkupgradestrategygraystrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeapkupgradestrategygraystrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeapkupgradestrategygraystrategy.FieldLimit:
		return m.Limit()
	case upgradeapkupgradestrategygraystrategy.FieldIsDel:
		return m.IsDel()
	case upgradeapkupgradestrategygraystrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeapkupgradestrategygraystrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeapkupgradestrategygraystrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeapkupgradestrategygraystrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeapkupgradestrategygraystrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeapkupgradestrategygraystrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeapkupgradestrategygraystrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeapkupgradestrategygraystrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeapkupgradestrategygraystrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeApkUpgradeStrategyGrayStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeapkupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyGrayStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldEnable)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkupgradestrategygraystrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeapkupgradestrategygraystrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeapkupgradestrategygraystrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeapkupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyGrayStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeapkupgradestrategygraystrategy.FieldCreateAt) {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeapkupgradestrategygraystrategy.FieldUpdateAt) {
		fields = append(fields, upgradeapkupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeapkupgradestrategygraystrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyGrayStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeapkupgradestrategygraystrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeapkupgradestrategygraystrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyGrayStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyGrayStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeApkUpgradeStrategyGrayStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkUpgradeStrategyGrayStrategy edge %s", name)
}

// UpgradeApkVersionMutation represents an operation that mutates the UpgradeApkVersion nodes in the graph.
type UpgradeApkVersionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	company_id      *int
	addcompany_id   *int
	apk_id          *int
	addapk_id       *int
	cloud_file_id   *string
	version_name    *string
	version_code    *int
	addversion_code *int
	description     *string
	is_del          *int32
	addis_del       *int32
	create_at       *time.Time
	update_at       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UpgradeApkVersion, error)
	predicates      []predicate.UpgradeApkVersion
}

var _ ent.Mutation = (*UpgradeApkVersionMutation)(nil)

// upgradeapkversionOption allows management of the mutation configuration using functional options.
type upgradeapkversionOption func(*UpgradeApkVersionMutation)

// newUpgradeApkVersionMutation creates new mutation for the UpgradeApkVersion entity.
func newUpgradeApkVersionMutation(c config, op Op, opts ...upgradeapkversionOption) *UpgradeApkVersionMutation {
	m := &UpgradeApkVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeApkVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeApkVersionID sets the ID field of the mutation.
func withUpgradeApkVersionID(id int) upgradeapkversionOption {
	return func(m *UpgradeApkVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeApkVersion
		)
		m.oldValue = func(ctx context.Context) (*UpgradeApkVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeApkVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeApkVersion sets the old UpgradeApkVersion of the mutation.
func withUpgradeApkVersion(node *UpgradeApkVersion) upgradeapkversionOption {
	return func(m *UpgradeApkVersionMutation) {
		m.oldValue = func(context.Context) (*UpgradeApkVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeApkVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeApkVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeApkVersion entities.
func (m *UpgradeApkVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeApkVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeApkVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeApkVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeApkVersionMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeApkVersionMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeApkVersionMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeApkVersionMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeApkVersionMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetApkID sets the "apk_id" field.
func (m *UpgradeApkVersionMutation) SetApkID(i int) {
	m.apk_id = &i
	m.addapk_id = nil
}

// ApkID returns the value of the "apk_id" field in the mutation.
func (m *UpgradeApkVersionMutation) ApkID() (r int, exists bool) {
	v := m.apk_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApkID returns the old "apk_id" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldApkID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApkID: %w", err)
	}
	return oldValue.ApkID, nil
}

// AddApkID adds i to the "apk_id" field.
func (m *UpgradeApkVersionMutation) AddApkID(i int) {
	if m.addapk_id != nil {
		*m.addapk_id += i
	} else {
		m.addapk_id = &i
	}
}

// AddedApkID returns the value that was added to the "apk_id" field in this mutation.
func (m *UpgradeApkVersionMutation) AddedApkID() (r int, exists bool) {
	v := m.addapk_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetApkID resets all changes to the "apk_id" field.
func (m *UpgradeApkVersionMutation) ResetApkID() {
	m.apk_id = nil
	m.addapk_id = nil
}

// SetCloudFileID sets the "cloud_file_id" field.
func (m *UpgradeApkVersionMutation) SetCloudFileID(s string) {
	m.cloud_file_id = &s
}

// CloudFileID returns the value of the "cloud_file_id" field in the mutation.
func (m *UpgradeApkVersionMutation) CloudFileID() (r string, exists bool) {
	v := m.cloud_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudFileID returns the old "cloud_file_id" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldCloudFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudFileID: %w", err)
	}
	return oldValue.CloudFileID, nil
}

// ResetCloudFileID resets all changes to the "cloud_file_id" field.
func (m *UpgradeApkVersionMutation) ResetCloudFileID() {
	m.cloud_file_id = nil
}

// SetVersionName sets the "version_name" field.
func (m *UpgradeApkVersionMutation) SetVersionName(s string) {
	m.version_name = &s
}

// VersionName returns the value of the "version_name" field in the mutation.
func (m *UpgradeApkVersionMutation) VersionName() (r string, exists bool) {
	v := m.version_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionName returns the old "version_name" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldVersionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionName: %w", err)
	}
	return oldValue.VersionName, nil
}

// ResetVersionName resets all changes to the "version_name" field.
func (m *UpgradeApkVersionMutation) ResetVersionName() {
	m.version_name = nil
}

// SetVersionCode sets the "version_code" field.
func (m *UpgradeApkVersionMutation) SetVersionCode(i int) {
	m.version_code = &i
	m.addversion_code = nil
}

// VersionCode returns the value of the "version_code" field in the mutation.
func (m *UpgradeApkVersionMutation) VersionCode() (r int, exists bool) {
	v := m.version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionCode returns the old "version_code" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldVersionCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionCode: %w", err)
	}
	return oldValue.VersionCode, nil
}

// AddVersionCode adds i to the "version_code" field.
func (m *UpgradeApkVersionMutation) AddVersionCode(i int) {
	if m.addversion_code != nil {
		*m.addversion_code += i
	} else {
		m.addversion_code = &i
	}
}

// AddedVersionCode returns the value that was added to the "version_code" field in this mutation.
func (m *UpgradeApkVersionMutation) AddedVersionCode() (r int, exists bool) {
	v := m.addversion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionCode resets all changes to the "version_code" field.
func (m *UpgradeApkVersionMutation) ResetVersionCode() {
	m.version_code = nil
	m.addversion_code = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeApkVersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeApkVersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeApkVersionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeapkversion.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeApkVersionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeapkversion.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeApkVersionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeapkversion.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeApkVersionMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeApkVersionMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeApkVersionMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeApkVersionMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeApkVersionMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeApkVersionMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeApkVersionMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeApkVersionMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeapkversion.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeApkVersionMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkversion.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeApkVersionMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeapkversion.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeApkVersionMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeApkVersionMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeApkVersion entity.
// If the UpgradeApkVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeApkVersionMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeApkVersionMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeapkversion.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeApkVersionMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeapkversion.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeApkVersionMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeapkversion.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeApkVersionMutation builder.
func (m *UpgradeApkVersionMutation) Where(ps ...predicate.UpgradeApkVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeApkVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeApkVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeApkVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeApkVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeApkVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeApkVersion).
func (m *UpgradeApkVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeApkVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.company_id != nil {
		fields = append(fields, upgradeapkversion.FieldCompanyID)
	}
	if m.apk_id != nil {
		fields = append(fields, upgradeapkversion.FieldApkID)
	}
	if m.cloud_file_id != nil {
		fields = append(fields, upgradeapkversion.FieldCloudFileID)
	}
	if m.version_name != nil {
		fields = append(fields, upgradeapkversion.FieldVersionName)
	}
	if m.version_code != nil {
		fields = append(fields, upgradeapkversion.FieldVersionCode)
	}
	if m.description != nil {
		fields = append(fields, upgradeapkversion.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeapkversion.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeapkversion.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeapkversion.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeApkVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkversion.FieldCompanyID:
		return m.CompanyID()
	case upgradeapkversion.FieldApkID:
		return m.ApkID()
	case upgradeapkversion.FieldCloudFileID:
		return m.CloudFileID()
	case upgradeapkversion.FieldVersionName:
		return m.VersionName()
	case upgradeapkversion.FieldVersionCode:
		return m.VersionCode()
	case upgradeapkversion.FieldDescription:
		return m.Description()
	case upgradeapkversion.FieldIsDel:
		return m.IsDel()
	case upgradeapkversion.FieldCreateAt:
		return m.CreateAt()
	case upgradeapkversion.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeApkVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeapkversion.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeapkversion.FieldApkID:
		return m.OldApkID(ctx)
	case upgradeapkversion.FieldCloudFileID:
		return m.OldCloudFileID(ctx)
	case upgradeapkversion.FieldVersionName:
		return m.OldVersionName(ctx)
	case upgradeapkversion.FieldVersionCode:
		return m.OldVersionCode(ctx)
	case upgradeapkversion.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeapkversion.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeapkversion.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeapkversion.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeApkVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeapkversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeapkversion.FieldApkID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApkID(v)
		return nil
	case upgradeapkversion.FieldCloudFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudFileID(v)
		return nil
	case upgradeapkversion.FieldVersionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionName(v)
		return nil
	case upgradeapkversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionCode(v)
		return nil
	case upgradeapkversion.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeapkversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeapkversion.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeapkversion.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeApkVersionMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeapkversion.FieldCompanyID)
	}
	if m.addapk_id != nil {
		fields = append(fields, upgradeapkversion.FieldApkID)
	}
	if m.addversion_code != nil {
		fields = append(fields, upgradeapkversion.FieldVersionCode)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeapkversion.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeApkVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeapkversion.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeapkversion.FieldApkID:
		return m.AddedApkID()
	case upgradeapkversion.FieldVersionCode:
		return m.AddedVersionCode()
	case upgradeapkversion.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeApkVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeapkversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeapkversion.FieldApkID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApkID(v)
		return nil
	case upgradeapkversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionCode(v)
		return nil
	case upgradeapkversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeApkVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeapkversion.FieldDescription) {
		fields = append(fields, upgradeapkversion.FieldDescription)
	}
	if m.FieldCleared(upgradeapkversion.FieldCreateAt) {
		fields = append(fields, upgradeapkversion.FieldCreateAt)
	}
	if m.FieldCleared(upgradeapkversion.FieldUpdateAt) {
		fields = append(fields, upgradeapkversion.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeApkVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeApkVersionMutation) ClearField(name string) error {
	switch name {
	case upgradeapkversion.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeapkversion.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeapkversion.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeApkVersionMutation) ResetField(name string) error {
	switch name {
	case upgradeapkversion.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeapkversion.FieldApkID:
		m.ResetApkID()
		return nil
	case upgradeapkversion.FieldCloudFileID:
		m.ResetCloudFileID()
		return nil
	case upgradeapkversion.FieldVersionName:
		m.ResetVersionName()
		return nil
	case upgradeapkversion.FieldVersionCode:
		m.ResetVersionCode()
		return nil
	case upgradeapkversion.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeapkversion.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeapkversion.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeapkversion.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeApkVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeApkVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeApkVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeApkVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeApkVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeApkVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeApkVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeApkVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeApkVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeApkVersion edge %s", name)
}

// UpgradeAppDownloadReportLogMutation represents an operation that mutates the UpgradeAppDownloadReportLog nodes in the graph.
type UpgradeAppDownloadReportLogMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	company_id          *int
	addcompany_id       *int
	timestamp           *time.Time
	app_key             *string
	app_version_id      *int
	addapp_version_id   *int
	app_version_code    *int
	addapp_version_code *int
	app_version_target  *string
	app_version_arch    *string
	create_at           *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*UpgradeAppDownloadReportLog, error)
	predicates          []predicate.UpgradeAppDownloadReportLog
}

var _ ent.Mutation = (*UpgradeAppDownloadReportLogMutation)(nil)

// upgradeappdownloadreportlogOption allows management of the mutation configuration using functional options.
type upgradeappdownloadreportlogOption func(*UpgradeAppDownloadReportLogMutation)

// newUpgradeAppDownloadReportLogMutation creates new mutation for the UpgradeAppDownloadReportLog entity.
func newUpgradeAppDownloadReportLogMutation(c config, op Op, opts ...upgradeappdownloadreportlogOption) *UpgradeAppDownloadReportLogMutation {
	m := &UpgradeAppDownloadReportLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeAppDownloadReportLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeAppDownloadReportLogID sets the ID field of the mutation.
func withUpgradeAppDownloadReportLogID(id int) upgradeappdownloadreportlogOption {
	return func(m *UpgradeAppDownloadReportLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeAppDownloadReportLog
		)
		m.oldValue = func(ctx context.Context) (*UpgradeAppDownloadReportLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeAppDownloadReportLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeAppDownloadReportLog sets the old UpgradeAppDownloadReportLog of the mutation.
func withUpgradeAppDownloadReportLog(node *UpgradeAppDownloadReportLog) upgradeappdownloadreportlogOption {
	return func(m *UpgradeAppDownloadReportLogMutation) {
		m.oldValue = func(context.Context) (*UpgradeAppDownloadReportLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeAppDownloadReportLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeAppDownloadReportLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeAppDownloadReportLog entities.
func (m *UpgradeAppDownloadReportLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeAppDownloadReportLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeAppDownloadReportLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeAppDownloadReportLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeAppDownloadReportLogMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeAppDownloadReportLogMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *UpgradeAppDownloadReportLogMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ClearTimestamp clears the value of the "timestamp" field.
func (m *UpgradeAppDownloadReportLogMutation) ClearTimestamp() {
	m.timestamp = nil
	m.clearedFields[upgradeappdownloadreportlog.FieldTimestamp] = struct{}{}
}

// TimestampCleared returns if the "timestamp" field was cleared in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) TimestampCleared() bool {
	_, ok := m.clearedFields[upgradeappdownloadreportlog.FieldTimestamp]
	return ok
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetTimestamp() {
	m.timestamp = nil
	delete(m.clearedFields, upgradeappdownloadreportlog.FieldTimestamp)
}

// SetAppKey sets the "app_key" field.
func (m *UpgradeAppDownloadReportLogMutation) SetAppKey(s string) {
	m.app_key = &s
}

// AppKey returns the value of the "app_key" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) AppKey() (r string, exists bool) {
	v := m.app_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAppKey returns the old "app_key" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldAppKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppKey: %w", err)
	}
	return oldValue.AppKey, nil
}

// ResetAppKey resets all changes to the "app_key" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetAppKey() {
	m.app_key = nil
}

// SetAppVersionID sets the "app_version_id" field.
func (m *UpgradeAppDownloadReportLogMutation) SetAppVersionID(i int) {
	m.app_version_id = &i
	m.addapp_version_id = nil
}

// AppVersionID returns the value of the "app_version_id" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) AppVersionID() (r int, exists bool) {
	v := m.app_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersionID returns the old "app_version_id" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldAppVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersionID: %w", err)
	}
	return oldValue.AppVersionID, nil
}

// AddAppVersionID adds i to the "app_version_id" field.
func (m *UpgradeAppDownloadReportLogMutation) AddAppVersionID(i int) {
	if m.addapp_version_id != nil {
		*m.addapp_version_id += i
	} else {
		m.addapp_version_id = &i
	}
}

// AddedAppVersionID returns the value that was added to the "app_version_id" field in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AddedAppVersionID() (r int, exists bool) {
	v := m.addapp_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppVersionID resets all changes to the "app_version_id" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetAppVersionID() {
	m.app_version_id = nil
	m.addapp_version_id = nil
}

// SetAppVersionCode sets the "app_version_code" field.
func (m *UpgradeAppDownloadReportLogMutation) SetAppVersionCode(i int) {
	m.app_version_code = &i
	m.addapp_version_code = nil
}

// AppVersionCode returns the value of the "app_version_code" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) AppVersionCode() (r int, exists bool) {
	v := m.app_version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersionCode returns the old "app_version_code" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldAppVersionCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersionCode: %w", err)
	}
	return oldValue.AppVersionCode, nil
}

// AddAppVersionCode adds i to the "app_version_code" field.
func (m *UpgradeAppDownloadReportLogMutation) AddAppVersionCode(i int) {
	if m.addapp_version_code != nil {
		*m.addapp_version_code += i
	} else {
		m.addapp_version_code = &i
	}
}

// AddedAppVersionCode returns the value that was added to the "app_version_code" field in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AddedAppVersionCode() (r int, exists bool) {
	v := m.addapp_version_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppVersionCode resets all changes to the "app_version_code" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetAppVersionCode() {
	m.app_version_code = nil
	m.addapp_version_code = nil
}

// SetAppVersionTarget sets the "app_version_target" field.
func (m *UpgradeAppDownloadReportLogMutation) SetAppVersionTarget(s string) {
	m.app_version_target = &s
}

// AppVersionTarget returns the value of the "app_version_target" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) AppVersionTarget() (r string, exists bool) {
	v := m.app_version_target
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersionTarget returns the old "app_version_target" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldAppVersionTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersionTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersionTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersionTarget: %w", err)
	}
	return oldValue.AppVersionTarget, nil
}

// ClearAppVersionTarget clears the value of the "app_version_target" field.
func (m *UpgradeAppDownloadReportLogMutation) ClearAppVersionTarget() {
	m.app_version_target = nil
	m.clearedFields[upgradeappdownloadreportlog.FieldAppVersionTarget] = struct{}{}
}

// AppVersionTargetCleared returns if the "app_version_target" field was cleared in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AppVersionTargetCleared() bool {
	_, ok := m.clearedFields[upgradeappdownloadreportlog.FieldAppVersionTarget]
	return ok
}

// ResetAppVersionTarget resets all changes to the "app_version_target" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetAppVersionTarget() {
	m.app_version_target = nil
	delete(m.clearedFields, upgradeappdownloadreportlog.FieldAppVersionTarget)
}

// SetAppVersionArch sets the "app_version_arch" field.
func (m *UpgradeAppDownloadReportLogMutation) SetAppVersionArch(s string) {
	m.app_version_arch = &s
}

// AppVersionArch returns the value of the "app_version_arch" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) AppVersionArch() (r string, exists bool) {
	v := m.app_version_arch
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersionArch returns the old "app_version_arch" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldAppVersionArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersionArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersionArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersionArch: %w", err)
	}
	return oldValue.AppVersionArch, nil
}

// ClearAppVersionArch clears the value of the "app_version_arch" field.
func (m *UpgradeAppDownloadReportLogMutation) ClearAppVersionArch() {
	m.app_version_arch = nil
	m.clearedFields[upgradeappdownloadreportlog.FieldAppVersionArch] = struct{}{}
}

// AppVersionArchCleared returns if the "app_version_arch" field was cleared in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AppVersionArchCleared() bool {
	_, ok := m.clearedFields[upgradeappdownloadreportlog.FieldAppVersionArch]
	return ok
}

// ResetAppVersionArch resets all changes to the "app_version_arch" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetAppVersionArch() {
	m.app_version_arch = nil
	delete(m.clearedFields, upgradeappdownloadreportlog.FieldAppVersionArch)
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeAppDownloadReportLogMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeAppDownloadReportLogMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeAppDownloadReportLog entity.
// If the UpgradeAppDownloadReportLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeAppDownloadReportLogMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeAppDownloadReportLogMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeappdownloadreportlog.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeappdownloadreportlog.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeAppDownloadReportLogMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeappdownloadreportlog.FieldCreateAt)
}

// Where appends a list predicates to the UpgradeAppDownloadReportLogMutation builder.
func (m *UpgradeAppDownloadReportLogMutation) Where(ps ...predicate.UpgradeAppDownloadReportLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeAppDownloadReportLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeAppDownloadReportLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeAppDownloadReportLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeAppDownloadReportLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeAppDownloadReportLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeAppDownloadReportLog).
func (m *UpgradeAppDownloadReportLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeAppDownloadReportLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.company_id != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldCompanyID)
	}
	if m.timestamp != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldTimestamp)
	}
	if m.app_key != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppKey)
	}
	if m.app_version_id != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionID)
	}
	if m.app_version_code != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionCode)
	}
	if m.app_version_target != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionTarget)
	}
	if m.app_version_arch != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionArch)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldCreateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeAppDownloadReportLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeappdownloadreportlog.FieldCompanyID:
		return m.CompanyID()
	case upgradeappdownloadreportlog.FieldTimestamp:
		return m.Timestamp()
	case upgradeappdownloadreportlog.FieldAppKey:
		return m.AppKey()
	case upgradeappdownloadreportlog.FieldAppVersionID:
		return m.AppVersionID()
	case upgradeappdownloadreportlog.FieldAppVersionCode:
		return m.AppVersionCode()
	case upgradeappdownloadreportlog.FieldAppVersionTarget:
		return m.AppVersionTarget()
	case upgradeappdownloadreportlog.FieldAppVersionArch:
		return m.AppVersionArch()
	case upgradeappdownloadreportlog.FieldCreateAt:
		return m.CreateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeAppDownloadReportLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeappdownloadreportlog.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeappdownloadreportlog.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case upgradeappdownloadreportlog.FieldAppKey:
		return m.OldAppKey(ctx)
	case upgradeappdownloadreportlog.FieldAppVersionID:
		return m.OldAppVersionID(ctx)
	case upgradeappdownloadreportlog.FieldAppVersionCode:
		return m.OldAppVersionCode(ctx)
	case upgradeappdownloadreportlog.FieldAppVersionTarget:
		return m.OldAppVersionTarget(ctx)
	case upgradeappdownloadreportlog.FieldAppVersionArch:
		return m.OldAppVersionArch(ctx)
	case upgradeappdownloadreportlog.FieldCreateAt:
		return m.OldCreateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeAppDownloadReportLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeAppDownloadReportLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeappdownloadreportlog.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeappdownloadreportlog.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case upgradeappdownloadreportlog.FieldAppKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppKey(v)
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersionID(v)
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersionCode(v)
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersionTarget(v)
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersionArch(v)
		return nil
	case upgradeappdownloadreportlog.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeAppDownloadReportLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldCompanyID)
	}
	if m.addapp_version_id != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionID)
	}
	if m.addapp_version_code != nil {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeAppDownloadReportLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeappdownloadreportlog.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeappdownloadreportlog.FieldAppVersionID:
		return m.AddedAppVersionID()
	case upgradeappdownloadreportlog.FieldAppVersionCode:
		return m.AddedAppVersionCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeAppDownloadReportLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeappdownloadreportlog.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppVersionID(v)
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppVersionCode(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeAppDownloadReportLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeAppDownloadReportLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeappdownloadreportlog.FieldTimestamp) {
		fields = append(fields, upgradeappdownloadreportlog.FieldTimestamp)
	}
	if m.FieldCleared(upgradeappdownloadreportlog.FieldAppVersionTarget) {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionTarget)
	}
	if m.FieldCleared(upgradeappdownloadreportlog.FieldAppVersionArch) {
		fields = append(fields, upgradeappdownloadreportlog.FieldAppVersionArch)
	}
	if m.FieldCleared(upgradeappdownloadreportlog.FieldCreateAt) {
		fields = append(fields, upgradeappdownloadreportlog.FieldCreateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeAppDownloadReportLogMutation) ClearField(name string) error {
	switch name {
	case upgradeappdownloadreportlog.FieldTimestamp:
		m.ClearTimestamp()
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionTarget:
		m.ClearAppVersionTarget()
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionArch:
		m.ClearAppVersionArch()
		return nil
	case upgradeappdownloadreportlog.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeAppDownloadReportLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeAppDownloadReportLogMutation) ResetField(name string) error {
	switch name {
	case upgradeappdownloadreportlog.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeappdownloadreportlog.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case upgradeappdownloadreportlog.FieldAppKey:
		m.ResetAppKey()
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionID:
		m.ResetAppVersionID()
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionCode:
		m.ResetAppVersionCode()
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionTarget:
		m.ResetAppVersionTarget()
		return nil
	case upgradeappdownloadreportlog.FieldAppVersionArch:
		m.ResetAppVersionArch()
		return nil
	case upgradeappdownloadreportlog.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeAppDownloadReportLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeAppDownloadReportLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeAppDownloadReportLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeAppDownloadReportLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeAppDownloadReportLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeAppDownloadReportLog edge %s", name)
}

// UpgradeCompanyIncomeMutation represents an operation that mutates the UpgradeCompanyIncome nodes in the graph.
type UpgradeCompanyIncomeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	company_id       *int
	addcompany_id    *int
	income_type      *int8
	addincome_type   *int8
	income_amount    *int
	addincome_amount *int
	income_time      *time.Time
	remark           *string
	status           *int32
	addstatus        *int32
	is_del           *int32
	addis_del        *int32
	create_at        *time.Time
	update_at        *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*UpgradeCompanyIncome, error)
	predicates       []predicate.UpgradeCompanyIncome
}

var _ ent.Mutation = (*UpgradeCompanyIncomeMutation)(nil)

// upgradecompanyincomeOption allows management of the mutation configuration using functional options.
type upgradecompanyincomeOption func(*UpgradeCompanyIncomeMutation)

// newUpgradeCompanyIncomeMutation creates new mutation for the UpgradeCompanyIncome entity.
func newUpgradeCompanyIncomeMutation(c config, op Op, opts ...upgradecompanyincomeOption) *UpgradeCompanyIncomeMutation {
	m := &UpgradeCompanyIncomeMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeCompanyIncome,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeCompanyIncomeID sets the ID field of the mutation.
func withUpgradeCompanyIncomeID(id int) upgradecompanyincomeOption {
	return func(m *UpgradeCompanyIncomeMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeCompanyIncome
		)
		m.oldValue = func(ctx context.Context) (*UpgradeCompanyIncome, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeCompanyIncome.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeCompanyIncome sets the old UpgradeCompanyIncome of the mutation.
func withUpgradeCompanyIncome(node *UpgradeCompanyIncome) upgradecompanyincomeOption {
	return func(m *UpgradeCompanyIncomeMutation) {
		m.oldValue = func(context.Context) (*UpgradeCompanyIncome, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeCompanyIncomeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeCompanyIncomeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeCompanyIncome entities.
func (m *UpgradeCompanyIncomeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeCompanyIncomeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeCompanyIncomeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeCompanyIncome.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeCompanyIncomeMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeCompanyIncomeMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeCompanyIncomeMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetIncomeType sets the "income_type" field.
func (m *UpgradeCompanyIncomeMutation) SetIncomeType(i int8) {
	m.income_type = &i
	m.addincome_type = nil
}

// IncomeType returns the value of the "income_type" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) IncomeType() (r int8, exists bool) {
	v := m.income_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIncomeType returns the old "income_type" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldIncomeType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncomeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncomeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncomeType: %w", err)
	}
	return oldValue.IncomeType, nil
}

// AddIncomeType adds i to the "income_type" field.
func (m *UpgradeCompanyIncomeMutation) AddIncomeType(i int8) {
	if m.addincome_type != nil {
		*m.addincome_type += i
	} else {
		m.addincome_type = &i
	}
}

// AddedIncomeType returns the value that was added to the "income_type" field in this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedIncomeType() (r int8, exists bool) {
	v := m.addincome_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetIncomeType resets all changes to the "income_type" field.
func (m *UpgradeCompanyIncomeMutation) ResetIncomeType() {
	m.income_type = nil
	m.addincome_type = nil
}

// SetIncomeAmount sets the "income_amount" field.
func (m *UpgradeCompanyIncomeMutation) SetIncomeAmount(i int) {
	m.income_amount = &i
	m.addincome_amount = nil
}

// IncomeAmount returns the value of the "income_amount" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) IncomeAmount() (r int, exists bool) {
	v := m.income_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldIncomeAmount returns the old "income_amount" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldIncomeAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncomeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncomeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncomeAmount: %w", err)
	}
	return oldValue.IncomeAmount, nil
}

// AddIncomeAmount adds i to the "income_amount" field.
func (m *UpgradeCompanyIncomeMutation) AddIncomeAmount(i int) {
	if m.addincome_amount != nil {
		*m.addincome_amount += i
	} else {
		m.addincome_amount = &i
	}
}

// AddedIncomeAmount returns the value that was added to the "income_amount" field in this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedIncomeAmount() (r int, exists bool) {
	v := m.addincome_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetIncomeAmount resets all changes to the "income_amount" field.
func (m *UpgradeCompanyIncomeMutation) ResetIncomeAmount() {
	m.income_amount = nil
	m.addincome_amount = nil
}

// SetIncomeTime sets the "income_time" field.
func (m *UpgradeCompanyIncomeMutation) SetIncomeTime(t time.Time) {
	m.income_time = &t
}

// IncomeTime returns the value of the "income_time" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) IncomeTime() (r time.Time, exists bool) {
	v := m.income_time
	if v == nil {
		return
	}
	return *v, true
}

// OldIncomeTime returns the old "income_time" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldIncomeTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncomeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncomeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncomeTime: %w", err)
	}
	return oldValue.IncomeTime, nil
}

// ClearIncomeTime clears the value of the "income_time" field.
func (m *UpgradeCompanyIncomeMutation) ClearIncomeTime() {
	m.income_time = nil
	m.clearedFields[upgradecompanyincome.FieldIncomeTime] = struct{}{}
}

// IncomeTimeCleared returns if the "income_time" field was cleared in this mutation.
func (m *UpgradeCompanyIncomeMutation) IncomeTimeCleared() bool {
	_, ok := m.clearedFields[upgradecompanyincome.FieldIncomeTime]
	return ok
}

// ResetIncomeTime resets all changes to the "income_time" field.
func (m *UpgradeCompanyIncomeMutation) ResetIncomeTime() {
	m.income_time = nil
	delete(m.clearedFields, upgradecompanyincome.FieldIncomeTime)
}

// SetRemark sets the "remark" field.
func (m *UpgradeCompanyIncomeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *UpgradeCompanyIncomeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[upgradecompanyincome.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *UpgradeCompanyIncomeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[upgradecompanyincome.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *UpgradeCompanyIncomeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, upgradecompanyincome.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *UpgradeCompanyIncomeMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UpgradeCompanyIncomeMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UpgradeCompanyIncomeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeCompanyIncomeMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeCompanyIncomeMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeCompanyIncomeMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeCompanyIncomeMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeCompanyIncomeMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradecompanyincome.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeCompanyIncomeMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradecompanyincome.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeCompanyIncomeMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradecompanyincome.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeCompanyIncomeMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeCompanyIncomeMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeCompanyIncome entity.
// If the UpgradeCompanyIncome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyIncomeMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeCompanyIncomeMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradecompanyincome.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeCompanyIncomeMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradecompanyincome.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeCompanyIncomeMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradecompanyincome.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeCompanyIncomeMutation builder.
func (m *UpgradeCompanyIncomeMutation) Where(ps ...predicate.UpgradeCompanyIncome) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeCompanyIncomeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeCompanyIncomeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeCompanyIncome, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeCompanyIncomeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeCompanyIncomeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeCompanyIncome).
func (m *UpgradeCompanyIncomeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeCompanyIncomeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.company_id != nil {
		fields = append(fields, upgradecompanyincome.FieldCompanyID)
	}
	if m.income_type != nil {
		fields = append(fields, upgradecompanyincome.FieldIncomeType)
	}
	if m.income_amount != nil {
		fields = append(fields, upgradecompanyincome.FieldIncomeAmount)
	}
	if m.income_time != nil {
		fields = append(fields, upgradecompanyincome.FieldIncomeTime)
	}
	if m.remark != nil {
		fields = append(fields, upgradecompanyincome.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, upgradecompanyincome.FieldStatus)
	}
	if m.is_del != nil {
		fields = append(fields, upgradecompanyincome.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradecompanyincome.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradecompanyincome.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeCompanyIncomeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradecompanyincome.FieldCompanyID:
		return m.CompanyID()
	case upgradecompanyincome.FieldIncomeType:
		return m.IncomeType()
	case upgradecompanyincome.FieldIncomeAmount:
		return m.IncomeAmount()
	case upgradecompanyincome.FieldIncomeTime:
		return m.IncomeTime()
	case upgradecompanyincome.FieldRemark:
		return m.Remark()
	case upgradecompanyincome.FieldStatus:
		return m.Status()
	case upgradecompanyincome.FieldIsDel:
		return m.IsDel()
	case upgradecompanyincome.FieldCreateAt:
		return m.CreateAt()
	case upgradecompanyincome.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeCompanyIncomeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradecompanyincome.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradecompanyincome.FieldIncomeType:
		return m.OldIncomeType(ctx)
	case upgradecompanyincome.FieldIncomeAmount:
		return m.OldIncomeAmount(ctx)
	case upgradecompanyincome.FieldIncomeTime:
		return m.OldIncomeTime(ctx)
	case upgradecompanyincome.FieldRemark:
		return m.OldRemark(ctx)
	case upgradecompanyincome.FieldStatus:
		return m.OldStatus(ctx)
	case upgradecompanyincome.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradecompanyincome.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradecompanyincome.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeCompanyIncome field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeCompanyIncomeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradecompanyincome.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradecompanyincome.FieldIncomeType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncomeType(v)
		return nil
	case upgradecompanyincome.FieldIncomeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncomeAmount(v)
		return nil
	case upgradecompanyincome.FieldIncomeTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncomeTime(v)
		return nil
	case upgradecompanyincome.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case upgradecompanyincome.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case upgradecompanyincome.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradecompanyincome.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradecompanyincome.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyIncome field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradecompanyincome.FieldCompanyID)
	}
	if m.addincome_type != nil {
		fields = append(fields, upgradecompanyincome.FieldIncomeType)
	}
	if m.addincome_amount != nil {
		fields = append(fields, upgradecompanyincome.FieldIncomeAmount)
	}
	if m.addstatus != nil {
		fields = append(fields, upgradecompanyincome.FieldStatus)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradecompanyincome.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeCompanyIncomeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradecompanyincome.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradecompanyincome.FieldIncomeType:
		return m.AddedIncomeType()
	case upgradecompanyincome.FieldIncomeAmount:
		return m.AddedIncomeAmount()
	case upgradecompanyincome.FieldStatus:
		return m.AddedStatus()
	case upgradecompanyincome.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeCompanyIncomeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradecompanyincome.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradecompanyincome.FieldIncomeType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncomeType(v)
		return nil
	case upgradecompanyincome.FieldIncomeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIncomeAmount(v)
		return nil
	case upgradecompanyincome.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case upgradecompanyincome.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyIncome numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeCompanyIncomeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradecompanyincome.FieldIncomeTime) {
		fields = append(fields, upgradecompanyincome.FieldIncomeTime)
	}
	if m.FieldCleared(upgradecompanyincome.FieldRemark) {
		fields = append(fields, upgradecompanyincome.FieldRemark)
	}
	if m.FieldCleared(upgradecompanyincome.FieldCreateAt) {
		fields = append(fields, upgradecompanyincome.FieldCreateAt)
	}
	if m.FieldCleared(upgradecompanyincome.FieldUpdateAt) {
		fields = append(fields, upgradecompanyincome.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeCompanyIncomeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeCompanyIncomeMutation) ClearField(name string) error {
	switch name {
	case upgradecompanyincome.FieldIncomeTime:
		m.ClearIncomeTime()
		return nil
	case upgradecompanyincome.FieldRemark:
		m.ClearRemark()
		return nil
	case upgradecompanyincome.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradecompanyincome.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyIncome nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeCompanyIncomeMutation) ResetField(name string) error {
	switch name {
	case upgradecompanyincome.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradecompanyincome.FieldIncomeType:
		m.ResetIncomeType()
		return nil
	case upgradecompanyincome.FieldIncomeAmount:
		m.ResetIncomeAmount()
		return nil
	case upgradecompanyincome.FieldIncomeTime:
		m.ResetIncomeTime()
		return nil
	case upgradecompanyincome.FieldRemark:
		m.ResetRemark()
		return nil
	case upgradecompanyincome.FieldStatus:
		m.ResetStatus()
		return nil
	case upgradecompanyincome.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradecompanyincome.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradecompanyincome.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyIncome field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeCompanyIncomeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeCompanyIncomeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeCompanyIncomeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeCompanyIncomeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeCompanyIncomeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeCompanyIncomeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeCompanyIncome unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeCompanyIncomeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeCompanyIncome edge %s", name)
}

// UpgradeCompanyTrafficPacketMutation represents an operation that mutates the UpgradeCompanyTrafficPacket nodes in the graph.
type UpgradeCompanyTrafficPacketMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	company_id        *int
	addcompany_id     *int
	packet_id         *int
	addpacket_id      *int
	start_time        *time.Time
	end_time          *time.Time
	initial_size      *int
	addinitial_size   *int
	remaining_size    *int
	addremaining_size *int
	status            *int32
	addstatus         *int32
	exchange_time     *time.Time
	create_at         *time.Time
	update_at         *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*UpgradeCompanyTrafficPacket, error)
	predicates        []predicate.UpgradeCompanyTrafficPacket
}

var _ ent.Mutation = (*UpgradeCompanyTrafficPacketMutation)(nil)

// upgradecompanytrafficpacketOption allows management of the mutation configuration using functional options.
type upgradecompanytrafficpacketOption func(*UpgradeCompanyTrafficPacketMutation)

// newUpgradeCompanyTrafficPacketMutation creates new mutation for the UpgradeCompanyTrafficPacket entity.
func newUpgradeCompanyTrafficPacketMutation(c config, op Op, opts ...upgradecompanytrafficpacketOption) *UpgradeCompanyTrafficPacketMutation {
	m := &UpgradeCompanyTrafficPacketMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeCompanyTrafficPacket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeCompanyTrafficPacketID sets the ID field of the mutation.
func withUpgradeCompanyTrafficPacketID(id uint64) upgradecompanytrafficpacketOption {
	return func(m *UpgradeCompanyTrafficPacketMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeCompanyTrafficPacket
		)
		m.oldValue = func(ctx context.Context) (*UpgradeCompanyTrafficPacket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeCompanyTrafficPacket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeCompanyTrafficPacket sets the old UpgradeCompanyTrafficPacket of the mutation.
func withUpgradeCompanyTrafficPacket(node *UpgradeCompanyTrafficPacket) upgradecompanytrafficpacketOption {
	return func(m *UpgradeCompanyTrafficPacketMutation) {
		m.oldValue = func(context.Context) (*UpgradeCompanyTrafficPacket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeCompanyTrafficPacketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeCompanyTrafficPacketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeCompanyTrafficPacket entities.
func (m *UpgradeCompanyTrafficPacketMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeCompanyTrafficPacketMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeCompanyTrafficPacket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeCompanyTrafficPacketMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetPacketID sets the "packet_id" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetPacketID(i int) {
	m.packet_id = &i
	m.addpacket_id = nil
}

// PacketID returns the value of the "packet_id" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) PacketID() (r int, exists bool) {
	v := m.packet_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPacketID returns the old "packet_id" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldPacketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPacketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPacketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPacketID: %w", err)
	}
	return oldValue.PacketID, nil
}

// AddPacketID adds i to the "packet_id" field.
func (m *UpgradeCompanyTrafficPacketMutation) AddPacketID(i int) {
	if m.addpacket_id != nil {
		*m.addpacket_id += i
	} else {
		m.addpacket_id = &i
	}
}

// AddedPacketID returns the value that was added to the "packet_id" field in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedPacketID() (r int, exists bool) {
	v := m.addpacket_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPacketID resets all changes to the "packet_id" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetPacketID() {
	m.packet_id = nil
	m.addpacket_id = nil
}

// SetStartTime sets the "start_time" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetEndTime() {
	m.end_time = nil
}

// SetInitialSize sets the "initial_size" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetInitialSize(i int) {
	m.initial_size = &i
	m.addinitial_size = nil
}

// InitialSize returns the value of the "initial_size" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) InitialSize() (r int, exists bool) {
	v := m.initial_size
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialSize returns the old "initial_size" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldInitialSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialSize: %w", err)
	}
	return oldValue.InitialSize, nil
}

// AddInitialSize adds i to the "initial_size" field.
func (m *UpgradeCompanyTrafficPacketMutation) AddInitialSize(i int) {
	if m.addinitial_size != nil {
		*m.addinitial_size += i
	} else {
		m.addinitial_size = &i
	}
}

// AddedInitialSize returns the value that was added to the "initial_size" field in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedInitialSize() (r int, exists bool) {
	v := m.addinitial_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetInitialSize resets all changes to the "initial_size" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetInitialSize() {
	m.initial_size = nil
	m.addinitial_size = nil
}

// SetRemainingSize sets the "remaining_size" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetRemainingSize(i int) {
	m.remaining_size = &i
	m.addremaining_size = nil
}

// RemainingSize returns the value of the "remaining_size" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) RemainingSize() (r int, exists bool) {
	v := m.remaining_size
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingSize returns the old "remaining_size" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldRemainingSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingSize: %w", err)
	}
	return oldValue.RemainingSize, nil
}

// AddRemainingSize adds i to the "remaining_size" field.
func (m *UpgradeCompanyTrafficPacketMutation) AddRemainingSize(i int) {
	if m.addremaining_size != nil {
		*m.addremaining_size += i
	} else {
		m.addremaining_size = &i
	}
}

// AddedRemainingSize returns the value that was added to the "remaining_size" field in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedRemainingSize() (r int, exists bool) {
	v := m.addremaining_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemainingSize resets all changes to the "remaining_size" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetRemainingSize() {
	m.remaining_size = nil
	m.addremaining_size = nil
}

// SetStatus sets the "status" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UpgradeCompanyTrafficPacketMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetExchangeTime sets the "exchange_time" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetExchangeTime(t time.Time) {
	m.exchange_time = &t
}

// ExchangeTime returns the value of the "exchange_time" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) ExchangeTime() (r time.Time, exists bool) {
	v := m.exchange_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeTime returns the old "exchange_time" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldExchangeTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeTime: %w", err)
	}
	return oldValue.ExchangeTime, nil
}

// ResetExchangeTime resets all changes to the "exchange_time" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetExchangeTime() {
	m.exchange_time = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeCompanyTrafficPacketMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradecompanytrafficpacket.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradecompanytrafficpacket.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradecompanytrafficpacket.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeCompanyTrafficPacketMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeCompanyTrafficPacketMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeCompanyTrafficPacket entity.
// If the UpgradeCompanyTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeCompanyTrafficPacketMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeCompanyTrafficPacketMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradecompanytrafficpacket.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradecompanytrafficpacket.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeCompanyTrafficPacketMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradecompanytrafficpacket.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeCompanyTrafficPacketMutation builder.
func (m *UpgradeCompanyTrafficPacketMutation) Where(ps ...predicate.UpgradeCompanyTrafficPacket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeCompanyTrafficPacketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeCompanyTrafficPacketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeCompanyTrafficPacket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeCompanyTrafficPacketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeCompanyTrafficPacketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeCompanyTrafficPacket).
func (m *UpgradeCompanyTrafficPacketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeCompanyTrafficPacketMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.company_id != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldCompanyID)
	}
	if m.packet_id != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldPacketID)
	}
	if m.start_time != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldEndTime)
	}
	if m.initial_size != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldInitialSize)
	}
	if m.remaining_size != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldRemainingSize)
	}
	if m.status != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldStatus)
	}
	if m.exchange_time != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldExchangeTime)
	}
	if m.create_at != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeCompanyTrafficPacketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradecompanytrafficpacket.FieldCompanyID:
		return m.CompanyID()
	case upgradecompanytrafficpacket.FieldPacketID:
		return m.PacketID()
	case upgradecompanytrafficpacket.FieldStartTime:
		return m.StartTime()
	case upgradecompanytrafficpacket.FieldEndTime:
		return m.EndTime()
	case upgradecompanytrafficpacket.FieldInitialSize:
		return m.InitialSize()
	case upgradecompanytrafficpacket.FieldRemainingSize:
		return m.RemainingSize()
	case upgradecompanytrafficpacket.FieldStatus:
		return m.Status()
	case upgradecompanytrafficpacket.FieldExchangeTime:
		return m.ExchangeTime()
	case upgradecompanytrafficpacket.FieldCreateAt:
		return m.CreateAt()
	case upgradecompanytrafficpacket.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeCompanyTrafficPacketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradecompanytrafficpacket.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradecompanytrafficpacket.FieldPacketID:
		return m.OldPacketID(ctx)
	case upgradecompanytrafficpacket.FieldStartTime:
		return m.OldStartTime(ctx)
	case upgradecompanytrafficpacket.FieldEndTime:
		return m.OldEndTime(ctx)
	case upgradecompanytrafficpacket.FieldInitialSize:
		return m.OldInitialSize(ctx)
	case upgradecompanytrafficpacket.FieldRemainingSize:
		return m.OldRemainingSize(ctx)
	case upgradecompanytrafficpacket.FieldStatus:
		return m.OldStatus(ctx)
	case upgradecompanytrafficpacket.FieldExchangeTime:
		return m.OldExchangeTime(ctx)
	case upgradecompanytrafficpacket.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradecompanytrafficpacket.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeCompanyTrafficPacket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeCompanyTrafficPacketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradecompanytrafficpacket.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradecompanytrafficpacket.FieldPacketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPacketID(v)
		return nil
	case upgradecompanytrafficpacket.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case upgradecompanytrafficpacket.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case upgradecompanytrafficpacket.FieldInitialSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialSize(v)
		return nil
	case upgradecompanytrafficpacket.FieldRemainingSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingSize(v)
		return nil
	case upgradecompanytrafficpacket.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case upgradecompanytrafficpacket.FieldExchangeTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeTime(v)
		return nil
	case upgradecompanytrafficpacket.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradecompanytrafficpacket.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyTrafficPacket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldCompanyID)
	}
	if m.addpacket_id != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldPacketID)
	}
	if m.addinitial_size != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldInitialSize)
	}
	if m.addremaining_size != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldRemainingSize)
	}
	if m.addstatus != nil {
		fields = append(fields, upgradecompanytrafficpacket.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeCompanyTrafficPacketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradecompanytrafficpacket.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradecompanytrafficpacket.FieldPacketID:
		return m.AddedPacketID()
	case upgradecompanytrafficpacket.FieldInitialSize:
		return m.AddedInitialSize()
	case upgradecompanytrafficpacket.FieldRemainingSize:
		return m.AddedRemainingSize()
	case upgradecompanytrafficpacket.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeCompanyTrafficPacketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradecompanytrafficpacket.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradecompanytrafficpacket.FieldPacketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPacketID(v)
		return nil
	case upgradecompanytrafficpacket.FieldInitialSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitialSize(v)
		return nil
	case upgradecompanytrafficpacket.FieldRemainingSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingSize(v)
		return nil
	case upgradecompanytrafficpacket.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyTrafficPacket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeCompanyTrafficPacketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradecompanytrafficpacket.FieldCreateAt) {
		fields = append(fields, upgradecompanytrafficpacket.FieldCreateAt)
	}
	if m.FieldCleared(upgradecompanytrafficpacket.FieldUpdateAt) {
		fields = append(fields, upgradecompanytrafficpacket.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeCompanyTrafficPacketMutation) ClearField(name string) error {
	switch name {
	case upgradecompanytrafficpacket.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradecompanytrafficpacket.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyTrafficPacket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeCompanyTrafficPacketMutation) ResetField(name string) error {
	switch name {
	case upgradecompanytrafficpacket.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradecompanytrafficpacket.FieldPacketID:
		m.ResetPacketID()
		return nil
	case upgradecompanytrafficpacket.FieldStartTime:
		m.ResetStartTime()
		return nil
	case upgradecompanytrafficpacket.FieldEndTime:
		m.ResetEndTime()
		return nil
	case upgradecompanytrafficpacket.FieldInitialSize:
		m.ResetInitialSize()
		return nil
	case upgradecompanytrafficpacket.FieldRemainingSize:
		m.ResetRemainingSize()
		return nil
	case upgradecompanytrafficpacket.FieldStatus:
		m.ResetStatus()
		return nil
	case upgradecompanytrafficpacket.FieldExchangeTime:
		m.ResetExchangeTime()
		return nil
	case upgradecompanytrafficpacket.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradecompanytrafficpacket.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeCompanyTrafficPacket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeCompanyTrafficPacketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeCompanyTrafficPacketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeCompanyTrafficPacket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeCompanyTrafficPacketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeCompanyTrafficPacket edge %s", name)
}

// UpgradeConfigurationMutation represents an operation that mutates the UpgradeConfiguration nodes in the graph.
type UpgradeConfigurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	name          *string
	description   *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeConfiguration, error)
	predicates    []predicate.UpgradeConfiguration
}

var _ ent.Mutation = (*UpgradeConfigurationMutation)(nil)

// upgradeconfigurationOption allows management of the mutation configuration using functional options.
type upgradeconfigurationOption func(*UpgradeConfigurationMutation)

// newUpgradeConfigurationMutation creates new mutation for the UpgradeConfiguration entity.
func newUpgradeConfigurationMutation(c config, op Op, opts ...upgradeconfigurationOption) *UpgradeConfigurationMutation {
	m := &UpgradeConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeConfigurationID sets the ID field of the mutation.
func withUpgradeConfigurationID(id int) upgradeconfigurationOption {
	return func(m *UpgradeConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeConfiguration
		)
		m.oldValue = func(ctx context.Context) (*UpgradeConfiguration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeConfiguration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeConfiguration sets the old UpgradeConfiguration of the mutation.
func withUpgradeConfiguration(node *UpgradeConfiguration) upgradeconfigurationOption {
	return func(m *UpgradeConfigurationMutation) {
		m.oldValue = func(context.Context) (*UpgradeConfiguration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeConfiguration entities.
func (m *UpgradeConfigurationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeConfigurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeConfigurationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeConfiguration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeConfigurationMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeConfigurationMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeConfiguration entity.
// If the UpgradeConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeConfigurationMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeConfigurationMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeConfigurationMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeConfigurationMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeConfigurationMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeConfiguration entity.
// If the UpgradeConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeConfigurationMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UpgradeConfigurationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeConfigurationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeConfiguration entity.
// If the UpgradeConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeConfigurationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeConfigurationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeConfigurationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeConfiguration entity.
// If the UpgradeConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeConfigurationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeconfiguration.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeConfigurationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeconfiguration.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeConfigurationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeconfiguration.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeConfigurationMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeConfigurationMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeConfiguration entity.
// If the UpgradeConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeConfigurationMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeConfigurationMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeConfigurationMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeConfigurationMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeConfigurationMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeConfiguration entity.
// If the UpgradeConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeConfigurationMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeconfiguration.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeConfigurationMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfiguration.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeConfigurationMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeconfiguration.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeConfigurationMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeConfigurationMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeConfiguration entity.
// If the UpgradeConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeConfigurationMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeconfiguration.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeConfigurationMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfiguration.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeConfigurationMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeconfiguration.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeConfigurationMutation builder.
func (m *UpgradeConfigurationMutation) Where(ps ...predicate.UpgradeConfiguration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeConfigurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeConfigurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeConfiguration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeConfigurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeConfigurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeConfiguration).
func (m *UpgradeConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.company_id != nil {
		fields = append(fields, upgradeconfiguration.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradeconfiguration.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, upgradeconfiguration.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradeconfiguration.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeconfiguration.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeconfiguration.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeconfiguration.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfiguration.FieldCompanyID:
		return m.CompanyID()
	case upgradeconfiguration.FieldKey:
		return m.Key()
	case upgradeconfiguration.FieldName:
		return m.Name()
	case upgradeconfiguration.FieldDescription:
		return m.Description()
	case upgradeconfiguration.FieldIsDel:
		return m.IsDel()
	case upgradeconfiguration.FieldCreateAt:
		return m.CreateAt()
	case upgradeconfiguration.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeconfiguration.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeconfiguration.FieldKey:
		return m.OldKey(ctx)
	case upgradeconfiguration.FieldName:
		return m.OldName(ctx)
	case upgradeconfiguration.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeconfiguration.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeconfiguration.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeconfiguration.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeConfiguration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeconfiguration.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeconfiguration.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradeconfiguration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeconfiguration.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeconfiguration.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeconfiguration.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeconfiguration.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfiguration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeConfigurationMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeconfiguration.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeconfiguration.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfiguration.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeconfiguration.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeconfiguration.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeconfiguration.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfiguration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeConfigurationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeconfiguration.FieldDescription) {
		fields = append(fields, upgradeconfiguration.FieldDescription)
	}
	if m.FieldCleared(upgradeconfiguration.FieldCreateAt) {
		fields = append(fields, upgradeconfiguration.FieldCreateAt)
	}
	if m.FieldCleared(upgradeconfiguration.FieldUpdateAt) {
		fields = append(fields, upgradeconfiguration.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeConfigurationMutation) ClearField(name string) error {
	switch name {
	case upgradeconfiguration.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeconfiguration.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeconfiguration.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfiguration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeConfigurationMutation) ResetField(name string) error {
	switch name {
	case upgradeconfiguration.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeconfiguration.FieldKey:
		m.ResetKey()
		return nil
	case upgradeconfiguration.FieldName:
		m.ResetName()
		return nil
	case upgradeconfiguration.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeconfiguration.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeconfiguration.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeconfiguration.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfiguration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeConfigurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeConfigurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeConfigurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeConfigurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfiguration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeConfigurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfiguration edge %s", name)
}

// UpgradeConfigurationUpgradeStrategyMutation represents an operation that mutates the UpgradeConfigurationUpgradeStrategy nodes in the graph.
type UpgradeConfigurationUpgradeStrategyMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	company_id                  *int
	addcompany_id               *int
	enable                      *int32
	addenable                   *int32
	name                        *string
	description                 *string
	configuration_id            *int
	addconfiguration_id         *int
	configuration_version_id    *int
	addconfiguration_version_id *int
	begin_datetime              *time.Time
	end_datetime                *time.Time
	upgrade_type                *int32
	addupgrade_type             *int32
	prompt_upgrade_content      *string
	upgrade_dev_type            *int32
	addupgrade_dev_type         *int32
	upgrade_dev_data            *string
	upgrade_version_type        *int32
	addupgrade_version_type     *int32
	upgrade_version_data        *string
	is_gray                     *int32
	addis_gray                  *int32
	gray_data                   *string
	is_flow_limit               *int32
	addis_flow_limit            *int32
	flow_limit_data             *string
	is_del                      *int32
	addis_del                   *int32
	create_at                   *time.Time
	update_at                   *time.Time
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*UpgradeConfigurationUpgradeStrategy, error)
	predicates                  []predicate.UpgradeConfigurationUpgradeStrategy
}

var _ ent.Mutation = (*UpgradeConfigurationUpgradeStrategyMutation)(nil)

// upgradeconfigurationupgradestrategyOption allows management of the mutation configuration using functional options.
type upgradeconfigurationupgradestrategyOption func(*UpgradeConfigurationUpgradeStrategyMutation)

// newUpgradeConfigurationUpgradeStrategyMutation creates new mutation for the UpgradeConfigurationUpgradeStrategy entity.
func newUpgradeConfigurationUpgradeStrategyMutation(c config, op Op, opts ...upgradeconfigurationupgradestrategyOption) *UpgradeConfigurationUpgradeStrategyMutation {
	m := &UpgradeConfigurationUpgradeStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeConfigurationUpgradeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeConfigurationUpgradeStrategyID sets the ID field of the mutation.
func withUpgradeConfigurationUpgradeStrategyID(id int) upgradeconfigurationupgradestrategyOption {
	return func(m *UpgradeConfigurationUpgradeStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeConfigurationUpgradeStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeConfigurationUpgradeStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeConfigurationUpgradeStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeConfigurationUpgradeStrategy sets the old UpgradeConfigurationUpgradeStrategy of the mutation.
func withUpgradeConfigurationUpgradeStrategy(node *UpgradeConfigurationUpgradeStrategy) upgradeconfigurationupgradestrategyOption {
	return func(m *UpgradeConfigurationUpgradeStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeConfigurationUpgradeStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeConfigurationUpgradeStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeConfigurationUpgradeStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeConfigurationUpgradeStrategy entities.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeConfigurationUpgradeStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetEnable sets the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetName sets the "name" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeconfigurationupgradestrategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategy.FieldDescription)
}

// SetConfigurationID sets the "configuration_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetConfigurationID(i int) {
	m.configuration_id = &i
	m.addconfiguration_id = nil
}

// ConfigurationID returns the value of the "configuration_id" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ConfigurationID() (r int, exists bool) {
	v := m.configuration_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationID returns the old "configuration_id" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldConfigurationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationID: %w", err)
	}
	return oldValue.ConfigurationID, nil
}

// AddConfigurationID adds i to the "configuration_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddConfigurationID(i int) {
	if m.addconfiguration_id != nil {
		*m.addconfiguration_id += i
	} else {
		m.addconfiguration_id = &i
	}
}

// AddedConfigurationID returns the value that was added to the "configuration_id" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedConfigurationID() (r int, exists bool) {
	v := m.addconfiguration_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfigurationID resets all changes to the "configuration_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetConfigurationID() {
	m.configuration_id = nil
	m.addconfiguration_id = nil
}

// SetConfigurationVersionID sets the "configuration_version_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetConfigurationVersionID(i int) {
	m.configuration_version_id = &i
	m.addconfiguration_version_id = nil
}

// ConfigurationVersionID returns the value of the "configuration_version_id" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ConfigurationVersionID() (r int, exists bool) {
	v := m.configuration_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationVersionID returns the old "configuration_version_id" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldConfigurationVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationVersionID: %w", err)
	}
	return oldValue.ConfigurationVersionID, nil
}

// AddConfigurationVersionID adds i to the "configuration_version_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddConfigurationVersionID(i int) {
	if m.addconfiguration_version_id != nil {
		*m.addconfiguration_version_id += i
	} else {
		m.addconfiguration_version_id = &i
	}
}

// AddedConfigurationVersionID returns the value that was added to the "configuration_version_id" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedConfigurationVersionID() (r int, exists bool) {
	v := m.addconfiguration_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfigurationVersionID resets all changes to the "configuration_version_id" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetConfigurationVersionID() {
	m.configuration_version_id = nil
	m.addconfiguration_version_id = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetUpgradeType sets the "upgrade_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetUpgradeType(i int32) {
	m.upgrade_type = &i
	m.addupgrade_type = nil
}

// UpgradeType returns the value of the "upgrade_type" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) UpgradeType() (r int32, exists bool) {
	v := m.upgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeType returns the old "upgrade_type" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldUpgradeType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeType: %w", err)
	}
	return oldValue.UpgradeType, nil
}

// AddUpgradeType adds i to the "upgrade_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddUpgradeType(i int32) {
	if m.addupgrade_type != nil {
		*m.addupgrade_type += i
	} else {
		m.addupgrade_type = &i
	}
}

// AddedUpgradeType returns the value that was added to the "upgrade_type" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedUpgradeType() (r int32, exists bool) {
	v := m.addupgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeType resets all changes to the "upgrade_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetUpgradeType() {
	m.upgrade_type = nil
	m.addupgrade_type = nil
}

// SetPromptUpgradeContent sets the "prompt_upgrade_content" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetPromptUpgradeContent(s string) {
	m.prompt_upgrade_content = &s
}

// PromptUpgradeContent returns the value of the "prompt_upgrade_content" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) PromptUpgradeContent() (r string, exists bool) {
	v := m.prompt_upgrade_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptUpgradeContent returns the old "prompt_upgrade_content" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldPromptUpgradeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptUpgradeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptUpgradeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptUpgradeContent: %w", err)
	}
	return oldValue.PromptUpgradeContent, nil
}

// ClearPromptUpgradeContent clears the value of the "prompt_upgrade_content" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	m.clearedFields[upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent] = struct{}{}
}

// PromptUpgradeContentCleared returns if the "prompt_upgrade_content" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) PromptUpgradeContentCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent]
	return ok
}

// ResetPromptUpgradeContent resets all changes to the "prompt_upgrade_content" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent)
}

// SetUpgradeDevType sets the "upgrade_dev_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetUpgradeDevType(i int32) {
	m.upgrade_dev_type = &i
	m.addupgrade_dev_type = nil
}

// UpgradeDevType returns the value of the "upgrade_dev_type" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) UpgradeDevType() (r int32, exists bool) {
	v := m.upgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevType returns the old "upgrade_dev_type" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldUpgradeDevType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevType: %w", err)
	}
	return oldValue.UpgradeDevType, nil
}

// AddUpgradeDevType adds i to the "upgrade_dev_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddUpgradeDevType(i int32) {
	if m.addupgrade_dev_type != nil {
		*m.addupgrade_dev_type += i
	} else {
		m.addupgrade_dev_type = &i
	}
}

// AddedUpgradeDevType returns the value that was added to the "upgrade_dev_type" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedUpgradeDevType() (r int32, exists bool) {
	v := m.addupgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeDevType resets all changes to the "upgrade_dev_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetUpgradeDevType() {
	m.upgrade_dev_type = nil
	m.addupgrade_dev_type = nil
}

// SetUpgradeDevData sets the "upgrade_dev_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetUpgradeDevData(s string) {
	m.upgrade_dev_data = &s
}

// UpgradeDevData returns the value of the "upgrade_dev_data" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) UpgradeDevData() (r string, exists bool) {
	v := m.upgrade_dev_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevData returns the old "upgrade_dev_data" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldUpgradeDevData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevData: %w", err)
	}
	return oldValue.UpgradeDevData, nil
}

// ResetUpgradeDevData resets all changes to the "upgrade_dev_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetUpgradeDevData() {
	m.upgrade_dev_data = nil
}

// SetUpgradeVersionType sets the "upgrade_version_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetUpgradeVersionType(i int32) {
	m.upgrade_version_type = &i
	m.addupgrade_version_type = nil
}

// UpgradeVersionType returns the value of the "upgrade_version_type" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) UpgradeVersionType() (r int32, exists bool) {
	v := m.upgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionType returns the old "upgrade_version_type" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldUpgradeVersionType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionType: %w", err)
	}
	return oldValue.UpgradeVersionType, nil
}

// AddUpgradeVersionType adds i to the "upgrade_version_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddUpgradeVersionType(i int32) {
	if m.addupgrade_version_type != nil {
		*m.addupgrade_version_type += i
	} else {
		m.addupgrade_version_type = &i
	}
}

// AddedUpgradeVersionType returns the value that was added to the "upgrade_version_type" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedUpgradeVersionType() (r int32, exists bool) {
	v := m.addupgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeVersionType resets all changes to the "upgrade_version_type" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetUpgradeVersionType() {
	m.upgrade_version_type = nil
	m.addupgrade_version_type = nil
}

// SetUpgradeVersionData sets the "upgrade_version_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetUpgradeVersionData(s string) {
	m.upgrade_version_data = &s
}

// UpgradeVersionData returns the value of the "upgrade_version_data" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) UpgradeVersionData() (r string, exists bool) {
	v := m.upgrade_version_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionData returns the old "upgrade_version_data" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldUpgradeVersionData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionData: %w", err)
	}
	return oldValue.UpgradeVersionData, nil
}

// ResetUpgradeVersionData resets all changes to the "upgrade_version_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetUpgradeVersionData() {
	m.upgrade_version_data = nil
}

// SetIsGray sets the "is_gray" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetIsGray(i int32) {
	m.is_gray = &i
	m.addis_gray = nil
}

// IsGray returns the value of the "is_gray" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) IsGray() (r int32, exists bool) {
	v := m.is_gray
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGray returns the old "is_gray" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldIsGray(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGray: %w", err)
	}
	return oldValue.IsGray, nil
}

// AddIsGray adds i to the "is_gray" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddIsGray(i int32) {
	if m.addis_gray != nil {
		*m.addis_gray += i
	} else {
		m.addis_gray = &i
	}
}

// AddedIsGray returns the value that was added to the "is_gray" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedIsGray() (r int32, exists bool) {
	v := m.addis_gray
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsGray resets all changes to the "is_gray" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetIsGray() {
	m.is_gray = nil
	m.addis_gray = nil
}

// SetGrayData sets the "gray_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetGrayData(s string) {
	m.gray_data = &s
}

// GrayData returns the value of the "gray_data" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) GrayData() (r string, exists bool) {
	v := m.gray_data
	if v == nil {
		return
	}
	return *v, true
}

// OldGrayData returns the old "gray_data" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldGrayData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrayData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrayData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrayData: %w", err)
	}
	return oldValue.GrayData, nil
}

// ResetGrayData resets all changes to the "gray_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetGrayData() {
	m.gray_data = nil
}

// SetIsFlowLimit sets the "is_flow_limit" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetIsFlowLimit(i int32) {
	m.is_flow_limit = &i
	m.addis_flow_limit = nil
}

// IsFlowLimit returns the value of the "is_flow_limit" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) IsFlowLimit() (r int32, exists bool) {
	v := m.is_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlowLimit returns the old "is_flow_limit" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldIsFlowLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlowLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlowLimit: %w", err)
	}
	return oldValue.IsFlowLimit, nil
}

// AddIsFlowLimit adds i to the "is_flow_limit" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddIsFlowLimit(i int32) {
	if m.addis_flow_limit != nil {
		*m.addis_flow_limit += i
	} else {
		m.addis_flow_limit = &i
	}
}

// AddedIsFlowLimit returns the value that was added to the "is_flow_limit" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedIsFlowLimit() (r int32, exists bool) {
	v := m.addis_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFlowLimit resets all changes to the "is_flow_limit" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetIsFlowLimit() {
	m.is_flow_limit = nil
	m.addis_flow_limit = nil
}

// SetFlowLimitData sets the "flow_limit_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetFlowLimitData(s string) {
	m.flow_limit_data = &s
}

// FlowLimitData returns the value of the "flow_limit_data" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) FlowLimitData() (r string, exists bool) {
	v := m.flow_limit_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowLimitData returns the old "flow_limit_data" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldFlowLimitData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowLimitData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowLimitData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowLimitData: %w", err)
	}
	return oldValue.FlowLimitData, nil
}

// ResetFlowLimitData resets all changes to the "flow_limit_data" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetFlowLimitData() {
	m.flow_limit_data = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeconfigurationupgradestrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeConfigurationUpgradeStrategy entity.
// If the UpgradeConfigurationUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeconfigurationupgradestrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeConfigurationUpgradeStrategyMutation builder.
func (m *UpgradeConfigurationUpgradeStrategyMutation) Where(ps ...predicate.UpgradeConfigurationUpgradeStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeConfigurationUpgradeStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeConfigurationUpgradeStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeConfigurationUpgradeStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeConfigurationUpgradeStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeConfigurationUpgradeStrategy).
func (m *UpgradeConfigurationUpgradeStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeConfigurationUpgradeStrategyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.company_id != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldCompanyID)
	}
	if m.enable != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldDescription)
	}
	if m.configuration_id != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldConfigurationID)
	}
	if m.configuration_version_id != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldConfigurationVersionID)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldEndDatetime)
	}
	if m.upgrade_type != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeType)
	}
	if m.prompt_upgrade_content != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.upgrade_dev_type != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeDevType)
	}
	if m.upgrade_dev_data != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeDevData)
	}
	if m.upgrade_version_type != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeVersionType)
	}
	if m.upgrade_version_data != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeVersionData)
	}
	if m.is_gray != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldIsGray)
	}
	if m.gray_data != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldGrayData)
	}
	if m.is_flow_limit != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldIsFlowLimit)
	}
	if m.flow_limit_data != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldFlowLimitData)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeConfigurationUpgradeStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationupgradestrategy.FieldCompanyID:
		return m.CompanyID()
	case upgradeconfigurationupgradestrategy.FieldEnable:
		return m.Enable()
	case upgradeconfigurationupgradestrategy.FieldName:
		return m.Name()
	case upgradeconfigurationupgradestrategy.FieldDescription:
		return m.Description()
	case upgradeconfigurationupgradestrategy.FieldConfigurationID:
		return m.ConfigurationID()
	case upgradeconfigurationupgradestrategy.FieldConfigurationVersionID:
		return m.ConfigurationVersionID()
	case upgradeconfigurationupgradestrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeconfigurationupgradestrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeconfigurationupgradestrategy.FieldUpgradeType:
		return m.UpgradeType()
	case upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent:
		return m.PromptUpgradeContent()
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevType:
		return m.UpgradeDevType()
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevData:
		return m.UpgradeDevData()
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionType:
		return m.UpgradeVersionType()
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionData:
		return m.UpgradeVersionData()
	case upgradeconfigurationupgradestrategy.FieldIsGray:
		return m.IsGray()
	case upgradeconfigurationupgradestrategy.FieldGrayData:
		return m.GrayData()
	case upgradeconfigurationupgradestrategy.FieldIsFlowLimit:
		return m.IsFlowLimit()
	case upgradeconfigurationupgradestrategy.FieldFlowLimitData:
		return m.FlowLimitData()
	case upgradeconfigurationupgradestrategy.FieldIsDel:
		return m.IsDel()
	case upgradeconfigurationupgradestrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeconfigurationupgradestrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeConfigurationUpgradeStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeconfigurationupgradestrategy.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeconfigurationupgradestrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeconfigurationupgradestrategy.FieldName:
		return m.OldName(ctx)
	case upgradeconfigurationupgradestrategy.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeconfigurationupgradestrategy.FieldConfigurationID:
		return m.OldConfigurationID(ctx)
	case upgradeconfigurationupgradestrategy.FieldConfigurationVersionID:
		return m.OldConfigurationVersionID(ctx)
	case upgradeconfigurationupgradestrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeconfigurationupgradestrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeconfigurationupgradestrategy.FieldUpgradeType:
		return m.OldUpgradeType(ctx)
	case upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent:
		return m.OldPromptUpgradeContent(ctx)
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevType:
		return m.OldUpgradeDevType(ctx)
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevData:
		return m.OldUpgradeDevData(ctx)
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionType:
		return m.OldUpgradeVersionType(ctx)
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionData:
		return m.OldUpgradeVersionData(ctx)
	case upgradeconfigurationupgradestrategy.FieldIsGray:
		return m.OldIsGray(ctx)
	case upgradeconfigurationupgradestrategy.FieldGrayData:
		return m.OldGrayData(ctx)
	case upgradeconfigurationupgradestrategy.FieldIsFlowLimit:
		return m.OldIsFlowLimit(ctx)
	case upgradeconfigurationupgradestrategy.FieldFlowLimitData:
		return m.OldFlowLimitData(ctx)
	case upgradeconfigurationupgradestrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeconfigurationupgradestrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeconfigurationupgradestrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationUpgradeStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldConfigurationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationID(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldConfigurationVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationVersionID(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeType(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptUpgradeContent(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevType(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevData(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionType(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionData(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGray(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldGrayData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrayData(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlowLimit(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldFlowLimitData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowLimitData(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldCompanyID)
	}
	if m.addenable != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldEnable)
	}
	if m.addconfiguration_id != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldConfigurationID)
	}
	if m.addconfiguration_version_id != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldConfigurationVersionID)
	}
	if m.addupgrade_type != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeType)
	}
	if m.addupgrade_dev_type != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeDevType)
	}
	if m.addupgrade_version_type != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpgradeVersionType)
	}
	if m.addis_gray != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldIsGray)
	}
	if m.addis_flow_limit != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldIsFlowLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationupgradestrategy.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeconfigurationupgradestrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeconfigurationupgradestrategy.FieldConfigurationID:
		return m.AddedConfigurationID()
	case upgradeconfigurationupgradestrategy.FieldConfigurationVersionID:
		return m.AddedConfigurationVersionID()
	case upgradeconfigurationupgradestrategy.FieldUpgradeType:
		return m.AddedUpgradeType()
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevType:
		return m.AddedUpgradeDevType()
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionType:
		return m.AddedUpgradeVersionType()
	case upgradeconfigurationupgradestrategy.FieldIsGray:
		return m.AddedIsGray()
	case upgradeconfigurationupgradestrategy.FieldIsFlowLimit:
		return m.AddedIsFlowLimit()
	case upgradeconfigurationupgradestrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldConfigurationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigurationID(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldConfigurationVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigurationVersionID(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeType(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeDevType(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeVersionType(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsGray(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFlowLimit(v)
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeconfigurationupgradestrategy.FieldDescription) {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldDescription)
	}
	if m.FieldCleared(upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent) {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.FieldCleared(upgradeconfigurationupgradestrategy.FieldCreateAt) {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeconfigurationupgradestrategy.FieldUpdateAt) {
		fields = append(fields, upgradeconfigurationupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeconfigurationupgradestrategy.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent:
		m.ClearPromptUpgradeContent()
		return nil
	case upgradeconfigurationupgradestrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeconfigurationupgradestrategy.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeconfigurationupgradestrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeconfigurationupgradestrategy.FieldName:
		m.ResetName()
		return nil
	case upgradeconfigurationupgradestrategy.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeconfigurationupgradestrategy.FieldConfigurationID:
		m.ResetConfigurationID()
		return nil
	case upgradeconfigurationupgradestrategy.FieldConfigurationVersionID:
		m.ResetConfigurationVersionID()
		return nil
	case upgradeconfigurationupgradestrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeconfigurationupgradestrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeType:
		m.ResetUpgradeType()
		return nil
	case upgradeconfigurationupgradestrategy.FieldPromptUpgradeContent:
		m.ResetPromptUpgradeContent()
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevType:
		m.ResetUpgradeDevType()
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeDevData:
		m.ResetUpgradeDevData()
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionType:
		m.ResetUpgradeVersionType()
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpgradeVersionData:
		m.ResetUpgradeVersionData()
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsGray:
		m.ResetIsGray()
		return nil
	case upgradeconfigurationupgradestrategy.FieldGrayData:
		m.ResetGrayData()
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsFlowLimit:
		m.ResetIsFlowLimit()
		return nil
	case upgradeconfigurationupgradestrategy.FieldFlowLimitData:
		m.ResetFlowLimitData()
		return nil
	case upgradeconfigurationupgradestrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeconfigurationupgradestrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeconfigurationupgradestrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategy edge %s", name)
}

// UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation represents an operation that mutates the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy nodes in the graph.
type UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	enable        *int32
	addenable     *int32
	begin_time    *string
	end_time      *string
	dimension     *int32
	adddimension  *int32
	_limit        *int
	add_limit     *int
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeConfigurationUpgradeStrategyFlowLimitStrategy, error)
	predicates    []predicate.UpgradeConfigurationUpgradeStrategyFlowLimitStrategy
}

var _ ent.Mutation = (*UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation)(nil)

// upgradeconfigurationupgradestrategyflowlimitstrategyOption allows management of the mutation configuration using functional options.
type upgradeconfigurationupgradestrategyflowlimitstrategyOption func(*UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation)

// newUpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation creates new mutation for the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
func newUpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation(c config, op Op, opts ...upgradeconfigurationupgradestrategyflowlimitstrategyOption) *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation {
	m := &UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeConfigurationUpgradeStrategyFlowLimitStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeConfigurationUpgradeStrategyFlowLimitStrategyID sets the ID field of the mutation.
func withUpgradeConfigurationUpgradeStrategyFlowLimitStrategyID(id int) upgradeconfigurationupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeConfigurationUpgradeStrategyFlowLimitStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeConfigurationUpgradeStrategyFlowLimitStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeConfigurationUpgradeStrategyFlowLimitStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeConfigurationUpgradeStrategyFlowLimitStrategy sets the old UpgradeConfigurationUpgradeStrategyFlowLimitStrategy of the mutation.
func withUpgradeConfigurationUpgradeStrategyFlowLimitStrategy(node *UpgradeConfigurationUpgradeStrategyFlowLimitStrategy) upgradeconfigurationupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeConfigurationUpgradeStrategyFlowLimitStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entities.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeConfigurationUpgradeStrategyFlowLimitStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginTime sets the "begin_time" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetBeginTime(s string) {
	m.begin_time = &s
}

// BeginTime returns the value of the "begin_time" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) BeginTime() (r string, exists bool) {
	v := m.begin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "begin_time" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldBeginTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "begin_time" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetBeginTime() {
	m.begin_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDimension sets the "dimension" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetDimension(i int32) {
	m.dimension = &i
	m.adddimension = nil
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Dimension() (r int32, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldDimension(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// AddDimension adds i to the "dimension" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddDimension(i int32) {
	if m.adddimension != nil {
		*m.adddimension += i
	} else {
		m.adddimension = &i
	}
}

// AddedDimension returns the value that was added to the "dimension" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedDimension() (r int32, exists bool) {
	v := m.adddimension
	if v == nil {
		return
	}
	return *v, true
}

// ResetDimension resets all changes to the "dimension" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetDimension() {
	m.dimension = nil
	m.adddimension = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation builder.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Where(ps ...predicate.UpgradeConfigurationUpgradeStrategyFlowLimitStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeConfigurationUpgradeStrategyFlowLimitStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeConfigurationUpgradeStrategyFlowLimitStrategy).
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.enable != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.begin_time != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldBeginTime)
	}
	if m.end_time != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEndTime)
	}
	if m.dimension != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m._limit != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable:
		return m.Enable()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.BeginTime()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.EndTime()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension:
		return m.Dimension()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit:
		return m.Limit()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.IsDel()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.OldEndTime(ctx)
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension:
		return m.OldDimension(ctx)
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyFlowLimitStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldBeginTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.adddimension != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension:
		return m.AddedDimension()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimension(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyFlowLimitStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt) {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt) {
		fields = append(fields, upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyFlowLimitStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldEndTime:
		m.ResetEndTime()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldDimension:
		m.ResetDimension()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeconfigurationupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyFlowLimitStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyFlowLimitStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyFlowLimitStrategy edge %s", name)
}

// UpgradeConfigurationUpgradeStrategyGrayStrategyMutation represents an operation that mutates the UpgradeConfigurationUpgradeStrategyGrayStrategy nodes in the graph.
type UpgradeConfigurationUpgradeStrategyGrayStrategyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	enable         *int32
	addenable      *int32
	begin_datetime *time.Time
	end_datetime   *time.Time
	_limit         *int
	add_limit      *int
	is_del         *int32
	addis_del      *int32
	create_at      *time.Time
	update_at      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UpgradeConfigurationUpgradeStrategyGrayStrategy, error)
	predicates     []predicate.UpgradeConfigurationUpgradeStrategyGrayStrategy
}

var _ ent.Mutation = (*UpgradeConfigurationUpgradeStrategyGrayStrategyMutation)(nil)

// upgradeconfigurationupgradestrategygraystrategyOption allows management of the mutation configuration using functional options.
type upgradeconfigurationupgradestrategygraystrategyOption func(*UpgradeConfigurationUpgradeStrategyGrayStrategyMutation)

// newUpgradeConfigurationUpgradeStrategyGrayStrategyMutation creates new mutation for the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
func newUpgradeConfigurationUpgradeStrategyGrayStrategyMutation(c config, op Op, opts ...upgradeconfigurationupgradestrategygraystrategyOption) *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation {
	m := &UpgradeConfigurationUpgradeStrategyGrayStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeConfigurationUpgradeStrategyGrayStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeConfigurationUpgradeStrategyGrayStrategyID sets the ID field of the mutation.
func withUpgradeConfigurationUpgradeStrategyGrayStrategyID(id int) upgradeconfigurationupgradestrategygraystrategyOption {
	return func(m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeConfigurationUpgradeStrategyGrayStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeConfigurationUpgradeStrategyGrayStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeConfigurationUpgradeStrategyGrayStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeConfigurationUpgradeStrategyGrayStrategy sets the old UpgradeConfigurationUpgradeStrategyGrayStrategy of the mutation.
func withUpgradeConfigurationUpgradeStrategyGrayStrategy(node *UpgradeConfigurationUpgradeStrategyGrayStrategy) upgradeconfigurationupgradestrategygraystrategyOption {
	return func(m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeConfigurationUpgradeStrategyGrayStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeConfigurationUpgradeStrategyGrayStrategy entities.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeConfigurationUpgradeStrategyGrayStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeConfigurationUpgradeStrategyGrayStrategy entity.
// If the UpgradeConfigurationUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeConfigurationUpgradeStrategyGrayStrategyMutation builder.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Where(ps ...predicate.UpgradeConfigurationUpgradeStrategyGrayStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeConfigurationUpgradeStrategyGrayStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeConfigurationUpgradeStrategyGrayStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeConfigurationUpgradeStrategyGrayStrategy).
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.enable != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldEnable)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldEndDatetime)
	}
	if m._limit != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationupgradestrategygraystrategy.FieldEnable:
		return m.Enable()
	case upgradeconfigurationupgradestrategygraystrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeconfigurationupgradestrategygraystrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeconfigurationupgradestrategygraystrategy.FieldLimit:
		return m.Limit()
	case upgradeconfigurationupgradestrategygraystrategy.FieldIsDel:
		return m.IsDel()
	case upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeconfigurationupgradestrategygraystrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeconfigurationupgradestrategygraystrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeconfigurationupgradestrategygraystrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeconfigurationupgradestrategygraystrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeconfigurationupgradestrategygraystrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyGrayStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyGrayStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldEnable)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationupgradestrategygraystrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeconfigurationupgradestrategygraystrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeconfigurationupgradestrategygraystrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyGrayStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt) {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt) {
		fields = append(fields, upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyGrayStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeconfigurationupgradestrategygraystrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeconfigurationupgradestrategygraystrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyGrayStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyGrayStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeConfigurationUpgradeStrategyGrayStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationUpgradeStrategyGrayStrategy edge %s", name)
}

// UpgradeConfigurationVersionMutation represents an operation that mutates the UpgradeConfigurationVersion nodes in the graph.
type UpgradeConfigurationVersionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	company_id          *int
	addcompany_id       *int
	configuration_id    *int
	addconfiguration_id *int
	content             *string
	version_name        *string
	version_code        *int
	addversion_code     *int
	description         *string
	is_del              *int32
	addis_del           *int32
	create_at           *time.Time
	update_at           *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*UpgradeConfigurationVersion, error)
	predicates          []predicate.UpgradeConfigurationVersion
}

var _ ent.Mutation = (*UpgradeConfigurationVersionMutation)(nil)

// upgradeconfigurationversionOption allows management of the mutation configuration using functional options.
type upgradeconfigurationversionOption func(*UpgradeConfigurationVersionMutation)

// newUpgradeConfigurationVersionMutation creates new mutation for the UpgradeConfigurationVersion entity.
func newUpgradeConfigurationVersionMutation(c config, op Op, opts ...upgradeconfigurationversionOption) *UpgradeConfigurationVersionMutation {
	m := &UpgradeConfigurationVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeConfigurationVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeConfigurationVersionID sets the ID field of the mutation.
func withUpgradeConfigurationVersionID(id int) upgradeconfigurationversionOption {
	return func(m *UpgradeConfigurationVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeConfigurationVersion
		)
		m.oldValue = func(ctx context.Context) (*UpgradeConfigurationVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeConfigurationVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeConfigurationVersion sets the old UpgradeConfigurationVersion of the mutation.
func withUpgradeConfigurationVersion(node *UpgradeConfigurationVersion) upgradeconfigurationversionOption {
	return func(m *UpgradeConfigurationVersionMutation) {
		m.oldValue = func(context.Context) (*UpgradeConfigurationVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeConfigurationVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeConfigurationVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeConfigurationVersion entities.
func (m *UpgradeConfigurationVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeConfigurationVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeConfigurationVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeConfigurationVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeConfigurationVersionMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeConfigurationVersionMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeConfigurationVersionMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeConfigurationVersionMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetConfigurationID sets the "configuration_id" field.
func (m *UpgradeConfigurationVersionMutation) SetConfigurationID(i int) {
	m.configuration_id = &i
	m.addconfiguration_id = nil
}

// ConfigurationID returns the value of the "configuration_id" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) ConfigurationID() (r int, exists bool) {
	v := m.configuration_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationID returns the old "configuration_id" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldConfigurationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationID: %w", err)
	}
	return oldValue.ConfigurationID, nil
}

// AddConfigurationID adds i to the "configuration_id" field.
func (m *UpgradeConfigurationVersionMutation) AddConfigurationID(i int) {
	if m.addconfiguration_id != nil {
		*m.addconfiguration_id += i
	} else {
		m.addconfiguration_id = &i
	}
}

// AddedConfigurationID returns the value that was added to the "configuration_id" field in this mutation.
func (m *UpgradeConfigurationVersionMutation) AddedConfigurationID() (r int, exists bool) {
	v := m.addconfiguration_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfigurationID resets all changes to the "configuration_id" field.
func (m *UpgradeConfigurationVersionMutation) ResetConfigurationID() {
	m.configuration_id = nil
	m.addconfiguration_id = nil
}

// SetContent sets the "content" field.
func (m *UpgradeConfigurationVersionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *UpgradeConfigurationVersionMutation) ResetContent() {
	m.content = nil
}

// SetVersionName sets the "version_name" field.
func (m *UpgradeConfigurationVersionMutation) SetVersionName(s string) {
	m.version_name = &s
}

// VersionName returns the value of the "version_name" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) VersionName() (r string, exists bool) {
	v := m.version_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionName returns the old "version_name" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldVersionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionName: %w", err)
	}
	return oldValue.VersionName, nil
}

// ResetVersionName resets all changes to the "version_name" field.
func (m *UpgradeConfigurationVersionMutation) ResetVersionName() {
	m.version_name = nil
}

// SetVersionCode sets the "version_code" field.
func (m *UpgradeConfigurationVersionMutation) SetVersionCode(i int) {
	m.version_code = &i
	m.addversion_code = nil
}

// VersionCode returns the value of the "version_code" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) VersionCode() (r int, exists bool) {
	v := m.version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionCode returns the old "version_code" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldVersionCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionCode: %w", err)
	}
	return oldValue.VersionCode, nil
}

// AddVersionCode adds i to the "version_code" field.
func (m *UpgradeConfigurationVersionMutation) AddVersionCode(i int) {
	if m.addversion_code != nil {
		*m.addversion_code += i
	} else {
		m.addversion_code = &i
	}
}

// AddedVersionCode returns the value that was added to the "version_code" field in this mutation.
func (m *UpgradeConfigurationVersionMutation) AddedVersionCode() (r int, exists bool) {
	v := m.addversion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionCode resets all changes to the "version_code" field.
func (m *UpgradeConfigurationVersionMutation) ResetVersionCode() {
	m.version_code = nil
	m.addversion_code = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeConfigurationVersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeConfigurationVersionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeconfigurationversion.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeConfigurationVersionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationversion.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeConfigurationVersionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeconfigurationversion.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeConfigurationVersionMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeConfigurationVersionMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeConfigurationVersionMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeConfigurationVersionMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeConfigurationVersionMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeConfigurationVersionMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeconfigurationversion.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeConfigurationVersionMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationversion.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeConfigurationVersionMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeconfigurationversion.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeConfigurationVersionMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeConfigurationVersionMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeConfigurationVersion entity.
// If the UpgradeConfigurationVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeConfigurationVersionMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeConfigurationVersionMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeconfigurationversion.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeConfigurationVersionMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeconfigurationversion.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeConfigurationVersionMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeconfigurationversion.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeConfigurationVersionMutation builder.
func (m *UpgradeConfigurationVersionMutation) Where(ps ...predicate.UpgradeConfigurationVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeConfigurationVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeConfigurationVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeConfigurationVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeConfigurationVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeConfigurationVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeConfigurationVersion).
func (m *UpgradeConfigurationVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeConfigurationVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.company_id != nil {
		fields = append(fields, upgradeconfigurationversion.FieldCompanyID)
	}
	if m.configuration_id != nil {
		fields = append(fields, upgradeconfigurationversion.FieldConfigurationID)
	}
	if m.content != nil {
		fields = append(fields, upgradeconfigurationversion.FieldContent)
	}
	if m.version_name != nil {
		fields = append(fields, upgradeconfigurationversion.FieldVersionName)
	}
	if m.version_code != nil {
		fields = append(fields, upgradeconfigurationversion.FieldVersionCode)
	}
	if m.description != nil {
		fields = append(fields, upgradeconfigurationversion.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeconfigurationversion.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeconfigurationversion.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeconfigurationversion.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeConfigurationVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationversion.FieldCompanyID:
		return m.CompanyID()
	case upgradeconfigurationversion.FieldConfigurationID:
		return m.ConfigurationID()
	case upgradeconfigurationversion.FieldContent:
		return m.Content()
	case upgradeconfigurationversion.FieldVersionName:
		return m.VersionName()
	case upgradeconfigurationversion.FieldVersionCode:
		return m.VersionCode()
	case upgradeconfigurationversion.FieldDescription:
		return m.Description()
	case upgradeconfigurationversion.FieldIsDel:
		return m.IsDel()
	case upgradeconfigurationversion.FieldCreateAt:
		return m.CreateAt()
	case upgradeconfigurationversion.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeConfigurationVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeconfigurationversion.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeconfigurationversion.FieldConfigurationID:
		return m.OldConfigurationID(ctx)
	case upgradeconfigurationversion.FieldContent:
		return m.OldContent(ctx)
	case upgradeconfigurationversion.FieldVersionName:
		return m.OldVersionName(ctx)
	case upgradeconfigurationversion.FieldVersionCode:
		return m.OldVersionCode(ctx)
	case upgradeconfigurationversion.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeconfigurationversion.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeconfigurationversion.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeconfigurationversion.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeConfigurationVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeconfigurationversion.FieldConfigurationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationID(v)
		return nil
	case upgradeconfigurationversion.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case upgradeconfigurationversion.FieldVersionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionName(v)
		return nil
	case upgradeconfigurationversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionCode(v)
		return nil
	case upgradeconfigurationversion.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeconfigurationversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeconfigurationversion.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeconfigurationversion.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeConfigurationVersionMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeconfigurationversion.FieldCompanyID)
	}
	if m.addconfiguration_id != nil {
		fields = append(fields, upgradeconfigurationversion.FieldConfigurationID)
	}
	if m.addversion_code != nil {
		fields = append(fields, upgradeconfigurationversion.FieldVersionCode)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeconfigurationversion.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeConfigurationVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeconfigurationversion.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeconfigurationversion.FieldConfigurationID:
		return m.AddedConfigurationID()
	case upgradeconfigurationversion.FieldVersionCode:
		return m.AddedVersionCode()
	case upgradeconfigurationversion.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeConfigurationVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeconfigurationversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeconfigurationversion.FieldConfigurationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigurationID(v)
		return nil
	case upgradeconfigurationversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionCode(v)
		return nil
	case upgradeconfigurationversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeConfigurationVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeconfigurationversion.FieldDescription) {
		fields = append(fields, upgradeconfigurationversion.FieldDescription)
	}
	if m.FieldCleared(upgradeconfigurationversion.FieldCreateAt) {
		fields = append(fields, upgradeconfigurationversion.FieldCreateAt)
	}
	if m.FieldCleared(upgradeconfigurationversion.FieldUpdateAt) {
		fields = append(fields, upgradeconfigurationversion.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeConfigurationVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeConfigurationVersionMutation) ClearField(name string) error {
	switch name {
	case upgradeconfigurationversion.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeconfigurationversion.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeconfigurationversion.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeConfigurationVersionMutation) ResetField(name string) error {
	switch name {
	case upgradeconfigurationversion.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeconfigurationversion.FieldConfigurationID:
		m.ResetConfigurationID()
		return nil
	case upgradeconfigurationversion.FieldContent:
		m.ResetContent()
		return nil
	case upgradeconfigurationversion.FieldVersionName:
		m.ResetVersionName()
		return nil
	case upgradeconfigurationversion.FieldVersionCode:
		m.ResetVersionCode()
		return nil
	case upgradeconfigurationversion.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeconfigurationversion.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeconfigurationversion.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeconfigurationversion.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeConfigurationVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeConfigurationVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeConfigurationVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeConfigurationVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeConfigurationVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeConfigurationVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeConfigurationVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeConfigurationVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeConfigurationVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeConfigurationVersion edge %s", name)
}

// UpgradeDevMutation represents an operation that mutates the UpgradeDev nodes in the graph.
type UpgradeDevMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeDev, error)
	predicates    []predicate.UpgradeDev
}

var _ ent.Mutation = (*UpgradeDevMutation)(nil)

// upgradedevOption allows management of the mutation configuration using functional options.
type upgradedevOption func(*UpgradeDevMutation)

// newUpgradeDevMutation creates new mutation for the UpgradeDev entity.
func newUpgradeDevMutation(c config, op Op, opts ...upgradedevOption) *UpgradeDevMutation {
	m := &UpgradeDevMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeDev,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeDevID sets the ID field of the mutation.
func withUpgradeDevID(id int) upgradedevOption {
	return func(m *UpgradeDevMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeDev
		)
		m.oldValue = func(ctx context.Context) (*UpgradeDev, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeDev.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeDev sets the old UpgradeDev of the mutation.
func withUpgradeDev(node *UpgradeDev) upgradedevOption {
	return func(m *UpgradeDevMutation) {
		m.oldValue = func(context.Context) (*UpgradeDev, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeDevMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeDevMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeDev entities.
func (m *UpgradeDevMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeDevMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeDevMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeDev.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeDevMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeDevMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeDev entity.
// If the UpgradeDev object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeDevMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeDevMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeDevMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeDevMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeDevMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeDev entity.
// If the UpgradeDev object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeDevMutation) ResetKey() {
	m.key = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeDevMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeDevMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeDev entity.
// If the UpgradeDev object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeDevMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeDevMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeDevMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeDevMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeDevMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeDev entity.
// If the UpgradeDev object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeDevMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradedev.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeDevMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradedev.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeDevMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradedev.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeDevMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeDevMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeDev entity.
// If the UpgradeDev object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeDevMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradedev.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeDevMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradedev.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeDevMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradedev.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeDevMutation builder.
func (m *UpgradeDevMutation) Where(ps ...predicate.UpgradeDev) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeDevMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeDevMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeDev, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeDevMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeDevMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeDev).
func (m *UpgradeDevMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeDevMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.company_id != nil {
		fields = append(fields, upgradedev.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradedev.FieldKey)
	}
	if m.is_del != nil {
		fields = append(fields, upgradedev.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradedev.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradedev.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeDevMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradedev.FieldCompanyID:
		return m.CompanyID()
	case upgradedev.FieldKey:
		return m.Key()
	case upgradedev.FieldIsDel:
		return m.IsDel()
	case upgradedev.FieldCreateAt:
		return m.CreateAt()
	case upgradedev.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeDevMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradedev.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradedev.FieldKey:
		return m.OldKey(ctx)
	case upgradedev.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradedev.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradedev.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeDev field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradedev.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradedev.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradedev.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradedev.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradedev.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDev field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeDevMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradedev.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradedev.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeDevMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradedev.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradedev.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradedev.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradedev.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDev numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeDevMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradedev.FieldCreateAt) {
		fields = append(fields, upgradedev.FieldCreateAt)
	}
	if m.FieldCleared(upgradedev.FieldUpdateAt) {
		fields = append(fields, upgradedev.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeDevMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeDevMutation) ClearField(name string) error {
	switch name {
	case upgradedev.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradedev.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDev nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeDevMutation) ResetField(name string) error {
	switch name {
	case upgradedev.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradedev.FieldKey:
		m.ResetKey()
		return nil
	case upgradedev.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradedev.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradedev.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDev field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeDevMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeDevMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeDevMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeDevMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeDevMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeDevMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeDevMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDev unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeDevMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDev edge %s", name)
}

// UpgradeDevGroupMutation represents an operation that mutates the UpgradeDevGroup nodes in the graph.
type UpgradeDevGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	name          *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeDevGroup, error)
	predicates    []predicate.UpgradeDevGroup
}

var _ ent.Mutation = (*UpgradeDevGroupMutation)(nil)

// upgradedevgroupOption allows management of the mutation configuration using functional options.
type upgradedevgroupOption func(*UpgradeDevGroupMutation)

// newUpgradeDevGroupMutation creates new mutation for the UpgradeDevGroup entity.
func newUpgradeDevGroupMutation(c config, op Op, opts ...upgradedevgroupOption) *UpgradeDevGroupMutation {
	m := &UpgradeDevGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeDevGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeDevGroupID sets the ID field of the mutation.
func withUpgradeDevGroupID(id int) upgradedevgroupOption {
	return func(m *UpgradeDevGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeDevGroup
		)
		m.oldValue = func(ctx context.Context) (*UpgradeDevGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeDevGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeDevGroup sets the old UpgradeDevGroup of the mutation.
func withUpgradeDevGroup(node *UpgradeDevGroup) upgradedevgroupOption {
	return func(m *UpgradeDevGroupMutation) {
		m.oldValue = func(context.Context) (*UpgradeDevGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeDevGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeDevGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeDevGroup entities.
func (m *UpgradeDevGroupMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeDevGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeDevGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeDevGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeDevGroupMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeDevGroupMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeDevGroup entity.
// If the UpgradeDevGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeDevGroupMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeDevGroupMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeDevGroupMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetName sets the "name" field.
func (m *UpgradeDevGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeDevGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeDevGroup entity.
// If the UpgradeDevGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeDevGroupMutation) ResetName() {
	m.name = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeDevGroupMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeDevGroupMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeDevGroup entity.
// If the UpgradeDevGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeDevGroupMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeDevGroupMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeDevGroupMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeDevGroupMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeDevGroupMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeDevGroup entity.
// If the UpgradeDevGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeDevGroupMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradedevgroup.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeDevGroupMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradedevgroup.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeDevGroupMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradedevgroup.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeDevGroupMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeDevGroupMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeDevGroup entity.
// If the UpgradeDevGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeDevGroupMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradedevgroup.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeDevGroupMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradedevgroup.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeDevGroupMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradedevgroup.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeDevGroupMutation builder.
func (m *UpgradeDevGroupMutation) Where(ps ...predicate.UpgradeDevGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeDevGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeDevGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeDevGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeDevGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeDevGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeDevGroup).
func (m *UpgradeDevGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeDevGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.company_id != nil {
		fields = append(fields, upgradedevgroup.FieldCompanyID)
	}
	if m.name != nil {
		fields = append(fields, upgradedevgroup.FieldName)
	}
	if m.is_del != nil {
		fields = append(fields, upgradedevgroup.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradedevgroup.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradedevgroup.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeDevGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradedevgroup.FieldCompanyID:
		return m.CompanyID()
	case upgradedevgroup.FieldName:
		return m.Name()
	case upgradedevgroup.FieldIsDel:
		return m.IsDel()
	case upgradedevgroup.FieldCreateAt:
		return m.CreateAt()
	case upgradedevgroup.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeDevGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradedevgroup.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradedevgroup.FieldName:
		return m.OldName(ctx)
	case upgradedevgroup.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradedevgroup.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradedevgroup.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeDevGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradedevgroup.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradedevgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradedevgroup.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradedevgroup.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradedevgroup.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeDevGroupMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradedevgroup.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradedevgroup.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeDevGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradedevgroup.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradedevgroup.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradedevgroup.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradedevgroup.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeDevGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradedevgroup.FieldCreateAt) {
		fields = append(fields, upgradedevgroup.FieldCreateAt)
	}
	if m.FieldCleared(upgradedevgroup.FieldUpdateAt) {
		fields = append(fields, upgradedevgroup.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeDevGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeDevGroupMutation) ClearField(name string) error {
	switch name {
	case upgradedevgroup.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradedevgroup.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeDevGroupMutation) ResetField(name string) error {
	switch name {
	case upgradedevgroup.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradedevgroup.FieldName:
		m.ResetName()
		return nil
	case upgradedevgroup.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradedevgroup.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradedevgroup.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeDevGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeDevGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeDevGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeDevGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeDevGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeDevGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeDevGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDevGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeDevGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDevGroup edge %s", name)
}

// UpgradeDevGroupRelationMutation represents an operation that mutates the UpgradeDevGroupRelation nodes in the graph.
type UpgradeDevGroupRelationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	dev_id          *int
	adddev_id       *int
	dev_group_id    *int
	adddev_group_id *int
	is_del          *int32
	addis_del       *int32
	create_at       *time.Time
	update_at       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UpgradeDevGroupRelation, error)
	predicates      []predicate.UpgradeDevGroupRelation
}

var _ ent.Mutation = (*UpgradeDevGroupRelationMutation)(nil)

// upgradedevgrouprelationOption allows management of the mutation configuration using functional options.
type upgradedevgrouprelationOption func(*UpgradeDevGroupRelationMutation)

// newUpgradeDevGroupRelationMutation creates new mutation for the UpgradeDevGroupRelation entity.
func newUpgradeDevGroupRelationMutation(c config, op Op, opts ...upgradedevgrouprelationOption) *UpgradeDevGroupRelationMutation {
	m := &UpgradeDevGroupRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeDevGroupRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeDevGroupRelationID sets the ID field of the mutation.
func withUpgradeDevGroupRelationID(id int) upgradedevgrouprelationOption {
	return func(m *UpgradeDevGroupRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeDevGroupRelation
		)
		m.oldValue = func(ctx context.Context) (*UpgradeDevGroupRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeDevGroupRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeDevGroupRelation sets the old UpgradeDevGroupRelation of the mutation.
func withUpgradeDevGroupRelation(node *UpgradeDevGroupRelation) upgradedevgrouprelationOption {
	return func(m *UpgradeDevGroupRelationMutation) {
		m.oldValue = func(context.Context) (*UpgradeDevGroupRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeDevGroupRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeDevGroupRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeDevGroupRelation entities.
func (m *UpgradeDevGroupRelationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeDevGroupRelationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeDevGroupRelationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeDevGroupRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDevID sets the "dev_id" field.
func (m *UpgradeDevGroupRelationMutation) SetDevID(i int) {
	m.dev_id = &i
	m.adddev_id = nil
}

// DevID returns the value of the "dev_id" field in the mutation.
func (m *UpgradeDevGroupRelationMutation) DevID() (r int, exists bool) {
	v := m.dev_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDevID returns the old "dev_id" field's value of the UpgradeDevGroupRelation entity.
// If the UpgradeDevGroupRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupRelationMutation) OldDevID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevID: %w", err)
	}
	return oldValue.DevID, nil
}

// AddDevID adds i to the "dev_id" field.
func (m *UpgradeDevGroupRelationMutation) AddDevID(i int) {
	if m.adddev_id != nil {
		*m.adddev_id += i
	} else {
		m.adddev_id = &i
	}
}

// AddedDevID returns the value that was added to the "dev_id" field in this mutation.
func (m *UpgradeDevGroupRelationMutation) AddedDevID() (r int, exists bool) {
	v := m.adddev_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDevID resets all changes to the "dev_id" field.
func (m *UpgradeDevGroupRelationMutation) ResetDevID() {
	m.dev_id = nil
	m.adddev_id = nil
}

// SetDevGroupID sets the "dev_group_id" field.
func (m *UpgradeDevGroupRelationMutation) SetDevGroupID(i int) {
	m.dev_group_id = &i
	m.adddev_group_id = nil
}

// DevGroupID returns the value of the "dev_group_id" field in the mutation.
func (m *UpgradeDevGroupRelationMutation) DevGroupID() (r int, exists bool) {
	v := m.dev_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDevGroupID returns the old "dev_group_id" field's value of the UpgradeDevGroupRelation entity.
// If the UpgradeDevGroupRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupRelationMutation) OldDevGroupID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevGroupID: %w", err)
	}
	return oldValue.DevGroupID, nil
}

// AddDevGroupID adds i to the "dev_group_id" field.
func (m *UpgradeDevGroupRelationMutation) AddDevGroupID(i int) {
	if m.adddev_group_id != nil {
		*m.adddev_group_id += i
	} else {
		m.adddev_group_id = &i
	}
}

// AddedDevGroupID returns the value that was added to the "dev_group_id" field in this mutation.
func (m *UpgradeDevGroupRelationMutation) AddedDevGroupID() (r int, exists bool) {
	v := m.adddev_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDevGroupID resets all changes to the "dev_group_id" field.
func (m *UpgradeDevGroupRelationMutation) ResetDevGroupID() {
	m.dev_group_id = nil
	m.adddev_group_id = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeDevGroupRelationMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeDevGroupRelationMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeDevGroupRelation entity.
// If the UpgradeDevGroupRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupRelationMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeDevGroupRelationMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeDevGroupRelationMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeDevGroupRelationMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeDevGroupRelationMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeDevGroupRelationMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeDevGroupRelation entity.
// If the UpgradeDevGroupRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupRelationMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeDevGroupRelationMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradedevgrouprelation.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeDevGroupRelationMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradedevgrouprelation.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeDevGroupRelationMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradedevgrouprelation.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeDevGroupRelationMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeDevGroupRelationMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeDevGroupRelation entity.
// If the UpgradeDevGroupRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevGroupRelationMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeDevGroupRelationMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradedevgrouprelation.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeDevGroupRelationMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradedevgrouprelation.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeDevGroupRelationMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradedevgrouprelation.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeDevGroupRelationMutation builder.
func (m *UpgradeDevGroupRelationMutation) Where(ps ...predicate.UpgradeDevGroupRelation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeDevGroupRelationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeDevGroupRelationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeDevGroupRelation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeDevGroupRelationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeDevGroupRelationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeDevGroupRelation).
func (m *UpgradeDevGroupRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeDevGroupRelationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.dev_id != nil {
		fields = append(fields, upgradedevgrouprelation.FieldDevID)
	}
	if m.dev_group_id != nil {
		fields = append(fields, upgradedevgrouprelation.FieldDevGroupID)
	}
	if m.is_del != nil {
		fields = append(fields, upgradedevgrouprelation.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradedevgrouprelation.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradedevgrouprelation.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeDevGroupRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradedevgrouprelation.FieldDevID:
		return m.DevID()
	case upgradedevgrouprelation.FieldDevGroupID:
		return m.DevGroupID()
	case upgradedevgrouprelation.FieldIsDel:
		return m.IsDel()
	case upgradedevgrouprelation.FieldCreateAt:
		return m.CreateAt()
	case upgradedevgrouprelation.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeDevGroupRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradedevgrouprelation.FieldDevID:
		return m.OldDevID(ctx)
	case upgradedevgrouprelation.FieldDevGroupID:
		return m.OldDevGroupID(ctx)
	case upgradedevgrouprelation.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradedevgrouprelation.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradedevgrouprelation.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeDevGroupRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevGroupRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradedevgrouprelation.FieldDevID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevID(v)
		return nil
	case upgradedevgrouprelation.FieldDevGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevGroupID(v)
		return nil
	case upgradedevgrouprelation.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradedevgrouprelation.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradedevgrouprelation.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroupRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeDevGroupRelationMutation) AddedFields() []string {
	var fields []string
	if m.adddev_id != nil {
		fields = append(fields, upgradedevgrouprelation.FieldDevID)
	}
	if m.adddev_group_id != nil {
		fields = append(fields, upgradedevgrouprelation.FieldDevGroupID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradedevgrouprelation.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeDevGroupRelationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradedevgrouprelation.FieldDevID:
		return m.AddedDevID()
	case upgradedevgrouprelation.FieldDevGroupID:
		return m.AddedDevGroupID()
	case upgradedevgrouprelation.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevGroupRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradedevgrouprelation.FieldDevID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDevID(v)
		return nil
	case upgradedevgrouprelation.FieldDevGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDevGroupID(v)
		return nil
	case upgradedevgrouprelation.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroupRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeDevGroupRelationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradedevgrouprelation.FieldCreateAt) {
		fields = append(fields, upgradedevgrouprelation.FieldCreateAt)
	}
	if m.FieldCleared(upgradedevgrouprelation.FieldUpdateAt) {
		fields = append(fields, upgradedevgrouprelation.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeDevGroupRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeDevGroupRelationMutation) ClearField(name string) error {
	switch name {
	case upgradedevgrouprelation.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradedevgrouprelation.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroupRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeDevGroupRelationMutation) ResetField(name string) error {
	switch name {
	case upgradedevgrouprelation.FieldDevID:
		m.ResetDevID()
		return nil
	case upgradedevgrouprelation.FieldDevGroupID:
		m.ResetDevGroupID()
		return nil
	case upgradedevgrouprelation.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradedevgrouprelation.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradedevgrouprelation.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevGroupRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeDevGroupRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeDevGroupRelationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeDevGroupRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeDevGroupRelationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeDevGroupRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeDevGroupRelationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeDevGroupRelationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDevGroupRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeDevGroupRelationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDevGroupRelation edge %s", name)
}

// UpgradeDevModelMutation represents an operation that mutates the UpgradeDevModel nodes in the graph.
type UpgradeDevModelMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	name          *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeDevModel, error)
	predicates    []predicate.UpgradeDevModel
}

var _ ent.Mutation = (*UpgradeDevModelMutation)(nil)

// upgradedevmodelOption allows management of the mutation configuration using functional options.
type upgradedevmodelOption func(*UpgradeDevModelMutation)

// newUpgradeDevModelMutation creates new mutation for the UpgradeDevModel entity.
func newUpgradeDevModelMutation(c config, op Op, opts ...upgradedevmodelOption) *UpgradeDevModelMutation {
	m := &UpgradeDevModelMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeDevModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeDevModelID sets the ID field of the mutation.
func withUpgradeDevModelID(id int) upgradedevmodelOption {
	return func(m *UpgradeDevModelMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeDevModel
		)
		m.oldValue = func(ctx context.Context) (*UpgradeDevModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeDevModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeDevModel sets the old UpgradeDevModel of the mutation.
func withUpgradeDevModel(node *UpgradeDevModel) upgradedevmodelOption {
	return func(m *UpgradeDevModelMutation) {
		m.oldValue = func(context.Context) (*UpgradeDevModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeDevModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeDevModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeDevModel entities.
func (m *UpgradeDevModelMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeDevModelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeDevModelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeDevModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeDevModelMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeDevModelMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeDevModel entity.
// If the UpgradeDevModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevModelMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeDevModelMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeDevModelMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeDevModelMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeDevModelMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeDevModelMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeDevModel entity.
// If the UpgradeDevModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevModelMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeDevModelMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UpgradeDevModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeDevModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeDevModel entity.
// If the UpgradeDevModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeDevModelMutation) ResetName() {
	m.name = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeDevModelMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeDevModelMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeDevModel entity.
// If the UpgradeDevModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevModelMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeDevModelMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeDevModelMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeDevModelMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeDevModelMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeDevModelMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeDevModel entity.
// If the UpgradeDevModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevModelMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeDevModelMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradedevmodel.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeDevModelMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradedevmodel.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeDevModelMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradedevmodel.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeDevModelMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeDevModelMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeDevModel entity.
// If the UpgradeDevModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeDevModelMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeDevModelMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradedevmodel.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeDevModelMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradedevmodel.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeDevModelMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradedevmodel.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeDevModelMutation builder.
func (m *UpgradeDevModelMutation) Where(ps ...predicate.UpgradeDevModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeDevModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeDevModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeDevModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeDevModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeDevModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeDevModel).
func (m *UpgradeDevModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeDevModelMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.company_id != nil {
		fields = append(fields, upgradedevmodel.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradedevmodel.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, upgradedevmodel.FieldName)
	}
	if m.is_del != nil {
		fields = append(fields, upgradedevmodel.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradedevmodel.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradedevmodel.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeDevModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradedevmodel.FieldCompanyID:
		return m.CompanyID()
	case upgradedevmodel.FieldKey:
		return m.Key()
	case upgradedevmodel.FieldName:
		return m.Name()
	case upgradedevmodel.FieldIsDel:
		return m.IsDel()
	case upgradedevmodel.FieldCreateAt:
		return m.CreateAt()
	case upgradedevmodel.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeDevModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradedevmodel.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradedevmodel.FieldKey:
		return m.OldKey(ctx)
	case upgradedevmodel.FieldName:
		return m.OldName(ctx)
	case upgradedevmodel.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradedevmodel.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradedevmodel.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeDevModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradedevmodel.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradedevmodel.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradedevmodel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradedevmodel.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradedevmodel.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradedevmodel.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeDevModelMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradedevmodel.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradedevmodel.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeDevModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradedevmodel.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradedevmodel.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeDevModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradedevmodel.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradedevmodel.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeDevModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradedevmodel.FieldCreateAt) {
		fields = append(fields, upgradedevmodel.FieldCreateAt)
	}
	if m.FieldCleared(upgradedevmodel.FieldUpdateAt) {
		fields = append(fields, upgradedevmodel.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeDevModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeDevModelMutation) ClearField(name string) error {
	switch name {
	case upgradedevmodel.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradedevmodel.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeDevModelMutation) ResetField(name string) error {
	switch name {
	case upgradedevmodel.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradedevmodel.FieldKey:
		m.ResetKey()
		return nil
	case upgradedevmodel.FieldName:
		m.ResetName()
		return nil
	case upgradedevmodel.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradedevmodel.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradedevmodel.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeDevModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeDevModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeDevModelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeDevModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeDevModelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeDevModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeDevModelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeDevModelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDevModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeDevModelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeDevModel edge %s", name)
}

// UpgradeElectronMutation represents an operation that mutates the UpgradeElectron nodes in the graph.
type UpgradeElectronMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	name          *string
	description   *string
	github_url    *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeElectron, error)
	predicates    []predicate.UpgradeElectron
}

var _ ent.Mutation = (*UpgradeElectronMutation)(nil)

// upgradeelectronOption allows management of the mutation configuration using functional options.
type upgradeelectronOption func(*UpgradeElectronMutation)

// newUpgradeElectronMutation creates new mutation for the UpgradeElectron entity.
func newUpgradeElectronMutation(c config, op Op, opts ...upgradeelectronOption) *UpgradeElectronMutation {
	m := &UpgradeElectronMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeElectron,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeElectronID sets the ID field of the mutation.
func withUpgradeElectronID(id int) upgradeelectronOption {
	return func(m *UpgradeElectronMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeElectron
		)
		m.oldValue = func(ctx context.Context) (*UpgradeElectron, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeElectron.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeElectron sets the old UpgradeElectron of the mutation.
func withUpgradeElectron(node *UpgradeElectron) upgradeelectronOption {
	return func(m *UpgradeElectronMutation) {
		m.oldValue = func(context.Context) (*UpgradeElectron, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeElectronMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeElectronMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeElectron entities.
func (m *UpgradeElectronMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeElectronMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeElectronMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeElectron.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeElectronMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeElectronMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeElectronMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeElectronMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeElectronMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeElectronMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeElectronMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeElectronMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UpgradeElectronMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeElectronMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeElectronMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeElectronMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeElectronMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeElectronMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeelectron.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeElectronMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeelectron.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeElectronMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeelectron.FieldDescription)
}

// SetGithubURL sets the "github_url" field.
func (m *UpgradeElectronMutation) SetGithubURL(s string) {
	m.github_url = &s
}

// GithubURL returns the value of the "github_url" field in the mutation.
func (m *UpgradeElectronMutation) GithubURL() (r string, exists bool) {
	v := m.github_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubURL returns the old "github_url" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldGithubURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubURL: %w", err)
	}
	return oldValue.GithubURL, nil
}

// ClearGithubURL clears the value of the "github_url" field.
func (m *UpgradeElectronMutation) ClearGithubURL() {
	m.github_url = nil
	m.clearedFields[upgradeelectron.FieldGithubURL] = struct{}{}
}

// GithubURLCleared returns if the "github_url" field was cleared in this mutation.
func (m *UpgradeElectronMutation) GithubURLCleared() bool {
	_, ok := m.clearedFields[upgradeelectron.FieldGithubURL]
	return ok
}

// ResetGithubURL resets all changes to the "github_url" field.
func (m *UpgradeElectronMutation) ResetGithubURL() {
	m.github_url = nil
	delete(m.clearedFields, upgradeelectron.FieldGithubURL)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeElectronMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeElectronMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeElectronMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeElectronMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeElectronMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeElectronMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeElectronMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeElectronMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeelectron.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeElectronMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectron.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeElectronMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeelectron.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeElectronMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeElectronMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeElectron entity.
// If the UpgradeElectron object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeElectronMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeelectron.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeElectronMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectron.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeElectronMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeelectron.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeElectronMutation builder.
func (m *UpgradeElectronMutation) Where(ps ...predicate.UpgradeElectron) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeElectronMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeElectronMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeElectron, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeElectronMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeElectronMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeElectron).
func (m *UpgradeElectronMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeElectronMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.company_id != nil {
		fields = append(fields, upgradeelectron.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradeelectron.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, upgradeelectron.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradeelectron.FieldDescription)
	}
	if m.github_url != nil {
		fields = append(fields, upgradeelectron.FieldGithubURL)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeelectron.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeelectron.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeelectron.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeElectronMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectron.FieldCompanyID:
		return m.CompanyID()
	case upgradeelectron.FieldKey:
		return m.Key()
	case upgradeelectron.FieldName:
		return m.Name()
	case upgradeelectron.FieldDescription:
		return m.Description()
	case upgradeelectron.FieldGithubURL:
		return m.GithubURL()
	case upgradeelectron.FieldIsDel:
		return m.IsDel()
	case upgradeelectron.FieldCreateAt:
		return m.CreateAt()
	case upgradeelectron.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeElectronMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeelectron.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeelectron.FieldKey:
		return m.OldKey(ctx)
	case upgradeelectron.FieldName:
		return m.OldName(ctx)
	case upgradeelectron.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeelectron.FieldGithubURL:
		return m.OldGithubURL(ctx)
	case upgradeelectron.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeelectron.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeelectron.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeElectron field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeelectron.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeelectron.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradeelectron.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeelectron.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeelectron.FieldGithubURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubURL(v)
		return nil
	case upgradeelectron.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeelectron.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeelectron.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectron field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeElectronMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeelectron.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeelectron.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeElectronMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectron.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeelectron.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeelectron.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeelectron.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectron numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeElectronMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeelectron.FieldDescription) {
		fields = append(fields, upgradeelectron.FieldDescription)
	}
	if m.FieldCleared(upgradeelectron.FieldGithubURL) {
		fields = append(fields, upgradeelectron.FieldGithubURL)
	}
	if m.FieldCleared(upgradeelectron.FieldCreateAt) {
		fields = append(fields, upgradeelectron.FieldCreateAt)
	}
	if m.FieldCleared(upgradeelectron.FieldUpdateAt) {
		fields = append(fields, upgradeelectron.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeElectronMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeElectronMutation) ClearField(name string) error {
	switch name {
	case upgradeelectron.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeelectron.FieldGithubURL:
		m.ClearGithubURL()
		return nil
	case upgradeelectron.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeelectron.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectron nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeElectronMutation) ResetField(name string) error {
	switch name {
	case upgradeelectron.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeelectron.FieldKey:
		m.ResetKey()
		return nil
	case upgradeelectron.FieldName:
		m.ResetName()
		return nil
	case upgradeelectron.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeelectron.FieldGithubURL:
		m.ResetGithubURL()
		return nil
	case upgradeelectron.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeelectron.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeelectron.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectron field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeElectronMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeElectronMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeElectronMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeElectronMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeElectronMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeElectronMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeElectronMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectron unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeElectronMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectron edge %s", name)
}

// UpgradeElectronUpgradeStrategyMutation represents an operation that mutates the UpgradeElectronUpgradeStrategy nodes in the graph.
type UpgradeElectronUpgradeStrategyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	company_id              *int
	addcompany_id           *int
	enable                  *int32
	addenable               *int32
	name                    *string
	description             *string
	electron_id             *int
	addelectron_id          *int
	electron_version_id     *int
	addelectron_version_id  *int
	begin_datetime          *time.Time
	end_datetime            *time.Time
	upgrade_type            *int32
	addupgrade_type         *int32
	prompt_upgrade_content  *string
	upgrade_dev_type        *int32
	addupgrade_dev_type     *int32
	upgrade_dev_data        *string
	upgrade_version_type    *int32
	addupgrade_version_type *int32
	upgrade_version_data    *string
	is_gray                 *int32
	addis_gray              *int32
	gray_data               *string
	is_flow_limit           *int32
	addis_flow_limit        *int32
	flow_limit_data         *string
	is_del                  *int32
	addis_del               *int32
	create_at               *time.Time
	update_at               *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*UpgradeElectronUpgradeStrategy, error)
	predicates              []predicate.UpgradeElectronUpgradeStrategy
}

var _ ent.Mutation = (*UpgradeElectronUpgradeStrategyMutation)(nil)

// upgradeelectronupgradestrategyOption allows management of the mutation configuration using functional options.
type upgradeelectronupgradestrategyOption func(*UpgradeElectronUpgradeStrategyMutation)

// newUpgradeElectronUpgradeStrategyMutation creates new mutation for the UpgradeElectronUpgradeStrategy entity.
func newUpgradeElectronUpgradeStrategyMutation(c config, op Op, opts ...upgradeelectronupgradestrategyOption) *UpgradeElectronUpgradeStrategyMutation {
	m := &UpgradeElectronUpgradeStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeElectronUpgradeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeElectronUpgradeStrategyID sets the ID field of the mutation.
func withUpgradeElectronUpgradeStrategyID(id int) upgradeelectronupgradestrategyOption {
	return func(m *UpgradeElectronUpgradeStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeElectronUpgradeStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeElectronUpgradeStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeElectronUpgradeStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeElectronUpgradeStrategy sets the old UpgradeElectronUpgradeStrategy of the mutation.
func withUpgradeElectronUpgradeStrategy(node *UpgradeElectronUpgradeStrategy) upgradeelectronupgradestrategyOption {
	return func(m *UpgradeElectronUpgradeStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeElectronUpgradeStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeElectronUpgradeStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeElectronUpgradeStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeElectronUpgradeStrategy entities.
func (m *UpgradeElectronUpgradeStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeElectronUpgradeStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeElectronUpgradeStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetEnable sets the "enable" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetName sets the "name" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeelectronupgradestrategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeelectronupgradestrategy.FieldDescription)
}

// SetElectronID sets the "electron_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetElectronID(i int) {
	m.electron_id = &i
	m.addelectron_id = nil
}

// ElectronID returns the value of the "electron_id" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) ElectronID() (r int, exists bool) {
	v := m.electron_id
	if v == nil {
		return
	}
	return *v, true
}

// OldElectronID returns the old "electron_id" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldElectronID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectronID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectronID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectronID: %w", err)
	}
	return oldValue.ElectronID, nil
}

// AddElectronID adds i to the "electron_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddElectronID(i int) {
	if m.addelectron_id != nil {
		*m.addelectron_id += i
	} else {
		m.addelectron_id = &i
	}
}

// AddedElectronID returns the value that was added to the "electron_id" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedElectronID() (r int, exists bool) {
	v := m.addelectron_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectronID resets all changes to the "electron_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetElectronID() {
	m.electron_id = nil
	m.addelectron_id = nil
}

// SetElectronVersionID sets the "electron_version_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetElectronVersionID(i int) {
	m.electron_version_id = &i
	m.addelectron_version_id = nil
}

// ElectronVersionID returns the value of the "electron_version_id" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) ElectronVersionID() (r int, exists bool) {
	v := m.electron_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldElectronVersionID returns the old "electron_version_id" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldElectronVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectronVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectronVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectronVersionID: %w", err)
	}
	return oldValue.ElectronVersionID, nil
}

// AddElectronVersionID adds i to the "electron_version_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddElectronVersionID(i int) {
	if m.addelectron_version_id != nil {
		*m.addelectron_version_id += i
	} else {
		m.addelectron_version_id = &i
	}
}

// AddedElectronVersionID returns the value that was added to the "electron_version_id" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedElectronVersionID() (r int, exists bool) {
	v := m.addelectron_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectronVersionID resets all changes to the "electron_version_id" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetElectronVersionID() {
	m.electron_version_id = nil
	m.addelectron_version_id = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetUpgradeType sets the "upgrade_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetUpgradeType(i int32) {
	m.upgrade_type = &i
	m.addupgrade_type = nil
}

// UpgradeType returns the value of the "upgrade_type" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) UpgradeType() (r int32, exists bool) {
	v := m.upgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeType returns the old "upgrade_type" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldUpgradeType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeType: %w", err)
	}
	return oldValue.UpgradeType, nil
}

// AddUpgradeType adds i to the "upgrade_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddUpgradeType(i int32) {
	if m.addupgrade_type != nil {
		*m.addupgrade_type += i
	} else {
		m.addupgrade_type = &i
	}
}

// AddedUpgradeType returns the value that was added to the "upgrade_type" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedUpgradeType() (r int32, exists bool) {
	v := m.addupgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeType resets all changes to the "upgrade_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetUpgradeType() {
	m.upgrade_type = nil
	m.addupgrade_type = nil
}

// SetPromptUpgradeContent sets the "prompt_upgrade_content" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetPromptUpgradeContent(s string) {
	m.prompt_upgrade_content = &s
}

// PromptUpgradeContent returns the value of the "prompt_upgrade_content" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) PromptUpgradeContent() (r string, exists bool) {
	v := m.prompt_upgrade_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptUpgradeContent returns the old "prompt_upgrade_content" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldPromptUpgradeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptUpgradeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptUpgradeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptUpgradeContent: %w", err)
	}
	return oldValue.PromptUpgradeContent, nil
}

// ClearPromptUpgradeContent clears the value of the "prompt_upgrade_content" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	m.clearedFields[upgradeelectronupgradestrategy.FieldPromptUpgradeContent] = struct{}{}
}

// PromptUpgradeContentCleared returns if the "prompt_upgrade_content" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) PromptUpgradeContentCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategy.FieldPromptUpgradeContent]
	return ok
}

// ResetPromptUpgradeContent resets all changes to the "prompt_upgrade_content" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	delete(m.clearedFields, upgradeelectronupgradestrategy.FieldPromptUpgradeContent)
}

// SetUpgradeDevType sets the "upgrade_dev_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetUpgradeDevType(i int32) {
	m.upgrade_dev_type = &i
	m.addupgrade_dev_type = nil
}

// UpgradeDevType returns the value of the "upgrade_dev_type" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) UpgradeDevType() (r int32, exists bool) {
	v := m.upgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevType returns the old "upgrade_dev_type" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldUpgradeDevType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevType: %w", err)
	}
	return oldValue.UpgradeDevType, nil
}

// AddUpgradeDevType adds i to the "upgrade_dev_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddUpgradeDevType(i int32) {
	if m.addupgrade_dev_type != nil {
		*m.addupgrade_dev_type += i
	} else {
		m.addupgrade_dev_type = &i
	}
}

// AddedUpgradeDevType returns the value that was added to the "upgrade_dev_type" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedUpgradeDevType() (r int32, exists bool) {
	v := m.addupgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeDevType resets all changes to the "upgrade_dev_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetUpgradeDevType() {
	m.upgrade_dev_type = nil
	m.addupgrade_dev_type = nil
}

// SetUpgradeDevData sets the "upgrade_dev_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetUpgradeDevData(s string) {
	m.upgrade_dev_data = &s
}

// UpgradeDevData returns the value of the "upgrade_dev_data" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) UpgradeDevData() (r string, exists bool) {
	v := m.upgrade_dev_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevData returns the old "upgrade_dev_data" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldUpgradeDevData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevData: %w", err)
	}
	return oldValue.UpgradeDevData, nil
}

// ResetUpgradeDevData resets all changes to the "upgrade_dev_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetUpgradeDevData() {
	m.upgrade_dev_data = nil
}

// SetUpgradeVersionType sets the "upgrade_version_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetUpgradeVersionType(i int32) {
	m.upgrade_version_type = &i
	m.addupgrade_version_type = nil
}

// UpgradeVersionType returns the value of the "upgrade_version_type" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) UpgradeVersionType() (r int32, exists bool) {
	v := m.upgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionType returns the old "upgrade_version_type" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldUpgradeVersionType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionType: %w", err)
	}
	return oldValue.UpgradeVersionType, nil
}

// AddUpgradeVersionType adds i to the "upgrade_version_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddUpgradeVersionType(i int32) {
	if m.addupgrade_version_type != nil {
		*m.addupgrade_version_type += i
	} else {
		m.addupgrade_version_type = &i
	}
}

// AddedUpgradeVersionType returns the value that was added to the "upgrade_version_type" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedUpgradeVersionType() (r int32, exists bool) {
	v := m.addupgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeVersionType resets all changes to the "upgrade_version_type" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetUpgradeVersionType() {
	m.upgrade_version_type = nil
	m.addupgrade_version_type = nil
}

// SetUpgradeVersionData sets the "upgrade_version_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetUpgradeVersionData(s string) {
	m.upgrade_version_data = &s
}

// UpgradeVersionData returns the value of the "upgrade_version_data" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) UpgradeVersionData() (r string, exists bool) {
	v := m.upgrade_version_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionData returns the old "upgrade_version_data" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldUpgradeVersionData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionData: %w", err)
	}
	return oldValue.UpgradeVersionData, nil
}

// ResetUpgradeVersionData resets all changes to the "upgrade_version_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetUpgradeVersionData() {
	m.upgrade_version_data = nil
}

// SetIsGray sets the "is_gray" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetIsGray(i int32) {
	m.is_gray = &i
	m.addis_gray = nil
}

// IsGray returns the value of the "is_gray" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) IsGray() (r int32, exists bool) {
	v := m.is_gray
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGray returns the old "is_gray" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldIsGray(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGray: %w", err)
	}
	return oldValue.IsGray, nil
}

// AddIsGray adds i to the "is_gray" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddIsGray(i int32) {
	if m.addis_gray != nil {
		*m.addis_gray += i
	} else {
		m.addis_gray = &i
	}
}

// AddedIsGray returns the value that was added to the "is_gray" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedIsGray() (r int32, exists bool) {
	v := m.addis_gray
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsGray resets all changes to the "is_gray" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetIsGray() {
	m.is_gray = nil
	m.addis_gray = nil
}

// SetGrayData sets the "gray_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetGrayData(s string) {
	m.gray_data = &s
}

// GrayData returns the value of the "gray_data" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) GrayData() (r string, exists bool) {
	v := m.gray_data
	if v == nil {
		return
	}
	return *v, true
}

// OldGrayData returns the old "gray_data" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldGrayData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrayData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrayData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrayData: %w", err)
	}
	return oldValue.GrayData, nil
}

// ResetGrayData resets all changes to the "gray_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetGrayData() {
	m.gray_data = nil
}

// SetIsFlowLimit sets the "is_flow_limit" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetIsFlowLimit(i int32) {
	m.is_flow_limit = &i
	m.addis_flow_limit = nil
}

// IsFlowLimit returns the value of the "is_flow_limit" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) IsFlowLimit() (r int32, exists bool) {
	v := m.is_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlowLimit returns the old "is_flow_limit" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldIsFlowLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlowLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlowLimit: %w", err)
	}
	return oldValue.IsFlowLimit, nil
}

// AddIsFlowLimit adds i to the "is_flow_limit" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddIsFlowLimit(i int32) {
	if m.addis_flow_limit != nil {
		*m.addis_flow_limit += i
	} else {
		m.addis_flow_limit = &i
	}
}

// AddedIsFlowLimit returns the value that was added to the "is_flow_limit" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedIsFlowLimit() (r int32, exists bool) {
	v := m.addis_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFlowLimit resets all changes to the "is_flow_limit" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetIsFlowLimit() {
	m.is_flow_limit = nil
	m.addis_flow_limit = nil
}

// SetFlowLimitData sets the "flow_limit_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetFlowLimitData(s string) {
	m.flow_limit_data = &s
}

// FlowLimitData returns the value of the "flow_limit_data" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) FlowLimitData() (r string, exists bool) {
	v := m.flow_limit_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowLimitData returns the old "flow_limit_data" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldFlowLimitData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowLimitData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowLimitData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowLimitData: %w", err)
	}
	return oldValue.FlowLimitData, nil
}

// ResetFlowLimitData resets all changes to the "flow_limit_data" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetFlowLimitData() {
	m.flow_limit_data = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeelectronupgradestrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeelectronupgradestrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeElectronUpgradeStrategy entity.
// If the UpgradeElectronUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeelectronupgradestrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeelectronupgradestrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeElectronUpgradeStrategyMutation builder.
func (m *UpgradeElectronUpgradeStrategyMutation) Where(ps ...predicate.UpgradeElectronUpgradeStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeElectronUpgradeStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeElectronUpgradeStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeElectronUpgradeStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeElectronUpgradeStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeElectronUpgradeStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeElectronUpgradeStrategy).
func (m *UpgradeElectronUpgradeStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeElectronUpgradeStrategyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.company_id != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldCompanyID)
	}
	if m.enable != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldDescription)
	}
	if m.electron_id != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldElectronID)
	}
	if m.electron_version_id != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldElectronVersionID)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldEndDatetime)
	}
	if m.upgrade_type != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeType)
	}
	if m.prompt_upgrade_content != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.upgrade_dev_type != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeDevType)
	}
	if m.upgrade_dev_data != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeDevData)
	}
	if m.upgrade_version_type != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeVersionType)
	}
	if m.upgrade_version_data != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeVersionData)
	}
	if m.is_gray != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldIsGray)
	}
	if m.gray_data != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldGrayData)
	}
	if m.is_flow_limit != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldIsFlowLimit)
	}
	if m.flow_limit_data != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldFlowLimitData)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeElectronUpgradeStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronupgradestrategy.FieldCompanyID:
		return m.CompanyID()
	case upgradeelectronupgradestrategy.FieldEnable:
		return m.Enable()
	case upgradeelectronupgradestrategy.FieldName:
		return m.Name()
	case upgradeelectronupgradestrategy.FieldDescription:
		return m.Description()
	case upgradeelectronupgradestrategy.FieldElectronID:
		return m.ElectronID()
	case upgradeelectronupgradestrategy.FieldElectronVersionID:
		return m.ElectronVersionID()
	case upgradeelectronupgradestrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeelectronupgradestrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeelectronupgradestrategy.FieldUpgradeType:
		return m.UpgradeType()
	case upgradeelectronupgradestrategy.FieldPromptUpgradeContent:
		return m.PromptUpgradeContent()
	case upgradeelectronupgradestrategy.FieldUpgradeDevType:
		return m.UpgradeDevType()
	case upgradeelectronupgradestrategy.FieldUpgradeDevData:
		return m.UpgradeDevData()
	case upgradeelectronupgradestrategy.FieldUpgradeVersionType:
		return m.UpgradeVersionType()
	case upgradeelectronupgradestrategy.FieldUpgradeVersionData:
		return m.UpgradeVersionData()
	case upgradeelectronupgradestrategy.FieldIsGray:
		return m.IsGray()
	case upgradeelectronupgradestrategy.FieldGrayData:
		return m.GrayData()
	case upgradeelectronupgradestrategy.FieldIsFlowLimit:
		return m.IsFlowLimit()
	case upgradeelectronupgradestrategy.FieldFlowLimitData:
		return m.FlowLimitData()
	case upgradeelectronupgradestrategy.FieldIsDel:
		return m.IsDel()
	case upgradeelectronupgradestrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeelectronupgradestrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeElectronUpgradeStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeelectronupgradestrategy.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeelectronupgradestrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeelectronupgradestrategy.FieldName:
		return m.OldName(ctx)
	case upgradeelectronupgradestrategy.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeelectronupgradestrategy.FieldElectronID:
		return m.OldElectronID(ctx)
	case upgradeelectronupgradestrategy.FieldElectronVersionID:
		return m.OldElectronVersionID(ctx)
	case upgradeelectronupgradestrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeelectronupgradestrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeelectronupgradestrategy.FieldUpgradeType:
		return m.OldUpgradeType(ctx)
	case upgradeelectronupgradestrategy.FieldPromptUpgradeContent:
		return m.OldPromptUpgradeContent(ctx)
	case upgradeelectronupgradestrategy.FieldUpgradeDevType:
		return m.OldUpgradeDevType(ctx)
	case upgradeelectronupgradestrategy.FieldUpgradeDevData:
		return m.OldUpgradeDevData(ctx)
	case upgradeelectronupgradestrategy.FieldUpgradeVersionType:
		return m.OldUpgradeVersionType(ctx)
	case upgradeelectronupgradestrategy.FieldUpgradeVersionData:
		return m.OldUpgradeVersionData(ctx)
	case upgradeelectronupgradestrategy.FieldIsGray:
		return m.OldIsGray(ctx)
	case upgradeelectronupgradestrategy.FieldGrayData:
		return m.OldGrayData(ctx)
	case upgradeelectronupgradestrategy.FieldIsFlowLimit:
		return m.OldIsFlowLimit(ctx)
	case upgradeelectronupgradestrategy.FieldFlowLimitData:
		return m.OldFlowLimitData(ctx)
	case upgradeelectronupgradestrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeelectronupgradestrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeelectronupgradestrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeElectronUpgradeStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronUpgradeStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeelectronupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeelectronupgradestrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeelectronupgradestrategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeelectronupgradestrategy.FieldElectronID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectronID(v)
		return nil
	case upgradeelectronupgradestrategy.FieldElectronVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectronVersionID(v)
		return nil
	case upgradeelectronupgradestrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeelectronupgradestrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeType(v)
		return nil
	case upgradeelectronupgradestrategy.FieldPromptUpgradeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptUpgradeContent(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevType(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeDevData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevData(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionType(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeVersionData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionData(v)
		return nil
	case upgradeelectronupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGray(v)
		return nil
	case upgradeelectronupgradestrategy.FieldGrayData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrayData(v)
		return nil
	case upgradeelectronupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlowLimit(v)
		return nil
	case upgradeelectronupgradestrategy.FieldFlowLimitData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowLimitData(v)
		return nil
	case upgradeelectronupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeelectronupgradestrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldCompanyID)
	}
	if m.addenable != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldEnable)
	}
	if m.addelectron_id != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldElectronID)
	}
	if m.addelectron_version_id != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldElectronVersionID)
	}
	if m.addupgrade_type != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeType)
	}
	if m.addupgrade_dev_type != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeDevType)
	}
	if m.addupgrade_version_type != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpgradeVersionType)
	}
	if m.addis_gray != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldIsGray)
	}
	if m.addis_flow_limit != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldIsFlowLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeelectronupgradestrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronupgradestrategy.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeelectronupgradestrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeelectronupgradestrategy.FieldElectronID:
		return m.AddedElectronID()
	case upgradeelectronupgradestrategy.FieldElectronVersionID:
		return m.AddedElectronVersionID()
	case upgradeelectronupgradestrategy.FieldUpgradeType:
		return m.AddedUpgradeType()
	case upgradeelectronupgradestrategy.FieldUpgradeDevType:
		return m.AddedUpgradeDevType()
	case upgradeelectronupgradestrategy.FieldUpgradeVersionType:
		return m.AddedUpgradeVersionType()
	case upgradeelectronupgradestrategy.FieldIsGray:
		return m.AddedIsGray()
	case upgradeelectronupgradestrategy.FieldIsFlowLimit:
		return m.AddedIsFlowLimit()
	case upgradeelectronupgradestrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronUpgradeStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeelectronupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeelectronupgradestrategy.FieldElectronID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectronID(v)
		return nil
	case upgradeelectronupgradestrategy.FieldElectronVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectronVersionID(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeType(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeDevType(v)
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeVersionType(v)
		return nil
	case upgradeelectronupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsGray(v)
		return nil
	case upgradeelectronupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFlowLimit(v)
		return nil
	case upgradeelectronupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeelectronupgradestrategy.FieldDescription) {
		fields = append(fields, upgradeelectronupgradestrategy.FieldDescription)
	}
	if m.FieldCleared(upgradeelectronupgradestrategy.FieldPromptUpgradeContent) {
		fields = append(fields, upgradeelectronupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.FieldCleared(upgradeelectronupgradestrategy.FieldCreateAt) {
		fields = append(fields, upgradeelectronupgradestrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeelectronupgradestrategy.FieldUpdateAt) {
		fields = append(fields, upgradeelectronupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeelectronupgradestrategy.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeelectronupgradestrategy.FieldPromptUpgradeContent:
		m.ClearPromptUpgradeContent()
		return nil
	case upgradeelectronupgradestrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeelectronupgradestrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeelectronupgradestrategy.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeelectronupgradestrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeelectronupgradestrategy.FieldName:
		m.ResetName()
		return nil
	case upgradeelectronupgradestrategy.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeelectronupgradestrategy.FieldElectronID:
		m.ResetElectronID()
		return nil
	case upgradeelectronupgradestrategy.FieldElectronVersionID:
		m.ResetElectronVersionID()
		return nil
	case upgradeelectronupgradestrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeelectronupgradestrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeType:
		m.ResetUpgradeType()
		return nil
	case upgradeelectronupgradestrategy.FieldPromptUpgradeContent:
		m.ResetPromptUpgradeContent()
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeDevType:
		m.ResetUpgradeDevType()
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeDevData:
		m.ResetUpgradeDevData()
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeVersionType:
		m.ResetUpgradeVersionType()
		return nil
	case upgradeelectronupgradestrategy.FieldUpgradeVersionData:
		m.ResetUpgradeVersionData()
		return nil
	case upgradeelectronupgradestrategy.FieldIsGray:
		m.ResetIsGray()
		return nil
	case upgradeelectronupgradestrategy.FieldGrayData:
		m.ResetGrayData()
		return nil
	case upgradeelectronupgradestrategy.FieldIsFlowLimit:
		m.ResetIsFlowLimit()
		return nil
	case upgradeelectronupgradestrategy.FieldFlowLimitData:
		m.ResetFlowLimitData()
		return nil
	case upgradeelectronupgradestrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeelectronupgradestrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeelectronupgradestrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategy edge %s", name)
}

// UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation represents an operation that mutates the UpgradeElectronUpgradeStrategyFlowLimitStrategy nodes in the graph.
type UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	enable        *int32
	addenable     *int32
	begin_time    *string
	end_time      *string
	dimension     *int32
	adddimension  *int32
	_limit        *int
	add_limit     *int
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeElectronUpgradeStrategyFlowLimitStrategy, error)
	predicates    []predicate.UpgradeElectronUpgradeStrategyFlowLimitStrategy
}

var _ ent.Mutation = (*UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation)(nil)

// upgradeelectronupgradestrategyflowlimitstrategyOption allows management of the mutation configuration using functional options.
type upgradeelectronupgradestrategyflowlimitstrategyOption func(*UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation)

// newUpgradeElectronUpgradeStrategyFlowLimitStrategyMutation creates new mutation for the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
func newUpgradeElectronUpgradeStrategyFlowLimitStrategyMutation(c config, op Op, opts ...upgradeelectronupgradestrategyflowlimitstrategyOption) *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation {
	m := &UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeElectronUpgradeStrategyFlowLimitStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeElectronUpgradeStrategyFlowLimitStrategyID sets the ID field of the mutation.
func withUpgradeElectronUpgradeStrategyFlowLimitStrategyID(id int) upgradeelectronupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeElectronUpgradeStrategyFlowLimitStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeElectronUpgradeStrategyFlowLimitStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeElectronUpgradeStrategyFlowLimitStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeElectronUpgradeStrategyFlowLimitStrategy sets the old UpgradeElectronUpgradeStrategyFlowLimitStrategy of the mutation.
func withUpgradeElectronUpgradeStrategyFlowLimitStrategy(node *UpgradeElectronUpgradeStrategyFlowLimitStrategy) upgradeelectronupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeElectronUpgradeStrategyFlowLimitStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeElectronUpgradeStrategyFlowLimitStrategy entities.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeElectronUpgradeStrategyFlowLimitStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginTime sets the "begin_time" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetBeginTime(s string) {
	m.begin_time = &s
}

// BeginTime returns the value of the "begin_time" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) BeginTime() (r string, exists bool) {
	v := m.begin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "begin_time" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldBeginTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "begin_time" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetBeginTime() {
	m.begin_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDimension sets the "dimension" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetDimension(i int32) {
	m.dimension = &i
	m.adddimension = nil
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Dimension() (r int32, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldDimension(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// AddDimension adds i to the "dimension" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddDimension(i int32) {
	if m.adddimension != nil {
		*m.adddimension += i
	} else {
		m.adddimension = &i
	}
}

// AddedDimension returns the value that was added to the "dimension" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedDimension() (r int32, exists bool) {
	v := m.adddimension
	if v == nil {
		return
	}
	return *v, true
}

// ResetDimension resets all changes to the "dimension" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetDimension() {
	m.dimension = nil
	m.adddimension = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeElectronUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeElectronUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation builder.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Where(ps ...predicate.UpgradeElectronUpgradeStrategyFlowLimitStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeElectronUpgradeStrategyFlowLimitStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeElectronUpgradeStrategyFlowLimitStrategy).
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.enable != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.begin_time != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldBeginTime)
	}
	if m.end_time != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldEndTime)
	}
	if m.dimension != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m._limit != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable:
		return m.Enable()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.BeginTime()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.EndTime()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension:
		return m.Dimension()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit:
		return m.Limit()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.IsDel()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.OldEndTime(ctx)
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension:
		return m.OldDimension(ctx)
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeElectronUpgradeStrategyFlowLimitStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldBeginTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.adddimension != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension:
		return m.AddedDimension()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimension(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyFlowLimitStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt) {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt) {
		fields = append(fields, upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyFlowLimitStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldEndTime:
		m.ResetEndTime()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldDimension:
		m.ResetDimension()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeelectronupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyFlowLimitStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyFlowLimitStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyFlowLimitStrategy edge %s", name)
}

// UpgradeElectronUpgradeStrategyGrayStrategyMutation represents an operation that mutates the UpgradeElectronUpgradeStrategyGrayStrategy nodes in the graph.
type UpgradeElectronUpgradeStrategyGrayStrategyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	enable         *int32
	addenable      *int32
	begin_datetime *time.Time
	end_datetime   *time.Time
	_limit         *int
	add_limit      *int
	is_del         *int32
	addis_del      *int32
	create_at      *time.Time
	update_at      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UpgradeElectronUpgradeStrategyGrayStrategy, error)
	predicates     []predicate.UpgradeElectronUpgradeStrategyGrayStrategy
}

var _ ent.Mutation = (*UpgradeElectronUpgradeStrategyGrayStrategyMutation)(nil)

// upgradeelectronupgradestrategygraystrategyOption allows management of the mutation configuration using functional options.
type upgradeelectronupgradestrategygraystrategyOption func(*UpgradeElectronUpgradeStrategyGrayStrategyMutation)

// newUpgradeElectronUpgradeStrategyGrayStrategyMutation creates new mutation for the UpgradeElectronUpgradeStrategyGrayStrategy entity.
func newUpgradeElectronUpgradeStrategyGrayStrategyMutation(c config, op Op, opts ...upgradeelectronupgradestrategygraystrategyOption) *UpgradeElectronUpgradeStrategyGrayStrategyMutation {
	m := &UpgradeElectronUpgradeStrategyGrayStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeElectronUpgradeStrategyGrayStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeElectronUpgradeStrategyGrayStrategyID sets the ID field of the mutation.
func withUpgradeElectronUpgradeStrategyGrayStrategyID(id int) upgradeelectronupgradestrategygraystrategyOption {
	return func(m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeElectronUpgradeStrategyGrayStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeElectronUpgradeStrategyGrayStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeElectronUpgradeStrategyGrayStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeElectronUpgradeStrategyGrayStrategy sets the old UpgradeElectronUpgradeStrategyGrayStrategy of the mutation.
func withUpgradeElectronUpgradeStrategyGrayStrategy(node *UpgradeElectronUpgradeStrategyGrayStrategy) upgradeelectronupgradestrategygraystrategyOption {
	return func(m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeElectronUpgradeStrategyGrayStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeElectronUpgradeStrategyGrayStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeElectronUpgradeStrategyGrayStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeElectronUpgradeStrategyGrayStrategy entities.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeElectronUpgradeStrategyGrayStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeElectronUpgradeStrategyGrayStrategy entity.
// If the UpgradeElectronUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeElectronUpgradeStrategyGrayStrategy entity.
// If the UpgradeElectronUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeElectronUpgradeStrategyGrayStrategy entity.
// If the UpgradeElectronUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeElectronUpgradeStrategyGrayStrategy entity.
// If the UpgradeElectronUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeElectronUpgradeStrategyGrayStrategy entity.
// If the UpgradeElectronUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeElectronUpgradeStrategyGrayStrategy entity.
// If the UpgradeElectronUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeelectronupgradestrategygraystrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategygraystrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeelectronupgradestrategygraystrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeElectronUpgradeStrategyGrayStrategy entity.
// If the UpgradeElectronUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeelectronupgradestrategygraystrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronupgradestrategygraystrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeelectronupgradestrategygraystrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeElectronUpgradeStrategyGrayStrategyMutation builder.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) Where(ps ...predicate.UpgradeElectronUpgradeStrategyGrayStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeElectronUpgradeStrategyGrayStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeElectronUpgradeStrategyGrayStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeElectronUpgradeStrategyGrayStrategy).
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.enable != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldEnable)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldEndDatetime)
	}
	if m._limit != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronupgradestrategygraystrategy.FieldEnable:
		return m.Enable()
	case upgradeelectronupgradestrategygraystrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeelectronupgradestrategygraystrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeelectronupgradestrategygraystrategy.FieldLimit:
		return m.Limit()
	case upgradeelectronupgradestrategygraystrategy.FieldIsDel:
		return m.IsDel()
	case upgradeelectronupgradestrategygraystrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeelectronupgradestrategygraystrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeelectronupgradestrategygraystrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeelectronupgradestrategygraystrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeelectronupgradestrategygraystrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeelectronupgradestrategygraystrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeelectronupgradestrategygraystrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeelectronupgradestrategygraystrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeelectronupgradestrategygraystrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeElectronUpgradeStrategyGrayStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyGrayStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldEnable)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronupgradestrategygraystrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeelectronupgradestrategygraystrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeelectronupgradestrategygraystrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyGrayStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeelectronupgradestrategygraystrategy.FieldCreateAt) {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeelectronupgradestrategygraystrategy.FieldUpdateAt) {
		fields = append(fields, upgradeelectronupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeelectronupgradestrategygraystrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyGrayStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeelectronupgradestrategygraystrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeelectronupgradestrategygraystrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyGrayStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyGrayStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeElectronUpgradeStrategyGrayStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronUpgradeStrategyGrayStrategy edge %s", name)
}

// UpgradeElectronVersionMutation represents an operation that mutates the UpgradeElectronVersion nodes in the graph.
type UpgradeElectronVersionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	company_id            *int
	addcompany_id         *int
	electron_id           *int
	addelectron_id        *int
	cloud_file_id         *string
	sha512                *string
	install_cloud_file_id *string
	install_sha512        *string
	version_name          *string
	version_code          *int
	addversion_code       *int
	platform              *string
	arch                  *string
	description           *string
	is_del                *int32
	addis_del             *int32
	create_at             *time.Time
	update_at             *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*UpgradeElectronVersion, error)
	predicates            []predicate.UpgradeElectronVersion
}

var _ ent.Mutation = (*UpgradeElectronVersionMutation)(nil)

// upgradeelectronversionOption allows management of the mutation configuration using functional options.
type upgradeelectronversionOption func(*UpgradeElectronVersionMutation)

// newUpgradeElectronVersionMutation creates new mutation for the UpgradeElectronVersion entity.
func newUpgradeElectronVersionMutation(c config, op Op, opts ...upgradeelectronversionOption) *UpgradeElectronVersionMutation {
	m := &UpgradeElectronVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeElectronVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeElectronVersionID sets the ID field of the mutation.
func withUpgradeElectronVersionID(id int) upgradeelectronversionOption {
	return func(m *UpgradeElectronVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeElectronVersion
		)
		m.oldValue = func(ctx context.Context) (*UpgradeElectronVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeElectronVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeElectronVersion sets the old UpgradeElectronVersion of the mutation.
func withUpgradeElectronVersion(node *UpgradeElectronVersion) upgradeelectronversionOption {
	return func(m *UpgradeElectronVersionMutation) {
		m.oldValue = func(context.Context) (*UpgradeElectronVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeElectronVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeElectronVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeElectronVersion entities.
func (m *UpgradeElectronVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeElectronVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeElectronVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeElectronVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeElectronVersionMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeElectronVersionMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeElectronVersionMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeElectronVersionMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeElectronVersionMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetElectronID sets the "electron_id" field.
func (m *UpgradeElectronVersionMutation) SetElectronID(i int) {
	m.electron_id = &i
	m.addelectron_id = nil
}

// ElectronID returns the value of the "electron_id" field in the mutation.
func (m *UpgradeElectronVersionMutation) ElectronID() (r int, exists bool) {
	v := m.electron_id
	if v == nil {
		return
	}
	return *v, true
}

// OldElectronID returns the old "electron_id" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldElectronID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectronID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectronID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectronID: %w", err)
	}
	return oldValue.ElectronID, nil
}

// AddElectronID adds i to the "electron_id" field.
func (m *UpgradeElectronVersionMutation) AddElectronID(i int) {
	if m.addelectron_id != nil {
		*m.addelectron_id += i
	} else {
		m.addelectron_id = &i
	}
}

// AddedElectronID returns the value that was added to the "electron_id" field in this mutation.
func (m *UpgradeElectronVersionMutation) AddedElectronID() (r int, exists bool) {
	v := m.addelectron_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectronID resets all changes to the "electron_id" field.
func (m *UpgradeElectronVersionMutation) ResetElectronID() {
	m.electron_id = nil
	m.addelectron_id = nil
}

// SetCloudFileID sets the "cloud_file_id" field.
func (m *UpgradeElectronVersionMutation) SetCloudFileID(s string) {
	m.cloud_file_id = &s
}

// CloudFileID returns the value of the "cloud_file_id" field in the mutation.
func (m *UpgradeElectronVersionMutation) CloudFileID() (r string, exists bool) {
	v := m.cloud_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudFileID returns the old "cloud_file_id" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldCloudFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudFileID: %w", err)
	}
	return oldValue.CloudFileID, nil
}

// ResetCloudFileID resets all changes to the "cloud_file_id" field.
func (m *UpgradeElectronVersionMutation) ResetCloudFileID() {
	m.cloud_file_id = nil
}

// SetSha512 sets the "sha512" field.
func (m *UpgradeElectronVersionMutation) SetSha512(s string) {
	m.sha512 = &s
}

// Sha512 returns the value of the "sha512" field in the mutation.
func (m *UpgradeElectronVersionMutation) Sha512() (r string, exists bool) {
	v := m.sha512
	if v == nil {
		return
	}
	return *v, true
}

// OldSha512 returns the old "sha512" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldSha512(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha512 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha512 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha512: %w", err)
	}
	return oldValue.Sha512, nil
}

// ResetSha512 resets all changes to the "sha512" field.
func (m *UpgradeElectronVersionMutation) ResetSha512() {
	m.sha512 = nil
}

// SetInstallCloudFileID sets the "install_cloud_file_id" field.
func (m *UpgradeElectronVersionMutation) SetInstallCloudFileID(s string) {
	m.install_cloud_file_id = &s
}

// InstallCloudFileID returns the value of the "install_cloud_file_id" field in the mutation.
func (m *UpgradeElectronVersionMutation) InstallCloudFileID() (r string, exists bool) {
	v := m.install_cloud_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallCloudFileID returns the old "install_cloud_file_id" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldInstallCloudFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallCloudFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallCloudFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallCloudFileID: %w", err)
	}
	return oldValue.InstallCloudFileID, nil
}

// ResetInstallCloudFileID resets all changes to the "install_cloud_file_id" field.
func (m *UpgradeElectronVersionMutation) ResetInstallCloudFileID() {
	m.install_cloud_file_id = nil
}

// SetInstallSha512 sets the "install_sha512" field.
func (m *UpgradeElectronVersionMutation) SetInstallSha512(s string) {
	m.install_sha512 = &s
}

// InstallSha512 returns the value of the "install_sha512" field in the mutation.
func (m *UpgradeElectronVersionMutation) InstallSha512() (r string, exists bool) {
	v := m.install_sha512
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallSha512 returns the old "install_sha512" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldInstallSha512(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallSha512 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallSha512 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallSha512: %w", err)
	}
	return oldValue.InstallSha512, nil
}

// ResetInstallSha512 resets all changes to the "install_sha512" field.
func (m *UpgradeElectronVersionMutation) ResetInstallSha512() {
	m.install_sha512 = nil
}

// SetVersionName sets the "version_name" field.
func (m *UpgradeElectronVersionMutation) SetVersionName(s string) {
	m.version_name = &s
}

// VersionName returns the value of the "version_name" field in the mutation.
func (m *UpgradeElectronVersionMutation) VersionName() (r string, exists bool) {
	v := m.version_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionName returns the old "version_name" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldVersionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionName: %w", err)
	}
	return oldValue.VersionName, nil
}

// ResetVersionName resets all changes to the "version_name" field.
func (m *UpgradeElectronVersionMutation) ResetVersionName() {
	m.version_name = nil
}

// SetVersionCode sets the "version_code" field.
func (m *UpgradeElectronVersionMutation) SetVersionCode(i int) {
	m.version_code = &i
	m.addversion_code = nil
}

// VersionCode returns the value of the "version_code" field in the mutation.
func (m *UpgradeElectronVersionMutation) VersionCode() (r int, exists bool) {
	v := m.version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionCode returns the old "version_code" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldVersionCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionCode: %w", err)
	}
	return oldValue.VersionCode, nil
}

// AddVersionCode adds i to the "version_code" field.
func (m *UpgradeElectronVersionMutation) AddVersionCode(i int) {
	if m.addversion_code != nil {
		*m.addversion_code += i
	} else {
		m.addversion_code = &i
	}
}

// AddedVersionCode returns the value that was added to the "version_code" field in this mutation.
func (m *UpgradeElectronVersionMutation) AddedVersionCode() (r int, exists bool) {
	v := m.addversion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionCode resets all changes to the "version_code" field.
func (m *UpgradeElectronVersionMutation) ResetVersionCode() {
	m.version_code = nil
	m.addversion_code = nil
}

// SetPlatform sets the "platform" field.
func (m *UpgradeElectronVersionMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UpgradeElectronVersionMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UpgradeElectronVersionMutation) ResetPlatform() {
	m.platform = nil
}

// SetArch sets the "arch" field.
func (m *UpgradeElectronVersionMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *UpgradeElectronVersionMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *UpgradeElectronVersionMutation) ResetArch() {
	m.arch = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeElectronVersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeElectronVersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeElectronVersionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeelectronversion.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeElectronVersionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeelectronversion.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeElectronVersionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeelectronversion.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeElectronVersionMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeElectronVersionMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeElectronVersionMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeElectronVersionMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeElectronVersionMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeElectronVersionMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeElectronVersionMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeElectronVersionMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeelectronversion.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeElectronVersionMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronversion.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeElectronVersionMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeelectronversion.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeElectronVersionMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeElectronVersionMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeElectronVersion entity.
// If the UpgradeElectronVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeElectronVersionMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeElectronVersionMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeelectronversion.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeElectronVersionMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeelectronversion.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeElectronVersionMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeelectronversion.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeElectronVersionMutation builder.
func (m *UpgradeElectronVersionMutation) Where(ps ...predicate.UpgradeElectronVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeElectronVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeElectronVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeElectronVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeElectronVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeElectronVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeElectronVersion).
func (m *UpgradeElectronVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeElectronVersionMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.company_id != nil {
		fields = append(fields, upgradeelectronversion.FieldCompanyID)
	}
	if m.electron_id != nil {
		fields = append(fields, upgradeelectronversion.FieldElectronID)
	}
	if m.cloud_file_id != nil {
		fields = append(fields, upgradeelectronversion.FieldCloudFileID)
	}
	if m.sha512 != nil {
		fields = append(fields, upgradeelectronversion.FieldSha512)
	}
	if m.install_cloud_file_id != nil {
		fields = append(fields, upgradeelectronversion.FieldInstallCloudFileID)
	}
	if m.install_sha512 != nil {
		fields = append(fields, upgradeelectronversion.FieldInstallSha512)
	}
	if m.version_name != nil {
		fields = append(fields, upgradeelectronversion.FieldVersionName)
	}
	if m.version_code != nil {
		fields = append(fields, upgradeelectronversion.FieldVersionCode)
	}
	if m.platform != nil {
		fields = append(fields, upgradeelectronversion.FieldPlatform)
	}
	if m.arch != nil {
		fields = append(fields, upgradeelectronversion.FieldArch)
	}
	if m.description != nil {
		fields = append(fields, upgradeelectronversion.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeelectronversion.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeelectronversion.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeelectronversion.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeElectronVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronversion.FieldCompanyID:
		return m.CompanyID()
	case upgradeelectronversion.FieldElectronID:
		return m.ElectronID()
	case upgradeelectronversion.FieldCloudFileID:
		return m.CloudFileID()
	case upgradeelectronversion.FieldSha512:
		return m.Sha512()
	case upgradeelectronversion.FieldInstallCloudFileID:
		return m.InstallCloudFileID()
	case upgradeelectronversion.FieldInstallSha512:
		return m.InstallSha512()
	case upgradeelectronversion.FieldVersionName:
		return m.VersionName()
	case upgradeelectronversion.FieldVersionCode:
		return m.VersionCode()
	case upgradeelectronversion.FieldPlatform:
		return m.Platform()
	case upgradeelectronversion.FieldArch:
		return m.Arch()
	case upgradeelectronversion.FieldDescription:
		return m.Description()
	case upgradeelectronversion.FieldIsDel:
		return m.IsDel()
	case upgradeelectronversion.FieldCreateAt:
		return m.CreateAt()
	case upgradeelectronversion.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeElectronVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeelectronversion.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeelectronversion.FieldElectronID:
		return m.OldElectronID(ctx)
	case upgradeelectronversion.FieldCloudFileID:
		return m.OldCloudFileID(ctx)
	case upgradeelectronversion.FieldSha512:
		return m.OldSha512(ctx)
	case upgradeelectronversion.FieldInstallCloudFileID:
		return m.OldInstallCloudFileID(ctx)
	case upgradeelectronversion.FieldInstallSha512:
		return m.OldInstallSha512(ctx)
	case upgradeelectronversion.FieldVersionName:
		return m.OldVersionName(ctx)
	case upgradeelectronversion.FieldVersionCode:
		return m.OldVersionCode(ctx)
	case upgradeelectronversion.FieldPlatform:
		return m.OldPlatform(ctx)
	case upgradeelectronversion.FieldArch:
		return m.OldArch(ctx)
	case upgradeelectronversion.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeelectronversion.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeelectronversion.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeelectronversion.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeElectronVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeelectronversion.FieldElectronID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectronID(v)
		return nil
	case upgradeelectronversion.FieldCloudFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudFileID(v)
		return nil
	case upgradeelectronversion.FieldSha512:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha512(v)
		return nil
	case upgradeelectronversion.FieldInstallCloudFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallCloudFileID(v)
		return nil
	case upgradeelectronversion.FieldInstallSha512:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallSha512(v)
		return nil
	case upgradeelectronversion.FieldVersionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionName(v)
		return nil
	case upgradeelectronversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionCode(v)
		return nil
	case upgradeelectronversion.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case upgradeelectronversion.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case upgradeelectronversion.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeelectronversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeelectronversion.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeelectronversion.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeElectronVersionMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeelectronversion.FieldCompanyID)
	}
	if m.addelectron_id != nil {
		fields = append(fields, upgradeelectronversion.FieldElectronID)
	}
	if m.addversion_code != nil {
		fields = append(fields, upgradeelectronversion.FieldVersionCode)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeelectronversion.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeElectronVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeelectronversion.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeelectronversion.FieldElectronID:
		return m.AddedElectronID()
	case upgradeelectronversion.FieldVersionCode:
		return m.AddedVersionCode()
	case upgradeelectronversion.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeElectronVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeelectronversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeelectronversion.FieldElectronID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectronID(v)
		return nil
	case upgradeelectronversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionCode(v)
		return nil
	case upgradeelectronversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeElectronVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeelectronversion.FieldDescription) {
		fields = append(fields, upgradeelectronversion.FieldDescription)
	}
	if m.FieldCleared(upgradeelectronversion.FieldCreateAt) {
		fields = append(fields, upgradeelectronversion.FieldCreateAt)
	}
	if m.FieldCleared(upgradeelectronversion.FieldUpdateAt) {
		fields = append(fields, upgradeelectronversion.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeElectronVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeElectronVersionMutation) ClearField(name string) error {
	switch name {
	case upgradeelectronversion.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeelectronversion.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeelectronversion.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeElectronVersionMutation) ResetField(name string) error {
	switch name {
	case upgradeelectronversion.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeelectronversion.FieldElectronID:
		m.ResetElectronID()
		return nil
	case upgradeelectronversion.FieldCloudFileID:
		m.ResetCloudFileID()
		return nil
	case upgradeelectronversion.FieldSha512:
		m.ResetSha512()
		return nil
	case upgradeelectronversion.FieldInstallCloudFileID:
		m.ResetInstallCloudFileID()
		return nil
	case upgradeelectronversion.FieldInstallSha512:
		m.ResetInstallSha512()
		return nil
	case upgradeelectronversion.FieldVersionName:
		m.ResetVersionName()
		return nil
	case upgradeelectronversion.FieldVersionCode:
		m.ResetVersionCode()
		return nil
	case upgradeelectronversion.FieldPlatform:
		m.ResetPlatform()
		return nil
	case upgradeelectronversion.FieldArch:
		m.ResetArch()
		return nil
	case upgradeelectronversion.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeelectronversion.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeelectronversion.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeelectronversion.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeElectronVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeElectronVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeElectronVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeElectronVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeElectronVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeElectronVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeElectronVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeElectronVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeElectronVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeElectronVersion edge %s", name)
}

// UpgradeFileMutation represents an operation that mutates the UpgradeFile nodes in the graph.
type UpgradeFileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	name          *string
	description   *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeFile, error)
	predicates    []predicate.UpgradeFile
}

var _ ent.Mutation = (*UpgradeFileMutation)(nil)

// upgradefileOption allows management of the mutation configuration using functional options.
type upgradefileOption func(*UpgradeFileMutation)

// newUpgradeFileMutation creates new mutation for the UpgradeFile entity.
func newUpgradeFileMutation(c config, op Op, opts ...upgradefileOption) *UpgradeFileMutation {
	m := &UpgradeFileMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeFileID sets the ID field of the mutation.
func withUpgradeFileID(id int) upgradefileOption {
	return func(m *UpgradeFileMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeFile
		)
		m.oldValue = func(ctx context.Context) (*UpgradeFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeFile sets the old UpgradeFile of the mutation.
func withUpgradeFile(node *UpgradeFile) upgradefileOption {
	return func(m *UpgradeFileMutation) {
		m.oldValue = func(context.Context) (*UpgradeFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeFile entities.
func (m *UpgradeFileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeFileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeFileMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeFileMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeFile entity.
// If the UpgradeFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeFileMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeFileMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeFileMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeFileMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeFileMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeFile entity.
// If the UpgradeFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeFileMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UpgradeFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeFile entity.
// If the UpgradeFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeFileMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeFileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeFileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeFile entity.
// If the UpgradeFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeFileMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradefile.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeFileMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradefile.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeFileMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradefile.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeFileMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeFileMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeFile entity.
// If the UpgradeFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeFileMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeFileMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeFileMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeFileMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeFileMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeFile entity.
// If the UpgradeFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeFileMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradefile.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeFileMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradefile.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeFileMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradefile.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeFileMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeFileMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeFile entity.
// If the UpgradeFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeFileMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradefile.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeFileMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradefile.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeFileMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradefile.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeFileMutation builder.
func (m *UpgradeFileMutation) Where(ps ...predicate.UpgradeFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeFile).
func (m *UpgradeFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeFileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.company_id != nil {
		fields = append(fields, upgradefile.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradefile.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, upgradefile.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradefile.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradefile.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradefile.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradefile.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradefile.FieldCompanyID:
		return m.CompanyID()
	case upgradefile.FieldKey:
		return m.Key()
	case upgradefile.FieldName:
		return m.Name()
	case upgradefile.FieldDescription:
		return m.Description()
	case upgradefile.FieldIsDel:
		return m.IsDel()
	case upgradefile.FieldCreateAt:
		return m.CreateAt()
	case upgradefile.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradefile.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradefile.FieldKey:
		return m.OldKey(ctx)
	case upgradefile.FieldName:
		return m.OldName(ctx)
	case upgradefile.FieldDescription:
		return m.OldDescription(ctx)
	case upgradefile.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradefile.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradefile.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradefile.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradefile.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradefile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradefile.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradefile.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradefile.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradefile.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeFileMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradefile.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradefile.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradefile.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradefile.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradefile.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradefile.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradefile.FieldDescription) {
		fields = append(fields, upgradefile.FieldDescription)
	}
	if m.FieldCleared(upgradefile.FieldCreateAt) {
		fields = append(fields, upgradefile.FieldCreateAt)
	}
	if m.FieldCleared(upgradefile.FieldUpdateAt) {
		fields = append(fields, upgradefile.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeFileMutation) ClearField(name string) error {
	switch name {
	case upgradefile.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradefile.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradefile.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeFileMutation) ResetField(name string) error {
	switch name {
	case upgradefile.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradefile.FieldKey:
		m.ResetKey()
		return nil
	case upgradefile.FieldName:
		m.ResetName()
		return nil
	case upgradefile.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradefile.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradefile.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradefile.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeFileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeFileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeFileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeFileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFile edge %s", name)
}

// UpgradeFileUpgradeStrategyMutation represents an operation that mutates the UpgradeFileUpgradeStrategy nodes in the graph.
type UpgradeFileUpgradeStrategyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	company_id              *int
	addcompany_id           *int
	enable                  *int32
	addenable               *int32
	name                    *string
	description             *string
	file_id                 *int
	addfile_id              *int
	file_version_id         *int
	addfile_version_id      *int
	begin_datetime          *time.Time
	end_datetime            *time.Time
	upgrade_type            *int32
	addupgrade_type         *int32
	prompt_upgrade_content  *string
	upgrade_dev_type        *int32
	addupgrade_dev_type     *int32
	upgrade_dev_data        *string
	upgrade_version_type    *int32
	addupgrade_version_type *int32
	upgrade_version_data    *string
	is_gray                 *int32
	addis_gray              *int32
	gray_data               *string
	is_flow_limit           *int32
	addis_flow_limit        *int32
	flow_limit_data         *string
	is_del                  *int32
	addis_del               *int32
	create_at               *time.Time
	update_at               *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*UpgradeFileUpgradeStrategy, error)
	predicates              []predicate.UpgradeFileUpgradeStrategy
}

var _ ent.Mutation = (*UpgradeFileUpgradeStrategyMutation)(nil)

// upgradefileupgradestrategyOption allows management of the mutation configuration using functional options.
type upgradefileupgradestrategyOption func(*UpgradeFileUpgradeStrategyMutation)

// newUpgradeFileUpgradeStrategyMutation creates new mutation for the UpgradeFileUpgradeStrategy entity.
func newUpgradeFileUpgradeStrategyMutation(c config, op Op, opts ...upgradefileupgradestrategyOption) *UpgradeFileUpgradeStrategyMutation {
	m := &UpgradeFileUpgradeStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeFileUpgradeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeFileUpgradeStrategyID sets the ID field of the mutation.
func withUpgradeFileUpgradeStrategyID(id int) upgradefileupgradestrategyOption {
	return func(m *UpgradeFileUpgradeStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeFileUpgradeStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeFileUpgradeStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeFileUpgradeStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeFileUpgradeStrategy sets the old UpgradeFileUpgradeStrategy of the mutation.
func withUpgradeFileUpgradeStrategy(node *UpgradeFileUpgradeStrategy) upgradefileupgradestrategyOption {
	return func(m *UpgradeFileUpgradeStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeFileUpgradeStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeFileUpgradeStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeFileUpgradeStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeFileUpgradeStrategy entities.
func (m *UpgradeFileUpgradeStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeFileUpgradeStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeFileUpgradeStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetEnable sets the "enable" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetName sets the "name" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeFileUpgradeStrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradefileupgradestrategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradefileupgradestrategy.FieldDescription)
}

// SetFileID sets the "file_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetFileID(i int) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) FileID() (r int, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddFileID(i int) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedFileID() (r int, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetFileVersionID sets the "file_version_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetFileVersionID(i int) {
	m.file_version_id = &i
	m.addfile_version_id = nil
}

// FileVersionID returns the value of the "file_version_id" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) FileVersionID() (r int, exists bool) {
	v := m.file_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileVersionID returns the old "file_version_id" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldFileVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileVersionID: %w", err)
	}
	return oldValue.FileVersionID, nil
}

// AddFileVersionID adds i to the "file_version_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddFileVersionID(i int) {
	if m.addfile_version_id != nil {
		*m.addfile_version_id += i
	} else {
		m.addfile_version_id = &i
	}
}

// AddedFileVersionID returns the value that was added to the "file_version_id" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedFileVersionID() (r int, exists bool) {
	v := m.addfile_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileVersionID resets all changes to the "file_version_id" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetFileVersionID() {
	m.file_version_id = nil
	m.addfile_version_id = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetUpgradeType sets the "upgrade_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetUpgradeType(i int32) {
	m.upgrade_type = &i
	m.addupgrade_type = nil
}

// UpgradeType returns the value of the "upgrade_type" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) UpgradeType() (r int32, exists bool) {
	v := m.upgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeType returns the old "upgrade_type" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldUpgradeType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeType: %w", err)
	}
	return oldValue.UpgradeType, nil
}

// AddUpgradeType adds i to the "upgrade_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddUpgradeType(i int32) {
	if m.addupgrade_type != nil {
		*m.addupgrade_type += i
	} else {
		m.addupgrade_type = &i
	}
}

// AddedUpgradeType returns the value that was added to the "upgrade_type" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedUpgradeType() (r int32, exists bool) {
	v := m.addupgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeType resets all changes to the "upgrade_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetUpgradeType() {
	m.upgrade_type = nil
	m.addupgrade_type = nil
}

// SetPromptUpgradeContent sets the "prompt_upgrade_content" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetPromptUpgradeContent(s string) {
	m.prompt_upgrade_content = &s
}

// PromptUpgradeContent returns the value of the "prompt_upgrade_content" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) PromptUpgradeContent() (r string, exists bool) {
	v := m.prompt_upgrade_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptUpgradeContent returns the old "prompt_upgrade_content" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldPromptUpgradeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptUpgradeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptUpgradeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptUpgradeContent: %w", err)
	}
	return oldValue.PromptUpgradeContent, nil
}

// ClearPromptUpgradeContent clears the value of the "prompt_upgrade_content" field.
func (m *UpgradeFileUpgradeStrategyMutation) ClearPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	m.clearedFields[upgradefileupgradestrategy.FieldPromptUpgradeContent] = struct{}{}
}

// PromptUpgradeContentCleared returns if the "prompt_upgrade_content" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) PromptUpgradeContentCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategy.FieldPromptUpgradeContent]
	return ok
}

// ResetPromptUpgradeContent resets all changes to the "prompt_upgrade_content" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	delete(m.clearedFields, upgradefileupgradestrategy.FieldPromptUpgradeContent)
}

// SetUpgradeDevType sets the "upgrade_dev_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetUpgradeDevType(i int32) {
	m.upgrade_dev_type = &i
	m.addupgrade_dev_type = nil
}

// UpgradeDevType returns the value of the "upgrade_dev_type" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) UpgradeDevType() (r int32, exists bool) {
	v := m.upgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevType returns the old "upgrade_dev_type" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldUpgradeDevType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevType: %w", err)
	}
	return oldValue.UpgradeDevType, nil
}

// AddUpgradeDevType adds i to the "upgrade_dev_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddUpgradeDevType(i int32) {
	if m.addupgrade_dev_type != nil {
		*m.addupgrade_dev_type += i
	} else {
		m.addupgrade_dev_type = &i
	}
}

// AddedUpgradeDevType returns the value that was added to the "upgrade_dev_type" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedUpgradeDevType() (r int32, exists bool) {
	v := m.addupgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeDevType resets all changes to the "upgrade_dev_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetUpgradeDevType() {
	m.upgrade_dev_type = nil
	m.addupgrade_dev_type = nil
}

// SetUpgradeDevData sets the "upgrade_dev_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetUpgradeDevData(s string) {
	m.upgrade_dev_data = &s
}

// UpgradeDevData returns the value of the "upgrade_dev_data" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) UpgradeDevData() (r string, exists bool) {
	v := m.upgrade_dev_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevData returns the old "upgrade_dev_data" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldUpgradeDevData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevData: %w", err)
	}
	return oldValue.UpgradeDevData, nil
}

// ResetUpgradeDevData resets all changes to the "upgrade_dev_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetUpgradeDevData() {
	m.upgrade_dev_data = nil
}

// SetUpgradeVersionType sets the "upgrade_version_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetUpgradeVersionType(i int32) {
	m.upgrade_version_type = &i
	m.addupgrade_version_type = nil
}

// UpgradeVersionType returns the value of the "upgrade_version_type" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) UpgradeVersionType() (r int32, exists bool) {
	v := m.upgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionType returns the old "upgrade_version_type" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldUpgradeVersionType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionType: %w", err)
	}
	return oldValue.UpgradeVersionType, nil
}

// AddUpgradeVersionType adds i to the "upgrade_version_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddUpgradeVersionType(i int32) {
	if m.addupgrade_version_type != nil {
		*m.addupgrade_version_type += i
	} else {
		m.addupgrade_version_type = &i
	}
}

// AddedUpgradeVersionType returns the value that was added to the "upgrade_version_type" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedUpgradeVersionType() (r int32, exists bool) {
	v := m.addupgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeVersionType resets all changes to the "upgrade_version_type" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetUpgradeVersionType() {
	m.upgrade_version_type = nil
	m.addupgrade_version_type = nil
}

// SetUpgradeVersionData sets the "upgrade_version_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetUpgradeVersionData(s string) {
	m.upgrade_version_data = &s
}

// UpgradeVersionData returns the value of the "upgrade_version_data" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) UpgradeVersionData() (r string, exists bool) {
	v := m.upgrade_version_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionData returns the old "upgrade_version_data" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldUpgradeVersionData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionData: %w", err)
	}
	return oldValue.UpgradeVersionData, nil
}

// ResetUpgradeVersionData resets all changes to the "upgrade_version_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetUpgradeVersionData() {
	m.upgrade_version_data = nil
}

// SetIsGray sets the "is_gray" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetIsGray(i int32) {
	m.is_gray = &i
	m.addis_gray = nil
}

// IsGray returns the value of the "is_gray" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) IsGray() (r int32, exists bool) {
	v := m.is_gray
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGray returns the old "is_gray" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldIsGray(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGray: %w", err)
	}
	return oldValue.IsGray, nil
}

// AddIsGray adds i to the "is_gray" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddIsGray(i int32) {
	if m.addis_gray != nil {
		*m.addis_gray += i
	} else {
		m.addis_gray = &i
	}
}

// AddedIsGray returns the value that was added to the "is_gray" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedIsGray() (r int32, exists bool) {
	v := m.addis_gray
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsGray resets all changes to the "is_gray" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetIsGray() {
	m.is_gray = nil
	m.addis_gray = nil
}

// SetGrayData sets the "gray_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetGrayData(s string) {
	m.gray_data = &s
}

// GrayData returns the value of the "gray_data" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) GrayData() (r string, exists bool) {
	v := m.gray_data
	if v == nil {
		return
	}
	return *v, true
}

// OldGrayData returns the old "gray_data" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldGrayData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrayData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrayData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrayData: %w", err)
	}
	return oldValue.GrayData, nil
}

// ResetGrayData resets all changes to the "gray_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetGrayData() {
	m.gray_data = nil
}

// SetIsFlowLimit sets the "is_flow_limit" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetIsFlowLimit(i int32) {
	m.is_flow_limit = &i
	m.addis_flow_limit = nil
}

// IsFlowLimit returns the value of the "is_flow_limit" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) IsFlowLimit() (r int32, exists bool) {
	v := m.is_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlowLimit returns the old "is_flow_limit" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldIsFlowLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlowLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlowLimit: %w", err)
	}
	return oldValue.IsFlowLimit, nil
}

// AddIsFlowLimit adds i to the "is_flow_limit" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddIsFlowLimit(i int32) {
	if m.addis_flow_limit != nil {
		*m.addis_flow_limit += i
	} else {
		m.addis_flow_limit = &i
	}
}

// AddedIsFlowLimit returns the value that was added to the "is_flow_limit" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedIsFlowLimit() (r int32, exists bool) {
	v := m.addis_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFlowLimit resets all changes to the "is_flow_limit" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetIsFlowLimit() {
	m.is_flow_limit = nil
	m.addis_flow_limit = nil
}

// SetFlowLimitData sets the "flow_limit_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetFlowLimitData(s string) {
	m.flow_limit_data = &s
}

// FlowLimitData returns the value of the "flow_limit_data" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) FlowLimitData() (r string, exists bool) {
	v := m.flow_limit_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowLimitData returns the old "flow_limit_data" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldFlowLimitData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowLimitData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowLimitData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowLimitData: %w", err)
	}
	return oldValue.FlowLimitData, nil
}

// ResetFlowLimitData resets all changes to the "flow_limit_data" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetFlowLimitData() {
	m.flow_limit_data = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeFileUpgradeStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeFileUpgradeStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradefileupgradestrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradefileupgradestrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeFileUpgradeStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeFileUpgradeStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeFileUpgradeStrategy entity.
// If the UpgradeFileUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeFileUpgradeStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradefileupgradestrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeFileUpgradeStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradefileupgradestrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeFileUpgradeStrategyMutation builder.
func (m *UpgradeFileUpgradeStrategyMutation) Where(ps ...predicate.UpgradeFileUpgradeStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeFileUpgradeStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeFileUpgradeStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeFileUpgradeStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeFileUpgradeStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeFileUpgradeStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeFileUpgradeStrategy).
func (m *UpgradeFileUpgradeStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeFileUpgradeStrategyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.company_id != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldCompanyID)
	}
	if m.enable != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldDescription)
	}
	if m.file_id != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldFileID)
	}
	if m.file_version_id != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldFileVersionID)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldEndDatetime)
	}
	if m.upgrade_type != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeType)
	}
	if m.prompt_upgrade_content != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.upgrade_dev_type != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeDevType)
	}
	if m.upgrade_dev_data != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeDevData)
	}
	if m.upgrade_version_type != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeVersionType)
	}
	if m.upgrade_version_data != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeVersionData)
	}
	if m.is_gray != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldIsGray)
	}
	if m.gray_data != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldGrayData)
	}
	if m.is_flow_limit != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldIsFlowLimit)
	}
	if m.flow_limit_data != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldFlowLimitData)
	}
	if m.is_del != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeFileUpgradeStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradefileupgradestrategy.FieldCompanyID:
		return m.CompanyID()
	case upgradefileupgradestrategy.FieldEnable:
		return m.Enable()
	case upgradefileupgradestrategy.FieldName:
		return m.Name()
	case upgradefileupgradestrategy.FieldDescription:
		return m.Description()
	case upgradefileupgradestrategy.FieldFileID:
		return m.FileID()
	case upgradefileupgradestrategy.FieldFileVersionID:
		return m.FileVersionID()
	case upgradefileupgradestrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradefileupgradestrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradefileupgradestrategy.FieldUpgradeType:
		return m.UpgradeType()
	case upgradefileupgradestrategy.FieldPromptUpgradeContent:
		return m.PromptUpgradeContent()
	case upgradefileupgradestrategy.FieldUpgradeDevType:
		return m.UpgradeDevType()
	case upgradefileupgradestrategy.FieldUpgradeDevData:
		return m.UpgradeDevData()
	case upgradefileupgradestrategy.FieldUpgradeVersionType:
		return m.UpgradeVersionType()
	case upgradefileupgradestrategy.FieldUpgradeVersionData:
		return m.UpgradeVersionData()
	case upgradefileupgradestrategy.FieldIsGray:
		return m.IsGray()
	case upgradefileupgradestrategy.FieldGrayData:
		return m.GrayData()
	case upgradefileupgradestrategy.FieldIsFlowLimit:
		return m.IsFlowLimit()
	case upgradefileupgradestrategy.FieldFlowLimitData:
		return m.FlowLimitData()
	case upgradefileupgradestrategy.FieldIsDel:
		return m.IsDel()
	case upgradefileupgradestrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradefileupgradestrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeFileUpgradeStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradefileupgradestrategy.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradefileupgradestrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradefileupgradestrategy.FieldName:
		return m.OldName(ctx)
	case upgradefileupgradestrategy.FieldDescription:
		return m.OldDescription(ctx)
	case upgradefileupgradestrategy.FieldFileID:
		return m.OldFileID(ctx)
	case upgradefileupgradestrategy.FieldFileVersionID:
		return m.OldFileVersionID(ctx)
	case upgradefileupgradestrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradefileupgradestrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradefileupgradestrategy.FieldUpgradeType:
		return m.OldUpgradeType(ctx)
	case upgradefileupgradestrategy.FieldPromptUpgradeContent:
		return m.OldPromptUpgradeContent(ctx)
	case upgradefileupgradestrategy.FieldUpgradeDevType:
		return m.OldUpgradeDevType(ctx)
	case upgradefileupgradestrategy.FieldUpgradeDevData:
		return m.OldUpgradeDevData(ctx)
	case upgradefileupgradestrategy.FieldUpgradeVersionType:
		return m.OldUpgradeVersionType(ctx)
	case upgradefileupgradestrategy.FieldUpgradeVersionData:
		return m.OldUpgradeVersionData(ctx)
	case upgradefileupgradestrategy.FieldIsGray:
		return m.OldIsGray(ctx)
	case upgradefileupgradestrategy.FieldGrayData:
		return m.OldGrayData(ctx)
	case upgradefileupgradestrategy.FieldIsFlowLimit:
		return m.OldIsFlowLimit(ctx)
	case upgradefileupgradestrategy.FieldFlowLimitData:
		return m.OldFlowLimitData(ctx)
	case upgradefileupgradestrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradefileupgradestrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradefileupgradestrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeFileUpgradeStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileUpgradeStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradefileupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradefileupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradefileupgradestrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradefileupgradestrategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradefileupgradestrategy.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case upgradefileupgradestrategy.FieldFileVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileVersionID(v)
		return nil
	case upgradefileupgradestrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradefileupgradestrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeType(v)
		return nil
	case upgradefileupgradestrategy.FieldPromptUpgradeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptUpgradeContent(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevType(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeDevData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevData(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionType(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeVersionData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionData(v)
		return nil
	case upgradefileupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGray(v)
		return nil
	case upgradefileupgradestrategy.FieldGrayData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrayData(v)
		return nil
	case upgradefileupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlowLimit(v)
		return nil
	case upgradefileupgradestrategy.FieldFlowLimitData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowLimitData(v)
		return nil
	case upgradefileupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradefileupgradestrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradefileupgradestrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldCompanyID)
	}
	if m.addenable != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldEnable)
	}
	if m.addfile_id != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldFileID)
	}
	if m.addfile_version_id != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldFileVersionID)
	}
	if m.addupgrade_type != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeType)
	}
	if m.addupgrade_dev_type != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeDevType)
	}
	if m.addupgrade_version_type != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldUpgradeVersionType)
	}
	if m.addis_gray != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldIsGray)
	}
	if m.addis_flow_limit != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldIsFlowLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradefileupgradestrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeFileUpgradeStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradefileupgradestrategy.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradefileupgradestrategy.FieldEnable:
		return m.AddedEnable()
	case upgradefileupgradestrategy.FieldFileID:
		return m.AddedFileID()
	case upgradefileupgradestrategy.FieldFileVersionID:
		return m.AddedFileVersionID()
	case upgradefileupgradestrategy.FieldUpgradeType:
		return m.AddedUpgradeType()
	case upgradefileupgradestrategy.FieldUpgradeDevType:
		return m.AddedUpgradeDevType()
	case upgradefileupgradestrategy.FieldUpgradeVersionType:
		return m.AddedUpgradeVersionType()
	case upgradefileupgradestrategy.FieldIsGray:
		return m.AddedIsGray()
	case upgradefileupgradestrategy.FieldIsFlowLimit:
		return m.AddedIsFlowLimit()
	case upgradefileupgradestrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileUpgradeStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradefileupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradefileupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradefileupgradestrategy.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	case upgradefileupgradestrategy.FieldFileVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileVersionID(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeType(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeDevType(v)
		return nil
	case upgradefileupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeVersionType(v)
		return nil
	case upgradefileupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsGray(v)
		return nil
	case upgradefileupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFlowLimit(v)
		return nil
	case upgradefileupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeFileUpgradeStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradefileupgradestrategy.FieldDescription) {
		fields = append(fields, upgradefileupgradestrategy.FieldDescription)
	}
	if m.FieldCleared(upgradefileupgradestrategy.FieldPromptUpgradeContent) {
		fields = append(fields, upgradefileupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.FieldCleared(upgradefileupgradestrategy.FieldCreateAt) {
		fields = append(fields, upgradefileupgradestrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradefileupgradestrategy.FieldUpdateAt) {
		fields = append(fields, upgradefileupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradefileupgradestrategy.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradefileupgradestrategy.FieldPromptUpgradeContent:
		m.ClearPromptUpgradeContent()
		return nil
	case upgradefileupgradestrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradefileupgradestrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradefileupgradestrategy.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradefileupgradestrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradefileupgradestrategy.FieldName:
		m.ResetName()
		return nil
	case upgradefileupgradestrategy.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradefileupgradestrategy.FieldFileID:
		m.ResetFileID()
		return nil
	case upgradefileupgradestrategy.FieldFileVersionID:
		m.ResetFileVersionID()
		return nil
	case upgradefileupgradestrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradefileupgradestrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradefileupgradestrategy.FieldUpgradeType:
		m.ResetUpgradeType()
		return nil
	case upgradefileupgradestrategy.FieldPromptUpgradeContent:
		m.ResetPromptUpgradeContent()
		return nil
	case upgradefileupgradestrategy.FieldUpgradeDevType:
		m.ResetUpgradeDevType()
		return nil
	case upgradefileupgradestrategy.FieldUpgradeDevData:
		m.ResetUpgradeDevData()
		return nil
	case upgradefileupgradestrategy.FieldUpgradeVersionType:
		m.ResetUpgradeVersionType()
		return nil
	case upgradefileupgradestrategy.FieldUpgradeVersionData:
		m.ResetUpgradeVersionData()
		return nil
	case upgradefileupgradestrategy.FieldIsGray:
		m.ResetIsGray()
		return nil
	case upgradefileupgradestrategy.FieldGrayData:
		m.ResetGrayData()
		return nil
	case upgradefileupgradestrategy.FieldIsFlowLimit:
		m.ResetIsFlowLimit()
		return nil
	case upgradefileupgradestrategy.FieldFlowLimitData:
		m.ResetFlowLimitData()
		return nil
	case upgradefileupgradestrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradefileupgradestrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradefileupgradestrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategy edge %s", name)
}

// UpgradeFileUpgradeStrategyFlowLimitStrategyMutation represents an operation that mutates the UpgradeFileUpgradeStrategyFlowLimitStrategy nodes in the graph.
type UpgradeFileUpgradeStrategyFlowLimitStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	enable        *int32
	addenable     *int32
	begin_time    *string
	end_time      *string
	dimension     *int32
	adddimension  *int32
	_limit        *int
	add_limit     *int
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeFileUpgradeStrategyFlowLimitStrategy, error)
	predicates    []predicate.UpgradeFileUpgradeStrategyFlowLimitStrategy
}

var _ ent.Mutation = (*UpgradeFileUpgradeStrategyFlowLimitStrategyMutation)(nil)

// upgradefileupgradestrategyflowlimitstrategyOption allows management of the mutation configuration using functional options.
type upgradefileupgradestrategyflowlimitstrategyOption func(*UpgradeFileUpgradeStrategyFlowLimitStrategyMutation)

// newUpgradeFileUpgradeStrategyFlowLimitStrategyMutation creates new mutation for the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
func newUpgradeFileUpgradeStrategyFlowLimitStrategyMutation(c config, op Op, opts ...upgradefileupgradestrategyflowlimitstrategyOption) *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation {
	m := &UpgradeFileUpgradeStrategyFlowLimitStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeFileUpgradeStrategyFlowLimitStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeFileUpgradeStrategyFlowLimitStrategyID sets the ID field of the mutation.
func withUpgradeFileUpgradeStrategyFlowLimitStrategyID(id int) upgradefileupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeFileUpgradeStrategyFlowLimitStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeFileUpgradeStrategyFlowLimitStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeFileUpgradeStrategyFlowLimitStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeFileUpgradeStrategyFlowLimitStrategy sets the old UpgradeFileUpgradeStrategyFlowLimitStrategy of the mutation.
func withUpgradeFileUpgradeStrategyFlowLimitStrategy(node *UpgradeFileUpgradeStrategyFlowLimitStrategy) upgradefileupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeFileUpgradeStrategyFlowLimitStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeFileUpgradeStrategyFlowLimitStrategy entities.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeFileUpgradeStrategyFlowLimitStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginTime sets the "begin_time" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetBeginTime(s string) {
	m.begin_time = &s
}

// BeginTime returns the value of the "begin_time" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) BeginTime() (r string, exists bool) {
	v := m.begin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "begin_time" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldBeginTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "begin_time" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetBeginTime() {
	m.begin_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDimension sets the "dimension" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetDimension(i int32) {
	m.dimension = &i
	m.adddimension = nil
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Dimension() (r int32, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldDimension(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// AddDimension adds i to the "dimension" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddDimension(i int32) {
	if m.adddimension != nil {
		*m.adddimension += i
	} else {
		m.adddimension = &i
	}
}

// AddedDimension returns the value that was added to the "dimension" field in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedDimension() (r int32, exists bool) {
	v := m.adddimension
	if v == nil {
		return
	}
	return *v, true
}

// ResetDimension resets all changes to the "dimension" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetDimension() {
	m.dimension = nil
	m.adddimension = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeFileUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeFileUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeFileUpgradeStrategyFlowLimitStrategyMutation builder.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Where(ps ...predicate.UpgradeFileUpgradeStrategyFlowLimitStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeFileUpgradeStrategyFlowLimitStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeFileUpgradeStrategyFlowLimitStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeFileUpgradeStrategyFlowLimitStrategy).
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.enable != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.begin_time != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldBeginTime)
	}
	if m.end_time != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldEndTime)
	}
	if m.dimension != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m._limit != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradefileupgradestrategyflowlimitstrategy.FieldEnable:
		return m.Enable()
	case upgradefileupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.BeginTime()
	case upgradefileupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.EndTime()
	case upgradefileupgradestrategyflowlimitstrategy.FieldDimension:
		return m.Dimension()
	case upgradefileupgradestrategyflowlimitstrategy.FieldLimit:
		return m.Limit()
	case upgradefileupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.IsDel()
	case upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradefileupgradestrategyflowlimitstrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradefileupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case upgradefileupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.OldEndTime(ctx)
	case upgradefileupgradestrategyflowlimitstrategy.FieldDimension:
		return m.OldDimension(ctx)
	case upgradefileupgradestrategyflowlimitstrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradefileupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeFileUpgradeStrategyFlowLimitStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradefileupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldBeginTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.adddimension != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradefileupgradestrategyflowlimitstrategy.FieldEnable:
		return m.AddedEnable()
	case upgradefileupgradestrategyflowlimitstrategy.FieldDimension:
		return m.AddedDimension()
	case upgradefileupgradestrategyflowlimitstrategy.FieldLimit:
		return m.AddedLimit()
	case upgradefileupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradefileupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimension(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyFlowLimitStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt) {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt) {
		fields = append(fields, upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyFlowLimitStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradefileupgradestrategyflowlimitstrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldEndTime:
		m.ResetEndTime()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldDimension:
		m.ResetDimension()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradefileupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyFlowLimitStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyFlowLimitStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyFlowLimitStrategy edge %s", name)
}

// UpgradeFileUpgradeStrategyGrayStrategyMutation represents an operation that mutates the UpgradeFileUpgradeStrategyGrayStrategy nodes in the graph.
type UpgradeFileUpgradeStrategyGrayStrategyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	enable         *int32
	addenable      *int32
	begin_datetime *time.Time
	end_datetime   *time.Time
	_limit         *int
	add_limit      *int
	is_del         *int32
	addis_del      *int32
	create_at      *time.Time
	update_at      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UpgradeFileUpgradeStrategyGrayStrategy, error)
	predicates     []predicate.UpgradeFileUpgradeStrategyGrayStrategy
}

var _ ent.Mutation = (*UpgradeFileUpgradeStrategyGrayStrategyMutation)(nil)

// upgradefileupgradestrategygraystrategyOption allows management of the mutation configuration using functional options.
type upgradefileupgradestrategygraystrategyOption func(*UpgradeFileUpgradeStrategyGrayStrategyMutation)

// newUpgradeFileUpgradeStrategyGrayStrategyMutation creates new mutation for the UpgradeFileUpgradeStrategyGrayStrategy entity.
func newUpgradeFileUpgradeStrategyGrayStrategyMutation(c config, op Op, opts ...upgradefileupgradestrategygraystrategyOption) *UpgradeFileUpgradeStrategyGrayStrategyMutation {
	m := &UpgradeFileUpgradeStrategyGrayStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeFileUpgradeStrategyGrayStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeFileUpgradeStrategyGrayStrategyID sets the ID field of the mutation.
func withUpgradeFileUpgradeStrategyGrayStrategyID(id int) upgradefileupgradestrategygraystrategyOption {
	return func(m *UpgradeFileUpgradeStrategyGrayStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeFileUpgradeStrategyGrayStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeFileUpgradeStrategyGrayStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeFileUpgradeStrategyGrayStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeFileUpgradeStrategyGrayStrategy sets the old UpgradeFileUpgradeStrategyGrayStrategy of the mutation.
func withUpgradeFileUpgradeStrategyGrayStrategy(node *UpgradeFileUpgradeStrategyGrayStrategy) upgradefileupgradestrategygraystrategyOption {
	return func(m *UpgradeFileUpgradeStrategyGrayStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeFileUpgradeStrategyGrayStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeFileUpgradeStrategyGrayStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeFileUpgradeStrategyGrayStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeFileUpgradeStrategyGrayStrategy entities.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeFileUpgradeStrategyGrayStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeFileUpgradeStrategyGrayStrategy entity.
// If the UpgradeFileUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeFileUpgradeStrategyGrayStrategy entity.
// If the UpgradeFileUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeFileUpgradeStrategyGrayStrategy entity.
// If the UpgradeFileUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeFileUpgradeStrategyGrayStrategy entity.
// If the UpgradeFileUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeFileUpgradeStrategyGrayStrategy entity.
// If the UpgradeFileUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeFileUpgradeStrategyGrayStrategy entity.
// If the UpgradeFileUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradefileupgradestrategygraystrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategygraystrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradefileupgradestrategygraystrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeFileUpgradeStrategyGrayStrategy entity.
// If the UpgradeFileUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradefileupgradestrategygraystrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileupgradestrategygraystrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradefileupgradestrategygraystrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeFileUpgradeStrategyGrayStrategyMutation builder.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) Where(ps ...predicate.UpgradeFileUpgradeStrategyGrayStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeFileUpgradeStrategyGrayStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeFileUpgradeStrategyGrayStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeFileUpgradeStrategyGrayStrategy).
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.enable != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldEnable)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldEndDatetime)
	}
	if m._limit != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradefileupgradestrategygraystrategy.FieldEnable:
		return m.Enable()
	case upgradefileupgradestrategygraystrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradefileupgradestrategygraystrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradefileupgradestrategygraystrategy.FieldLimit:
		return m.Limit()
	case upgradefileupgradestrategygraystrategy.FieldIsDel:
		return m.IsDel()
	case upgradefileupgradestrategygraystrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradefileupgradestrategygraystrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradefileupgradestrategygraystrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradefileupgradestrategygraystrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradefileupgradestrategygraystrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradefileupgradestrategygraystrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradefileupgradestrategygraystrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradefileupgradestrategygraystrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradefileupgradestrategygraystrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeFileUpgradeStrategyGrayStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradefileupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyGrayStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldEnable)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradefileupgradestrategygraystrategy.FieldEnable:
		return m.AddedEnable()
	case upgradefileupgradestrategygraystrategy.FieldLimit:
		return m.AddedLimit()
	case upgradefileupgradestrategygraystrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradefileupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradefileupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyGrayStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradefileupgradestrategygraystrategy.FieldCreateAt) {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradefileupgradestrategygraystrategy.FieldUpdateAt) {
		fields = append(fields, upgradefileupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradefileupgradestrategygraystrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradefileupgradestrategygraystrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyGrayStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradefileupgradestrategygraystrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradefileupgradestrategygraystrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradefileupgradestrategygraystrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradefileupgradestrategygraystrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradefileupgradestrategygraystrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradefileupgradestrategygraystrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradefileupgradestrategygraystrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyGrayStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyGrayStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeFileUpgradeStrategyGrayStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileUpgradeStrategyGrayStrategy edge %s", name)
}

// UpgradeFileVersionMutation represents an operation that mutates the UpgradeFileVersion nodes in the graph.
type UpgradeFileVersionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	company_id      *int
	addcompany_id   *int
	file_id         *int
	addfile_id      *int
	cloud_file_id   *string
	version_name    *string
	version_code    *int
	addversion_code *int
	description     *string
	is_del          *int32
	addis_del       *int32
	create_at       *time.Time
	update_at       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UpgradeFileVersion, error)
	predicates      []predicate.UpgradeFileVersion
}

var _ ent.Mutation = (*UpgradeFileVersionMutation)(nil)

// upgradefileversionOption allows management of the mutation configuration using functional options.
type upgradefileversionOption func(*UpgradeFileVersionMutation)

// newUpgradeFileVersionMutation creates new mutation for the UpgradeFileVersion entity.
func newUpgradeFileVersionMutation(c config, op Op, opts ...upgradefileversionOption) *UpgradeFileVersionMutation {
	m := &UpgradeFileVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeFileVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeFileVersionID sets the ID field of the mutation.
func withUpgradeFileVersionID(id int) upgradefileversionOption {
	return func(m *UpgradeFileVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeFileVersion
		)
		m.oldValue = func(ctx context.Context) (*UpgradeFileVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeFileVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeFileVersion sets the old UpgradeFileVersion of the mutation.
func withUpgradeFileVersion(node *UpgradeFileVersion) upgradefileversionOption {
	return func(m *UpgradeFileVersionMutation) {
		m.oldValue = func(context.Context) (*UpgradeFileVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeFileVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeFileVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeFileVersion entities.
func (m *UpgradeFileVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeFileVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeFileVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeFileVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeFileVersionMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeFileVersionMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeFileVersionMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeFileVersionMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeFileVersionMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetFileID sets the "file_id" field.
func (m *UpgradeFileVersionMutation) SetFileID(i int) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *UpgradeFileVersionMutation) FileID() (r int, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *UpgradeFileVersionMutation) AddFileID(i int) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *UpgradeFileVersionMutation) AddedFileID() (r int, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *UpgradeFileVersionMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetCloudFileID sets the "cloud_file_id" field.
func (m *UpgradeFileVersionMutation) SetCloudFileID(s string) {
	m.cloud_file_id = &s
}

// CloudFileID returns the value of the "cloud_file_id" field in the mutation.
func (m *UpgradeFileVersionMutation) CloudFileID() (r string, exists bool) {
	v := m.cloud_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudFileID returns the old "cloud_file_id" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldCloudFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudFileID: %w", err)
	}
	return oldValue.CloudFileID, nil
}

// ResetCloudFileID resets all changes to the "cloud_file_id" field.
func (m *UpgradeFileVersionMutation) ResetCloudFileID() {
	m.cloud_file_id = nil
}

// SetVersionName sets the "version_name" field.
func (m *UpgradeFileVersionMutation) SetVersionName(s string) {
	m.version_name = &s
}

// VersionName returns the value of the "version_name" field in the mutation.
func (m *UpgradeFileVersionMutation) VersionName() (r string, exists bool) {
	v := m.version_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionName returns the old "version_name" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldVersionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionName: %w", err)
	}
	return oldValue.VersionName, nil
}

// ResetVersionName resets all changes to the "version_name" field.
func (m *UpgradeFileVersionMutation) ResetVersionName() {
	m.version_name = nil
}

// SetVersionCode sets the "version_code" field.
func (m *UpgradeFileVersionMutation) SetVersionCode(i int) {
	m.version_code = &i
	m.addversion_code = nil
}

// VersionCode returns the value of the "version_code" field in the mutation.
func (m *UpgradeFileVersionMutation) VersionCode() (r int, exists bool) {
	v := m.version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionCode returns the old "version_code" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldVersionCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionCode: %w", err)
	}
	return oldValue.VersionCode, nil
}

// AddVersionCode adds i to the "version_code" field.
func (m *UpgradeFileVersionMutation) AddVersionCode(i int) {
	if m.addversion_code != nil {
		*m.addversion_code += i
	} else {
		m.addversion_code = &i
	}
}

// AddedVersionCode returns the value that was added to the "version_code" field in this mutation.
func (m *UpgradeFileVersionMutation) AddedVersionCode() (r int, exists bool) {
	v := m.addversion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionCode resets all changes to the "version_code" field.
func (m *UpgradeFileVersionMutation) ResetVersionCode() {
	m.version_code = nil
	m.addversion_code = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeFileVersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeFileVersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeFileVersionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradefileversion.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeFileVersionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradefileversion.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeFileVersionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradefileversion.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeFileVersionMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeFileVersionMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeFileVersionMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeFileVersionMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeFileVersionMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeFileVersionMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeFileVersionMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeFileVersionMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradefileversion.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeFileVersionMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileversion.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeFileVersionMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradefileversion.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeFileVersionMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeFileVersionMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeFileVersion entity.
// If the UpgradeFileVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeFileVersionMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeFileVersionMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradefileversion.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeFileVersionMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradefileversion.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeFileVersionMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradefileversion.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeFileVersionMutation builder.
func (m *UpgradeFileVersionMutation) Where(ps ...predicate.UpgradeFileVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeFileVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeFileVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeFileVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeFileVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeFileVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeFileVersion).
func (m *UpgradeFileVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeFileVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.company_id != nil {
		fields = append(fields, upgradefileversion.FieldCompanyID)
	}
	if m.file_id != nil {
		fields = append(fields, upgradefileversion.FieldFileID)
	}
	if m.cloud_file_id != nil {
		fields = append(fields, upgradefileversion.FieldCloudFileID)
	}
	if m.version_name != nil {
		fields = append(fields, upgradefileversion.FieldVersionName)
	}
	if m.version_code != nil {
		fields = append(fields, upgradefileversion.FieldVersionCode)
	}
	if m.description != nil {
		fields = append(fields, upgradefileversion.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradefileversion.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradefileversion.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradefileversion.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeFileVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradefileversion.FieldCompanyID:
		return m.CompanyID()
	case upgradefileversion.FieldFileID:
		return m.FileID()
	case upgradefileversion.FieldCloudFileID:
		return m.CloudFileID()
	case upgradefileversion.FieldVersionName:
		return m.VersionName()
	case upgradefileversion.FieldVersionCode:
		return m.VersionCode()
	case upgradefileversion.FieldDescription:
		return m.Description()
	case upgradefileversion.FieldIsDel:
		return m.IsDel()
	case upgradefileversion.FieldCreateAt:
		return m.CreateAt()
	case upgradefileversion.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeFileVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradefileversion.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradefileversion.FieldFileID:
		return m.OldFileID(ctx)
	case upgradefileversion.FieldCloudFileID:
		return m.OldCloudFileID(ctx)
	case upgradefileversion.FieldVersionName:
		return m.OldVersionName(ctx)
	case upgradefileversion.FieldVersionCode:
		return m.OldVersionCode(ctx)
	case upgradefileversion.FieldDescription:
		return m.OldDescription(ctx)
	case upgradefileversion.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradefileversion.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradefileversion.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeFileVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradefileversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradefileversion.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case upgradefileversion.FieldCloudFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudFileID(v)
		return nil
	case upgradefileversion.FieldVersionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionName(v)
		return nil
	case upgradefileversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionCode(v)
		return nil
	case upgradefileversion.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradefileversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradefileversion.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradefileversion.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeFileVersionMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradefileversion.FieldCompanyID)
	}
	if m.addfile_id != nil {
		fields = append(fields, upgradefileversion.FieldFileID)
	}
	if m.addversion_code != nil {
		fields = append(fields, upgradefileversion.FieldVersionCode)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradefileversion.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeFileVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradefileversion.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradefileversion.FieldFileID:
		return m.AddedFileID()
	case upgradefileversion.FieldVersionCode:
		return m.AddedVersionCode()
	case upgradefileversion.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeFileVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradefileversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradefileversion.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	case upgradefileversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionCode(v)
		return nil
	case upgradefileversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeFileVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradefileversion.FieldDescription) {
		fields = append(fields, upgradefileversion.FieldDescription)
	}
	if m.FieldCleared(upgradefileversion.FieldCreateAt) {
		fields = append(fields, upgradefileversion.FieldCreateAt)
	}
	if m.FieldCleared(upgradefileversion.FieldUpdateAt) {
		fields = append(fields, upgradefileversion.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeFileVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeFileVersionMutation) ClearField(name string) error {
	switch name {
	case upgradefileversion.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradefileversion.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradefileversion.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeFileVersionMutation) ResetField(name string) error {
	switch name {
	case upgradefileversion.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradefileversion.FieldFileID:
		m.ResetFileID()
		return nil
	case upgradefileversion.FieldCloudFileID:
		m.ResetCloudFileID()
		return nil
	case upgradefileversion.FieldVersionName:
		m.ResetVersionName()
		return nil
	case upgradefileversion.FieldVersionCode:
		m.ResetVersionCode()
		return nil
	case upgradefileversion.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradefileversion.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradefileversion.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradefileversion.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeFileVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeFileVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeFileVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeFileVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeFileVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeFileVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeFileVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeFileVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeFileVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeFileVersion edge %s", name)
}

// UpgradeTauriMutation represents an operation that mutates the UpgradeTauri nodes in the graph.
type UpgradeTauriMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	name          *string
	description   *string
	github_url    *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeTauri, error)
	predicates    []predicate.UpgradeTauri
}

var _ ent.Mutation = (*UpgradeTauriMutation)(nil)

// upgradetauriOption allows management of the mutation configuration using functional options.
type upgradetauriOption func(*UpgradeTauriMutation)

// newUpgradeTauriMutation creates new mutation for the UpgradeTauri entity.
func newUpgradeTauriMutation(c config, op Op, opts ...upgradetauriOption) *UpgradeTauriMutation {
	m := &UpgradeTauriMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeTauri,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeTauriID sets the ID field of the mutation.
func withUpgradeTauriID(id int) upgradetauriOption {
	return func(m *UpgradeTauriMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeTauri
		)
		m.oldValue = func(ctx context.Context) (*UpgradeTauri, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeTauri.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeTauri sets the old UpgradeTauri of the mutation.
func withUpgradeTauri(node *UpgradeTauri) upgradetauriOption {
	return func(m *UpgradeTauriMutation) {
		m.oldValue = func(context.Context) (*UpgradeTauri, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeTauriMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeTauriMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeTauri entities.
func (m *UpgradeTauriMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeTauriMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeTauriMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeTauri.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeTauriMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeTauriMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeTauriMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeTauriMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeTauriMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeTauriMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeTauriMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeTauriMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UpgradeTauriMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeTauriMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeTauriMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeTauriMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeTauriMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeTauriMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradetauri.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeTauriMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradetauri.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeTauriMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradetauri.FieldDescription)
}

// SetGithubURL sets the "github_url" field.
func (m *UpgradeTauriMutation) SetGithubURL(s string) {
	m.github_url = &s
}

// GithubURL returns the value of the "github_url" field in the mutation.
func (m *UpgradeTauriMutation) GithubURL() (r string, exists bool) {
	v := m.github_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubURL returns the old "github_url" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldGithubURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubURL: %w", err)
	}
	return oldValue.GithubURL, nil
}

// ClearGithubURL clears the value of the "github_url" field.
func (m *UpgradeTauriMutation) ClearGithubURL() {
	m.github_url = nil
	m.clearedFields[upgradetauri.FieldGithubURL] = struct{}{}
}

// GithubURLCleared returns if the "github_url" field was cleared in this mutation.
func (m *UpgradeTauriMutation) GithubURLCleared() bool {
	_, ok := m.clearedFields[upgradetauri.FieldGithubURL]
	return ok
}

// ResetGithubURL resets all changes to the "github_url" field.
func (m *UpgradeTauriMutation) ResetGithubURL() {
	m.github_url = nil
	delete(m.clearedFields, upgradetauri.FieldGithubURL)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeTauriMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeTauriMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeTauriMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeTauriMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeTauriMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeTauriMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeTauriMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeTauriMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradetauri.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeTauriMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauri.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeTauriMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradetauri.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeTauriMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeTauriMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeTauri entity.
// If the UpgradeTauri object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeTauriMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradetauri.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeTauriMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauri.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeTauriMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradetauri.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeTauriMutation builder.
func (m *UpgradeTauriMutation) Where(ps ...predicate.UpgradeTauri) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeTauriMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeTauriMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeTauri, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeTauriMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeTauriMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeTauri).
func (m *UpgradeTauriMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeTauriMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.company_id != nil {
		fields = append(fields, upgradetauri.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradetauri.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, upgradetauri.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradetauri.FieldDescription)
	}
	if m.github_url != nil {
		fields = append(fields, upgradetauri.FieldGithubURL)
	}
	if m.is_del != nil {
		fields = append(fields, upgradetauri.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradetauri.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradetauri.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeTauriMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradetauri.FieldCompanyID:
		return m.CompanyID()
	case upgradetauri.FieldKey:
		return m.Key()
	case upgradetauri.FieldName:
		return m.Name()
	case upgradetauri.FieldDescription:
		return m.Description()
	case upgradetauri.FieldGithubURL:
		return m.GithubURL()
	case upgradetauri.FieldIsDel:
		return m.IsDel()
	case upgradetauri.FieldCreateAt:
		return m.CreateAt()
	case upgradetauri.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeTauriMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradetauri.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradetauri.FieldKey:
		return m.OldKey(ctx)
	case upgradetauri.FieldName:
		return m.OldName(ctx)
	case upgradetauri.FieldDescription:
		return m.OldDescription(ctx)
	case upgradetauri.FieldGithubURL:
		return m.OldGithubURL(ctx)
	case upgradetauri.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradetauri.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradetauri.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeTauri field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradetauri.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradetauri.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradetauri.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradetauri.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradetauri.FieldGithubURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubURL(v)
		return nil
	case upgradetauri.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradetauri.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradetauri.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauri field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeTauriMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradetauri.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradetauri.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeTauriMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradetauri.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradetauri.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradetauri.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradetauri.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauri numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeTauriMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradetauri.FieldDescription) {
		fields = append(fields, upgradetauri.FieldDescription)
	}
	if m.FieldCleared(upgradetauri.FieldGithubURL) {
		fields = append(fields, upgradetauri.FieldGithubURL)
	}
	if m.FieldCleared(upgradetauri.FieldCreateAt) {
		fields = append(fields, upgradetauri.FieldCreateAt)
	}
	if m.FieldCleared(upgradetauri.FieldUpdateAt) {
		fields = append(fields, upgradetauri.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeTauriMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeTauriMutation) ClearField(name string) error {
	switch name {
	case upgradetauri.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradetauri.FieldGithubURL:
		m.ClearGithubURL()
		return nil
	case upgradetauri.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradetauri.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauri nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeTauriMutation) ResetField(name string) error {
	switch name {
	case upgradetauri.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradetauri.FieldKey:
		m.ResetKey()
		return nil
	case upgradetauri.FieldName:
		m.ResetName()
		return nil
	case upgradetauri.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradetauri.FieldGithubURL:
		m.ResetGithubURL()
		return nil
	case upgradetauri.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradetauri.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradetauri.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauri field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeTauriMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeTauriMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeTauriMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeTauriMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeTauriMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeTauriMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeTauriMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauri unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeTauriMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauri edge %s", name)
}

// UpgradeTauriUpgradeStrategyMutation represents an operation that mutates the UpgradeTauriUpgradeStrategy nodes in the graph.
type UpgradeTauriUpgradeStrategyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	company_id              *int
	addcompany_id           *int
	enable                  *int32
	addenable               *int32
	name                    *string
	description             *string
	tauri_id                *int
	addtauri_id             *int
	tauri_version_id        *int
	addtauri_version_id     *int
	begin_datetime          *time.Time
	end_datetime            *time.Time
	upgrade_type            *int32
	addupgrade_type         *int32
	prompt_upgrade_content  *string
	upgrade_dev_type        *int32
	addupgrade_dev_type     *int32
	upgrade_dev_data        *string
	upgrade_version_type    *int32
	addupgrade_version_type *int32
	upgrade_version_data    *string
	is_gray                 *int32
	addis_gray              *int32
	gray_data               *string
	is_flow_limit           *int32
	addis_flow_limit        *int32
	flow_limit_data         *string
	is_del                  *int32
	addis_del               *int32
	create_at               *time.Time
	update_at               *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*UpgradeTauriUpgradeStrategy, error)
	predicates              []predicate.UpgradeTauriUpgradeStrategy
}

var _ ent.Mutation = (*UpgradeTauriUpgradeStrategyMutation)(nil)

// upgradetauriupgradestrategyOption allows management of the mutation configuration using functional options.
type upgradetauriupgradestrategyOption func(*UpgradeTauriUpgradeStrategyMutation)

// newUpgradeTauriUpgradeStrategyMutation creates new mutation for the UpgradeTauriUpgradeStrategy entity.
func newUpgradeTauriUpgradeStrategyMutation(c config, op Op, opts ...upgradetauriupgradestrategyOption) *UpgradeTauriUpgradeStrategyMutation {
	m := &UpgradeTauriUpgradeStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeTauriUpgradeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeTauriUpgradeStrategyID sets the ID field of the mutation.
func withUpgradeTauriUpgradeStrategyID(id int) upgradetauriupgradestrategyOption {
	return func(m *UpgradeTauriUpgradeStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeTauriUpgradeStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeTauriUpgradeStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeTauriUpgradeStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeTauriUpgradeStrategy sets the old UpgradeTauriUpgradeStrategy of the mutation.
func withUpgradeTauriUpgradeStrategy(node *UpgradeTauriUpgradeStrategy) upgradetauriupgradestrategyOption {
	return func(m *UpgradeTauriUpgradeStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeTauriUpgradeStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeTauriUpgradeStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeTauriUpgradeStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeTauriUpgradeStrategy entities.
func (m *UpgradeTauriUpgradeStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeTauriUpgradeStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeTauriUpgradeStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetEnable sets the "enable" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetName sets the "name" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradetauriupgradestrategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradetauriupgradestrategy.FieldDescription)
}

// SetTauriID sets the "tauri_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetTauriID(i int) {
	m.tauri_id = &i
	m.addtauri_id = nil
}

// TauriID returns the value of the "tauri_id" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) TauriID() (r int, exists bool) {
	v := m.tauri_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTauriID returns the old "tauri_id" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldTauriID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTauriID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTauriID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTauriID: %w", err)
	}
	return oldValue.TauriID, nil
}

// AddTauriID adds i to the "tauri_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddTauriID(i int) {
	if m.addtauri_id != nil {
		*m.addtauri_id += i
	} else {
		m.addtauri_id = &i
	}
}

// AddedTauriID returns the value that was added to the "tauri_id" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedTauriID() (r int, exists bool) {
	v := m.addtauri_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTauriID resets all changes to the "tauri_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetTauriID() {
	m.tauri_id = nil
	m.addtauri_id = nil
}

// SetTauriVersionID sets the "tauri_version_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetTauriVersionID(i int) {
	m.tauri_version_id = &i
	m.addtauri_version_id = nil
}

// TauriVersionID returns the value of the "tauri_version_id" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) TauriVersionID() (r int, exists bool) {
	v := m.tauri_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTauriVersionID returns the old "tauri_version_id" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldTauriVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTauriVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTauriVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTauriVersionID: %w", err)
	}
	return oldValue.TauriVersionID, nil
}

// AddTauriVersionID adds i to the "tauri_version_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddTauriVersionID(i int) {
	if m.addtauri_version_id != nil {
		*m.addtauri_version_id += i
	} else {
		m.addtauri_version_id = &i
	}
}

// AddedTauriVersionID returns the value that was added to the "tauri_version_id" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedTauriVersionID() (r int, exists bool) {
	v := m.addtauri_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTauriVersionID resets all changes to the "tauri_version_id" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetTauriVersionID() {
	m.tauri_version_id = nil
	m.addtauri_version_id = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetUpgradeType sets the "upgrade_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetUpgradeType(i int32) {
	m.upgrade_type = &i
	m.addupgrade_type = nil
}

// UpgradeType returns the value of the "upgrade_type" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) UpgradeType() (r int32, exists bool) {
	v := m.upgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeType returns the old "upgrade_type" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldUpgradeType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeType: %w", err)
	}
	return oldValue.UpgradeType, nil
}

// AddUpgradeType adds i to the "upgrade_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddUpgradeType(i int32) {
	if m.addupgrade_type != nil {
		*m.addupgrade_type += i
	} else {
		m.addupgrade_type = &i
	}
}

// AddedUpgradeType returns the value that was added to the "upgrade_type" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedUpgradeType() (r int32, exists bool) {
	v := m.addupgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeType resets all changes to the "upgrade_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetUpgradeType() {
	m.upgrade_type = nil
	m.addupgrade_type = nil
}

// SetPromptUpgradeContent sets the "prompt_upgrade_content" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetPromptUpgradeContent(s string) {
	m.prompt_upgrade_content = &s
}

// PromptUpgradeContent returns the value of the "prompt_upgrade_content" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) PromptUpgradeContent() (r string, exists bool) {
	v := m.prompt_upgrade_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptUpgradeContent returns the old "prompt_upgrade_content" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldPromptUpgradeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptUpgradeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptUpgradeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptUpgradeContent: %w", err)
	}
	return oldValue.PromptUpgradeContent, nil
}

// ClearPromptUpgradeContent clears the value of the "prompt_upgrade_content" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	m.clearedFields[upgradetauriupgradestrategy.FieldPromptUpgradeContent] = struct{}{}
}

// PromptUpgradeContentCleared returns if the "prompt_upgrade_content" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) PromptUpgradeContentCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategy.FieldPromptUpgradeContent]
	return ok
}

// ResetPromptUpgradeContent resets all changes to the "prompt_upgrade_content" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	delete(m.clearedFields, upgradetauriupgradestrategy.FieldPromptUpgradeContent)
}

// SetUpgradeDevType sets the "upgrade_dev_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetUpgradeDevType(i int32) {
	m.upgrade_dev_type = &i
	m.addupgrade_dev_type = nil
}

// UpgradeDevType returns the value of the "upgrade_dev_type" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) UpgradeDevType() (r int32, exists bool) {
	v := m.upgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevType returns the old "upgrade_dev_type" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldUpgradeDevType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevType: %w", err)
	}
	return oldValue.UpgradeDevType, nil
}

// AddUpgradeDevType adds i to the "upgrade_dev_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddUpgradeDevType(i int32) {
	if m.addupgrade_dev_type != nil {
		*m.addupgrade_dev_type += i
	} else {
		m.addupgrade_dev_type = &i
	}
}

// AddedUpgradeDevType returns the value that was added to the "upgrade_dev_type" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedUpgradeDevType() (r int32, exists bool) {
	v := m.addupgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeDevType resets all changes to the "upgrade_dev_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetUpgradeDevType() {
	m.upgrade_dev_type = nil
	m.addupgrade_dev_type = nil
}

// SetUpgradeDevData sets the "upgrade_dev_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetUpgradeDevData(s string) {
	m.upgrade_dev_data = &s
}

// UpgradeDevData returns the value of the "upgrade_dev_data" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) UpgradeDevData() (r string, exists bool) {
	v := m.upgrade_dev_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevData returns the old "upgrade_dev_data" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldUpgradeDevData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevData: %w", err)
	}
	return oldValue.UpgradeDevData, nil
}

// ResetUpgradeDevData resets all changes to the "upgrade_dev_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetUpgradeDevData() {
	m.upgrade_dev_data = nil
}

// SetUpgradeVersionType sets the "upgrade_version_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetUpgradeVersionType(i int32) {
	m.upgrade_version_type = &i
	m.addupgrade_version_type = nil
}

// UpgradeVersionType returns the value of the "upgrade_version_type" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) UpgradeVersionType() (r int32, exists bool) {
	v := m.upgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionType returns the old "upgrade_version_type" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldUpgradeVersionType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionType: %w", err)
	}
	return oldValue.UpgradeVersionType, nil
}

// AddUpgradeVersionType adds i to the "upgrade_version_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddUpgradeVersionType(i int32) {
	if m.addupgrade_version_type != nil {
		*m.addupgrade_version_type += i
	} else {
		m.addupgrade_version_type = &i
	}
}

// AddedUpgradeVersionType returns the value that was added to the "upgrade_version_type" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedUpgradeVersionType() (r int32, exists bool) {
	v := m.addupgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeVersionType resets all changes to the "upgrade_version_type" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetUpgradeVersionType() {
	m.upgrade_version_type = nil
	m.addupgrade_version_type = nil
}

// SetUpgradeVersionData sets the "upgrade_version_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetUpgradeVersionData(s string) {
	m.upgrade_version_data = &s
}

// UpgradeVersionData returns the value of the "upgrade_version_data" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) UpgradeVersionData() (r string, exists bool) {
	v := m.upgrade_version_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionData returns the old "upgrade_version_data" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldUpgradeVersionData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionData: %w", err)
	}
	return oldValue.UpgradeVersionData, nil
}

// ResetUpgradeVersionData resets all changes to the "upgrade_version_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetUpgradeVersionData() {
	m.upgrade_version_data = nil
}

// SetIsGray sets the "is_gray" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetIsGray(i int32) {
	m.is_gray = &i
	m.addis_gray = nil
}

// IsGray returns the value of the "is_gray" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) IsGray() (r int32, exists bool) {
	v := m.is_gray
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGray returns the old "is_gray" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldIsGray(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGray: %w", err)
	}
	return oldValue.IsGray, nil
}

// AddIsGray adds i to the "is_gray" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddIsGray(i int32) {
	if m.addis_gray != nil {
		*m.addis_gray += i
	} else {
		m.addis_gray = &i
	}
}

// AddedIsGray returns the value that was added to the "is_gray" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedIsGray() (r int32, exists bool) {
	v := m.addis_gray
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsGray resets all changes to the "is_gray" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetIsGray() {
	m.is_gray = nil
	m.addis_gray = nil
}

// SetGrayData sets the "gray_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetGrayData(s string) {
	m.gray_data = &s
}

// GrayData returns the value of the "gray_data" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) GrayData() (r string, exists bool) {
	v := m.gray_data
	if v == nil {
		return
	}
	return *v, true
}

// OldGrayData returns the old "gray_data" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldGrayData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrayData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrayData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrayData: %w", err)
	}
	return oldValue.GrayData, nil
}

// ResetGrayData resets all changes to the "gray_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetGrayData() {
	m.gray_data = nil
}

// SetIsFlowLimit sets the "is_flow_limit" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetIsFlowLimit(i int32) {
	m.is_flow_limit = &i
	m.addis_flow_limit = nil
}

// IsFlowLimit returns the value of the "is_flow_limit" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) IsFlowLimit() (r int32, exists bool) {
	v := m.is_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlowLimit returns the old "is_flow_limit" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldIsFlowLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlowLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlowLimit: %w", err)
	}
	return oldValue.IsFlowLimit, nil
}

// AddIsFlowLimit adds i to the "is_flow_limit" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddIsFlowLimit(i int32) {
	if m.addis_flow_limit != nil {
		*m.addis_flow_limit += i
	} else {
		m.addis_flow_limit = &i
	}
}

// AddedIsFlowLimit returns the value that was added to the "is_flow_limit" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedIsFlowLimit() (r int32, exists bool) {
	v := m.addis_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFlowLimit resets all changes to the "is_flow_limit" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetIsFlowLimit() {
	m.is_flow_limit = nil
	m.addis_flow_limit = nil
}

// SetFlowLimitData sets the "flow_limit_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetFlowLimitData(s string) {
	m.flow_limit_data = &s
}

// FlowLimitData returns the value of the "flow_limit_data" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) FlowLimitData() (r string, exists bool) {
	v := m.flow_limit_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowLimitData returns the old "flow_limit_data" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldFlowLimitData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowLimitData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowLimitData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowLimitData: %w", err)
	}
	return oldValue.FlowLimitData, nil
}

// ResetFlowLimitData resets all changes to the "flow_limit_data" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetFlowLimitData() {
	m.flow_limit_data = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradetauriupgradestrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradetauriupgradestrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeTauriUpgradeStrategy entity.
// If the UpgradeTauriUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradetauriupgradestrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradetauriupgradestrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeTauriUpgradeStrategyMutation builder.
func (m *UpgradeTauriUpgradeStrategyMutation) Where(ps ...predicate.UpgradeTauriUpgradeStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeTauriUpgradeStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeTauriUpgradeStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeTauriUpgradeStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeTauriUpgradeStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeTauriUpgradeStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeTauriUpgradeStrategy).
func (m *UpgradeTauriUpgradeStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeTauriUpgradeStrategyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.company_id != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldCompanyID)
	}
	if m.enable != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldDescription)
	}
	if m.tauri_id != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldTauriID)
	}
	if m.tauri_version_id != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldTauriVersionID)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldEndDatetime)
	}
	if m.upgrade_type != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeType)
	}
	if m.prompt_upgrade_content != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.upgrade_dev_type != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeDevType)
	}
	if m.upgrade_dev_data != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeDevData)
	}
	if m.upgrade_version_type != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeVersionType)
	}
	if m.upgrade_version_data != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeVersionData)
	}
	if m.is_gray != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldIsGray)
	}
	if m.gray_data != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldGrayData)
	}
	if m.is_flow_limit != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldIsFlowLimit)
	}
	if m.flow_limit_data != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldFlowLimitData)
	}
	if m.is_del != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeTauriUpgradeStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriupgradestrategy.FieldCompanyID:
		return m.CompanyID()
	case upgradetauriupgradestrategy.FieldEnable:
		return m.Enable()
	case upgradetauriupgradestrategy.FieldName:
		return m.Name()
	case upgradetauriupgradestrategy.FieldDescription:
		return m.Description()
	case upgradetauriupgradestrategy.FieldTauriID:
		return m.TauriID()
	case upgradetauriupgradestrategy.FieldTauriVersionID:
		return m.TauriVersionID()
	case upgradetauriupgradestrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradetauriupgradestrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradetauriupgradestrategy.FieldUpgradeType:
		return m.UpgradeType()
	case upgradetauriupgradestrategy.FieldPromptUpgradeContent:
		return m.PromptUpgradeContent()
	case upgradetauriupgradestrategy.FieldUpgradeDevType:
		return m.UpgradeDevType()
	case upgradetauriupgradestrategy.FieldUpgradeDevData:
		return m.UpgradeDevData()
	case upgradetauriupgradestrategy.FieldUpgradeVersionType:
		return m.UpgradeVersionType()
	case upgradetauriupgradestrategy.FieldUpgradeVersionData:
		return m.UpgradeVersionData()
	case upgradetauriupgradestrategy.FieldIsGray:
		return m.IsGray()
	case upgradetauriupgradestrategy.FieldGrayData:
		return m.GrayData()
	case upgradetauriupgradestrategy.FieldIsFlowLimit:
		return m.IsFlowLimit()
	case upgradetauriupgradestrategy.FieldFlowLimitData:
		return m.FlowLimitData()
	case upgradetauriupgradestrategy.FieldIsDel:
		return m.IsDel()
	case upgradetauriupgradestrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradetauriupgradestrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeTauriUpgradeStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradetauriupgradestrategy.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradetauriupgradestrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradetauriupgradestrategy.FieldName:
		return m.OldName(ctx)
	case upgradetauriupgradestrategy.FieldDescription:
		return m.OldDescription(ctx)
	case upgradetauriupgradestrategy.FieldTauriID:
		return m.OldTauriID(ctx)
	case upgradetauriupgradestrategy.FieldTauriVersionID:
		return m.OldTauriVersionID(ctx)
	case upgradetauriupgradestrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradetauriupgradestrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradetauriupgradestrategy.FieldUpgradeType:
		return m.OldUpgradeType(ctx)
	case upgradetauriupgradestrategy.FieldPromptUpgradeContent:
		return m.OldPromptUpgradeContent(ctx)
	case upgradetauriupgradestrategy.FieldUpgradeDevType:
		return m.OldUpgradeDevType(ctx)
	case upgradetauriupgradestrategy.FieldUpgradeDevData:
		return m.OldUpgradeDevData(ctx)
	case upgradetauriupgradestrategy.FieldUpgradeVersionType:
		return m.OldUpgradeVersionType(ctx)
	case upgradetauriupgradestrategy.FieldUpgradeVersionData:
		return m.OldUpgradeVersionData(ctx)
	case upgradetauriupgradestrategy.FieldIsGray:
		return m.OldIsGray(ctx)
	case upgradetauriupgradestrategy.FieldGrayData:
		return m.OldGrayData(ctx)
	case upgradetauriupgradestrategy.FieldIsFlowLimit:
		return m.OldIsFlowLimit(ctx)
	case upgradetauriupgradestrategy.FieldFlowLimitData:
		return m.OldFlowLimitData(ctx)
	case upgradetauriupgradestrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradetauriupgradestrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradetauriupgradestrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeTauriUpgradeStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriUpgradeStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradetauriupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradetauriupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradetauriupgradestrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradetauriupgradestrategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradetauriupgradestrategy.FieldTauriID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTauriID(v)
		return nil
	case upgradetauriupgradestrategy.FieldTauriVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTauriVersionID(v)
		return nil
	case upgradetauriupgradestrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradetauriupgradestrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeType(v)
		return nil
	case upgradetauriupgradestrategy.FieldPromptUpgradeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptUpgradeContent(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevType(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeDevData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevData(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionType(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeVersionData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionData(v)
		return nil
	case upgradetauriupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGray(v)
		return nil
	case upgradetauriupgradestrategy.FieldGrayData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrayData(v)
		return nil
	case upgradetauriupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlowLimit(v)
		return nil
	case upgradetauriupgradestrategy.FieldFlowLimitData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowLimitData(v)
		return nil
	case upgradetauriupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradetauriupgradestrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldCompanyID)
	}
	if m.addenable != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldEnable)
	}
	if m.addtauri_id != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldTauriID)
	}
	if m.addtauri_version_id != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldTauriVersionID)
	}
	if m.addupgrade_type != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeType)
	}
	if m.addupgrade_dev_type != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeDevType)
	}
	if m.addupgrade_version_type != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpgradeVersionType)
	}
	if m.addis_gray != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldIsGray)
	}
	if m.addis_flow_limit != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldIsFlowLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradetauriupgradestrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriupgradestrategy.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradetauriupgradestrategy.FieldEnable:
		return m.AddedEnable()
	case upgradetauriupgradestrategy.FieldTauriID:
		return m.AddedTauriID()
	case upgradetauriupgradestrategy.FieldTauriVersionID:
		return m.AddedTauriVersionID()
	case upgradetauriupgradestrategy.FieldUpgradeType:
		return m.AddedUpgradeType()
	case upgradetauriupgradestrategy.FieldUpgradeDevType:
		return m.AddedUpgradeDevType()
	case upgradetauriupgradestrategy.FieldUpgradeVersionType:
		return m.AddedUpgradeVersionType()
	case upgradetauriupgradestrategy.FieldIsGray:
		return m.AddedIsGray()
	case upgradetauriupgradestrategy.FieldIsFlowLimit:
		return m.AddedIsFlowLimit()
	case upgradetauriupgradestrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriUpgradeStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradetauriupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradetauriupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradetauriupgradestrategy.FieldTauriID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTauriID(v)
		return nil
	case upgradetauriupgradestrategy.FieldTauriVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTauriVersionID(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeType(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeDevType(v)
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeVersionType(v)
		return nil
	case upgradetauriupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsGray(v)
		return nil
	case upgradetauriupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFlowLimit(v)
		return nil
	case upgradetauriupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradetauriupgradestrategy.FieldDescription) {
		fields = append(fields, upgradetauriupgradestrategy.FieldDescription)
	}
	if m.FieldCleared(upgradetauriupgradestrategy.FieldPromptUpgradeContent) {
		fields = append(fields, upgradetauriupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.FieldCleared(upgradetauriupgradestrategy.FieldCreateAt) {
		fields = append(fields, upgradetauriupgradestrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradetauriupgradestrategy.FieldUpdateAt) {
		fields = append(fields, upgradetauriupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradetauriupgradestrategy.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradetauriupgradestrategy.FieldPromptUpgradeContent:
		m.ClearPromptUpgradeContent()
		return nil
	case upgradetauriupgradestrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradetauriupgradestrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradetauriupgradestrategy.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradetauriupgradestrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradetauriupgradestrategy.FieldName:
		m.ResetName()
		return nil
	case upgradetauriupgradestrategy.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradetauriupgradestrategy.FieldTauriID:
		m.ResetTauriID()
		return nil
	case upgradetauriupgradestrategy.FieldTauriVersionID:
		m.ResetTauriVersionID()
		return nil
	case upgradetauriupgradestrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradetauriupgradestrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeType:
		m.ResetUpgradeType()
		return nil
	case upgradetauriupgradestrategy.FieldPromptUpgradeContent:
		m.ResetPromptUpgradeContent()
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeDevType:
		m.ResetUpgradeDevType()
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeDevData:
		m.ResetUpgradeDevData()
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeVersionType:
		m.ResetUpgradeVersionType()
		return nil
	case upgradetauriupgradestrategy.FieldUpgradeVersionData:
		m.ResetUpgradeVersionData()
		return nil
	case upgradetauriupgradestrategy.FieldIsGray:
		m.ResetIsGray()
		return nil
	case upgradetauriupgradestrategy.FieldGrayData:
		m.ResetGrayData()
		return nil
	case upgradetauriupgradestrategy.FieldIsFlowLimit:
		m.ResetIsFlowLimit()
		return nil
	case upgradetauriupgradestrategy.FieldFlowLimitData:
		m.ResetFlowLimitData()
		return nil
	case upgradetauriupgradestrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradetauriupgradestrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradetauriupgradestrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategy edge %s", name)
}

// UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation represents an operation that mutates the UpgradeTauriUpgradeStrategyFlowLimitStrategy nodes in the graph.
type UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	enable        *int32
	addenable     *int32
	begin_time    *string
	end_time      *string
	dimension     *int32
	adddimension  *int32
	_limit        *int
	add_limit     *int
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeTauriUpgradeStrategyFlowLimitStrategy, error)
	predicates    []predicate.UpgradeTauriUpgradeStrategyFlowLimitStrategy
}

var _ ent.Mutation = (*UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation)(nil)

// upgradetauriupgradestrategyflowlimitstrategyOption allows management of the mutation configuration using functional options.
type upgradetauriupgradestrategyflowlimitstrategyOption func(*UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation)

// newUpgradeTauriUpgradeStrategyFlowLimitStrategyMutation creates new mutation for the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
func newUpgradeTauriUpgradeStrategyFlowLimitStrategyMutation(c config, op Op, opts ...upgradetauriupgradestrategyflowlimitstrategyOption) *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation {
	m := &UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeTauriUpgradeStrategyFlowLimitStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeTauriUpgradeStrategyFlowLimitStrategyID sets the ID field of the mutation.
func withUpgradeTauriUpgradeStrategyFlowLimitStrategyID(id int) upgradetauriupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeTauriUpgradeStrategyFlowLimitStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeTauriUpgradeStrategyFlowLimitStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeTauriUpgradeStrategyFlowLimitStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeTauriUpgradeStrategyFlowLimitStrategy sets the old UpgradeTauriUpgradeStrategyFlowLimitStrategy of the mutation.
func withUpgradeTauriUpgradeStrategyFlowLimitStrategy(node *UpgradeTauriUpgradeStrategyFlowLimitStrategy) upgradetauriupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeTauriUpgradeStrategyFlowLimitStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeTauriUpgradeStrategyFlowLimitStrategy entities.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeTauriUpgradeStrategyFlowLimitStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginTime sets the "begin_time" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetBeginTime(s string) {
	m.begin_time = &s
}

// BeginTime returns the value of the "begin_time" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) BeginTime() (r string, exists bool) {
	v := m.begin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "begin_time" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldBeginTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "begin_time" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetBeginTime() {
	m.begin_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDimension sets the "dimension" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetDimension(i int32) {
	m.dimension = &i
	m.adddimension = nil
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Dimension() (r int32, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldDimension(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// AddDimension adds i to the "dimension" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddDimension(i int32) {
	if m.adddimension != nil {
		*m.adddimension += i
	} else {
		m.adddimension = &i
	}
}

// AddedDimension returns the value that was added to the "dimension" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedDimension() (r int32, exists bool) {
	v := m.adddimension
	if v == nil {
		return
	}
	return *v, true
}

// ResetDimension resets all changes to the "dimension" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetDimension() {
	m.dimension = nil
	m.adddimension = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeTauriUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeTauriUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation builder.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Where(ps ...predicate.UpgradeTauriUpgradeStrategyFlowLimitStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeTauriUpgradeStrategyFlowLimitStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeTauriUpgradeStrategyFlowLimitStrategy).
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.enable != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.begin_time != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldBeginTime)
	}
	if m.end_time != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldEndTime)
	}
	if m.dimension != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m._limit != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEnable:
		return m.Enable()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.BeginTime()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.EndTime()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldDimension:
		return m.Dimension()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldLimit:
		return m.Limit()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.IsDel()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradetauriupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.OldEndTime(ctx)
	case upgradetauriupgradestrategyflowlimitstrategy.FieldDimension:
		return m.OldDimension(ctx)
	case upgradetauriupgradestrategyflowlimitstrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeTauriUpgradeStrategyFlowLimitStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldBeginTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.adddimension != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEnable:
		return m.AddedEnable()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldDimension:
		return m.AddedDimension()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldLimit:
		return m.AddedLimit()
	case upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimension(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyFlowLimitStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt) {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt) {
		fields = append(fields, upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyFlowLimitStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldEndTime:
		m.ResetEndTime()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldDimension:
		m.ResetDimension()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradetauriupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyFlowLimitStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyFlowLimitStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyFlowLimitStrategy edge %s", name)
}

// UpgradeTauriUpgradeStrategyGrayStrategyMutation represents an operation that mutates the UpgradeTauriUpgradeStrategyGrayStrategy nodes in the graph.
type UpgradeTauriUpgradeStrategyGrayStrategyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	enable         *int32
	addenable      *int32
	begin_datetime *time.Time
	end_datetime   *time.Time
	_limit         *int
	add_limit      *int
	is_del         *int32
	addis_del      *int32
	create_at      *time.Time
	update_at      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UpgradeTauriUpgradeStrategyGrayStrategy, error)
	predicates     []predicate.UpgradeTauriUpgradeStrategyGrayStrategy
}

var _ ent.Mutation = (*UpgradeTauriUpgradeStrategyGrayStrategyMutation)(nil)

// upgradetauriupgradestrategygraystrategyOption allows management of the mutation configuration using functional options.
type upgradetauriupgradestrategygraystrategyOption func(*UpgradeTauriUpgradeStrategyGrayStrategyMutation)

// newUpgradeTauriUpgradeStrategyGrayStrategyMutation creates new mutation for the UpgradeTauriUpgradeStrategyGrayStrategy entity.
func newUpgradeTauriUpgradeStrategyGrayStrategyMutation(c config, op Op, opts ...upgradetauriupgradestrategygraystrategyOption) *UpgradeTauriUpgradeStrategyGrayStrategyMutation {
	m := &UpgradeTauriUpgradeStrategyGrayStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeTauriUpgradeStrategyGrayStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeTauriUpgradeStrategyGrayStrategyID sets the ID field of the mutation.
func withUpgradeTauriUpgradeStrategyGrayStrategyID(id int) upgradetauriupgradestrategygraystrategyOption {
	return func(m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeTauriUpgradeStrategyGrayStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeTauriUpgradeStrategyGrayStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeTauriUpgradeStrategyGrayStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeTauriUpgradeStrategyGrayStrategy sets the old UpgradeTauriUpgradeStrategyGrayStrategy of the mutation.
func withUpgradeTauriUpgradeStrategyGrayStrategy(node *UpgradeTauriUpgradeStrategyGrayStrategy) upgradetauriupgradestrategygraystrategyOption {
	return func(m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeTauriUpgradeStrategyGrayStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeTauriUpgradeStrategyGrayStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeTauriUpgradeStrategyGrayStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeTauriUpgradeStrategyGrayStrategy entities.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeTauriUpgradeStrategyGrayStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeTauriUpgradeStrategyGrayStrategy entity.
// If the UpgradeTauriUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeTauriUpgradeStrategyGrayStrategy entity.
// If the UpgradeTauriUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeTauriUpgradeStrategyGrayStrategy entity.
// If the UpgradeTauriUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeTauriUpgradeStrategyGrayStrategy entity.
// If the UpgradeTauriUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeTauriUpgradeStrategyGrayStrategy entity.
// If the UpgradeTauriUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeTauriUpgradeStrategyGrayStrategy entity.
// If the UpgradeTauriUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradetauriupgradestrategygraystrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategygraystrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradetauriupgradestrategygraystrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeTauriUpgradeStrategyGrayStrategy entity.
// If the UpgradeTauriUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradetauriupgradestrategygraystrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriupgradestrategygraystrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradetauriupgradestrategygraystrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeTauriUpgradeStrategyGrayStrategyMutation builder.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) Where(ps ...predicate.UpgradeTauriUpgradeStrategyGrayStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeTauriUpgradeStrategyGrayStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeTauriUpgradeStrategyGrayStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeTauriUpgradeStrategyGrayStrategy).
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.enable != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldEnable)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldEndDatetime)
	}
	if m._limit != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriupgradestrategygraystrategy.FieldEnable:
		return m.Enable()
	case upgradetauriupgradestrategygraystrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradetauriupgradestrategygraystrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradetauriupgradestrategygraystrategy.FieldLimit:
		return m.Limit()
	case upgradetauriupgradestrategygraystrategy.FieldIsDel:
		return m.IsDel()
	case upgradetauriupgradestrategygraystrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradetauriupgradestrategygraystrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradetauriupgradestrategygraystrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradetauriupgradestrategygraystrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradetauriupgradestrategygraystrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradetauriupgradestrategygraystrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradetauriupgradestrategygraystrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradetauriupgradestrategygraystrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradetauriupgradestrategygraystrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeTauriUpgradeStrategyGrayStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradetauriupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyGrayStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldEnable)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriupgradestrategygraystrategy.FieldEnable:
		return m.AddedEnable()
	case upgradetauriupgradestrategygraystrategy.FieldLimit:
		return m.AddedLimit()
	case upgradetauriupgradestrategygraystrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradetauriupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyGrayStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradetauriupgradestrategygraystrategy.FieldCreateAt) {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradetauriupgradestrategygraystrategy.FieldUpdateAt) {
		fields = append(fields, upgradetauriupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradetauriupgradestrategygraystrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyGrayStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradetauriupgradestrategygraystrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradetauriupgradestrategygraystrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyGrayStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyGrayStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeTauriUpgradeStrategyGrayStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriUpgradeStrategyGrayStrategy edge %s", name)
}

// UpgradeTauriVersionMutation represents an operation that mutates the UpgradeTauriVersion nodes in the graph.
type UpgradeTauriVersionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	company_id            *int
	addcompany_id         *int
	tauri_id              *int
	addtauri_id           *int
	cloud_file_id         *string
	install_cloud_file_id *string
	version_name          *string
	version_code          *int
	addversion_code       *int
	target                *string
	arch                  *string
	signature             *string
	description           *string
	is_del                *int32
	addis_del             *int32
	create_at             *time.Time
	update_at             *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*UpgradeTauriVersion, error)
	predicates            []predicate.UpgradeTauriVersion
}

var _ ent.Mutation = (*UpgradeTauriVersionMutation)(nil)

// upgradetauriversionOption allows management of the mutation configuration using functional options.
type upgradetauriversionOption func(*UpgradeTauriVersionMutation)

// newUpgradeTauriVersionMutation creates new mutation for the UpgradeTauriVersion entity.
func newUpgradeTauriVersionMutation(c config, op Op, opts ...upgradetauriversionOption) *UpgradeTauriVersionMutation {
	m := &UpgradeTauriVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeTauriVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeTauriVersionID sets the ID field of the mutation.
func withUpgradeTauriVersionID(id int) upgradetauriversionOption {
	return func(m *UpgradeTauriVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeTauriVersion
		)
		m.oldValue = func(ctx context.Context) (*UpgradeTauriVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeTauriVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeTauriVersion sets the old UpgradeTauriVersion of the mutation.
func withUpgradeTauriVersion(node *UpgradeTauriVersion) upgradetauriversionOption {
	return func(m *UpgradeTauriVersionMutation) {
		m.oldValue = func(context.Context) (*UpgradeTauriVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeTauriVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeTauriVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeTauriVersion entities.
func (m *UpgradeTauriVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeTauriVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeTauriVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeTauriVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeTauriVersionMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeTauriVersionMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeTauriVersionMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeTauriVersionMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeTauriVersionMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetTauriID sets the "tauri_id" field.
func (m *UpgradeTauriVersionMutation) SetTauriID(i int) {
	m.tauri_id = &i
	m.addtauri_id = nil
}

// TauriID returns the value of the "tauri_id" field in the mutation.
func (m *UpgradeTauriVersionMutation) TauriID() (r int, exists bool) {
	v := m.tauri_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTauriID returns the old "tauri_id" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldTauriID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTauriID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTauriID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTauriID: %w", err)
	}
	return oldValue.TauriID, nil
}

// AddTauriID adds i to the "tauri_id" field.
func (m *UpgradeTauriVersionMutation) AddTauriID(i int) {
	if m.addtauri_id != nil {
		*m.addtauri_id += i
	} else {
		m.addtauri_id = &i
	}
}

// AddedTauriID returns the value that was added to the "tauri_id" field in this mutation.
func (m *UpgradeTauriVersionMutation) AddedTauriID() (r int, exists bool) {
	v := m.addtauri_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTauriID resets all changes to the "tauri_id" field.
func (m *UpgradeTauriVersionMutation) ResetTauriID() {
	m.tauri_id = nil
	m.addtauri_id = nil
}

// SetCloudFileID sets the "cloud_file_id" field.
func (m *UpgradeTauriVersionMutation) SetCloudFileID(s string) {
	m.cloud_file_id = &s
}

// CloudFileID returns the value of the "cloud_file_id" field in the mutation.
func (m *UpgradeTauriVersionMutation) CloudFileID() (r string, exists bool) {
	v := m.cloud_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudFileID returns the old "cloud_file_id" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldCloudFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudFileID: %w", err)
	}
	return oldValue.CloudFileID, nil
}

// ResetCloudFileID resets all changes to the "cloud_file_id" field.
func (m *UpgradeTauriVersionMutation) ResetCloudFileID() {
	m.cloud_file_id = nil
}

// SetInstallCloudFileID sets the "install_cloud_file_id" field.
func (m *UpgradeTauriVersionMutation) SetInstallCloudFileID(s string) {
	m.install_cloud_file_id = &s
}

// InstallCloudFileID returns the value of the "install_cloud_file_id" field in the mutation.
func (m *UpgradeTauriVersionMutation) InstallCloudFileID() (r string, exists bool) {
	v := m.install_cloud_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallCloudFileID returns the old "install_cloud_file_id" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldInstallCloudFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallCloudFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallCloudFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallCloudFileID: %w", err)
	}
	return oldValue.InstallCloudFileID, nil
}

// ResetInstallCloudFileID resets all changes to the "install_cloud_file_id" field.
func (m *UpgradeTauriVersionMutation) ResetInstallCloudFileID() {
	m.install_cloud_file_id = nil
}

// SetVersionName sets the "version_name" field.
func (m *UpgradeTauriVersionMutation) SetVersionName(s string) {
	m.version_name = &s
}

// VersionName returns the value of the "version_name" field in the mutation.
func (m *UpgradeTauriVersionMutation) VersionName() (r string, exists bool) {
	v := m.version_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionName returns the old "version_name" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldVersionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionName: %w", err)
	}
	return oldValue.VersionName, nil
}

// ResetVersionName resets all changes to the "version_name" field.
func (m *UpgradeTauriVersionMutation) ResetVersionName() {
	m.version_name = nil
}

// SetVersionCode sets the "version_code" field.
func (m *UpgradeTauriVersionMutation) SetVersionCode(i int) {
	m.version_code = &i
	m.addversion_code = nil
}

// VersionCode returns the value of the "version_code" field in the mutation.
func (m *UpgradeTauriVersionMutation) VersionCode() (r int, exists bool) {
	v := m.version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionCode returns the old "version_code" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldVersionCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionCode: %w", err)
	}
	return oldValue.VersionCode, nil
}

// AddVersionCode adds i to the "version_code" field.
func (m *UpgradeTauriVersionMutation) AddVersionCode(i int) {
	if m.addversion_code != nil {
		*m.addversion_code += i
	} else {
		m.addversion_code = &i
	}
}

// AddedVersionCode returns the value that was added to the "version_code" field in this mutation.
func (m *UpgradeTauriVersionMutation) AddedVersionCode() (r int, exists bool) {
	v := m.addversion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionCode resets all changes to the "version_code" field.
func (m *UpgradeTauriVersionMutation) ResetVersionCode() {
	m.version_code = nil
	m.addversion_code = nil
}

// SetTarget sets the "target" field.
func (m *UpgradeTauriVersionMutation) SetTarget(s string) {
	m.target = &s
}

// Target returns the value of the "target" field in the mutation.
func (m *UpgradeTauriVersionMutation) Target() (r string, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old "target" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// ResetTarget resets all changes to the "target" field.
func (m *UpgradeTauriVersionMutation) ResetTarget() {
	m.target = nil
}

// SetArch sets the "arch" field.
func (m *UpgradeTauriVersionMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *UpgradeTauriVersionMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *UpgradeTauriVersionMutation) ResetArch() {
	m.arch = nil
}

// SetSignature sets the "signature" field.
func (m *UpgradeTauriVersionMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *UpgradeTauriVersionMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "signature" field.
func (m *UpgradeTauriVersionMutation) ResetSignature() {
	m.signature = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeTauriVersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeTauriVersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeTauriVersionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradetauriversion.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeTauriVersionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradetauriversion.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeTauriVersionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradetauriversion.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeTauriVersionMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeTauriVersionMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeTauriVersionMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeTauriVersionMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeTauriVersionMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeTauriVersionMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeTauriVersionMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeTauriVersionMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradetauriversion.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeTauriVersionMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriversion.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeTauriVersionMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradetauriversion.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeTauriVersionMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeTauriVersionMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeTauriVersion entity.
// If the UpgradeTauriVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTauriVersionMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeTauriVersionMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradetauriversion.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeTauriVersionMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradetauriversion.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeTauriVersionMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradetauriversion.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeTauriVersionMutation builder.
func (m *UpgradeTauriVersionMutation) Where(ps ...predicate.UpgradeTauriVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeTauriVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeTauriVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeTauriVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeTauriVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeTauriVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeTauriVersion).
func (m *UpgradeTauriVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeTauriVersionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.company_id != nil {
		fields = append(fields, upgradetauriversion.FieldCompanyID)
	}
	if m.tauri_id != nil {
		fields = append(fields, upgradetauriversion.FieldTauriID)
	}
	if m.cloud_file_id != nil {
		fields = append(fields, upgradetauriversion.FieldCloudFileID)
	}
	if m.install_cloud_file_id != nil {
		fields = append(fields, upgradetauriversion.FieldInstallCloudFileID)
	}
	if m.version_name != nil {
		fields = append(fields, upgradetauriversion.FieldVersionName)
	}
	if m.version_code != nil {
		fields = append(fields, upgradetauriversion.FieldVersionCode)
	}
	if m.target != nil {
		fields = append(fields, upgradetauriversion.FieldTarget)
	}
	if m.arch != nil {
		fields = append(fields, upgradetauriversion.FieldArch)
	}
	if m.signature != nil {
		fields = append(fields, upgradetauriversion.FieldSignature)
	}
	if m.description != nil {
		fields = append(fields, upgradetauriversion.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradetauriversion.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradetauriversion.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradetauriversion.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeTauriVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriversion.FieldCompanyID:
		return m.CompanyID()
	case upgradetauriversion.FieldTauriID:
		return m.TauriID()
	case upgradetauriversion.FieldCloudFileID:
		return m.CloudFileID()
	case upgradetauriversion.FieldInstallCloudFileID:
		return m.InstallCloudFileID()
	case upgradetauriversion.FieldVersionName:
		return m.VersionName()
	case upgradetauriversion.FieldVersionCode:
		return m.VersionCode()
	case upgradetauriversion.FieldTarget:
		return m.Target()
	case upgradetauriversion.FieldArch:
		return m.Arch()
	case upgradetauriversion.FieldSignature:
		return m.Signature()
	case upgradetauriversion.FieldDescription:
		return m.Description()
	case upgradetauriversion.FieldIsDel:
		return m.IsDel()
	case upgradetauriversion.FieldCreateAt:
		return m.CreateAt()
	case upgradetauriversion.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeTauriVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradetauriversion.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradetauriversion.FieldTauriID:
		return m.OldTauriID(ctx)
	case upgradetauriversion.FieldCloudFileID:
		return m.OldCloudFileID(ctx)
	case upgradetauriversion.FieldInstallCloudFileID:
		return m.OldInstallCloudFileID(ctx)
	case upgradetauriversion.FieldVersionName:
		return m.OldVersionName(ctx)
	case upgradetauriversion.FieldVersionCode:
		return m.OldVersionCode(ctx)
	case upgradetauriversion.FieldTarget:
		return m.OldTarget(ctx)
	case upgradetauriversion.FieldArch:
		return m.OldArch(ctx)
	case upgradetauriversion.FieldSignature:
		return m.OldSignature(ctx)
	case upgradetauriversion.FieldDescription:
		return m.OldDescription(ctx)
	case upgradetauriversion.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradetauriversion.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradetauriversion.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeTauriVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradetauriversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradetauriversion.FieldTauriID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTauriID(v)
		return nil
	case upgradetauriversion.FieldCloudFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudFileID(v)
		return nil
	case upgradetauriversion.FieldInstallCloudFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallCloudFileID(v)
		return nil
	case upgradetauriversion.FieldVersionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionName(v)
		return nil
	case upgradetauriversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionCode(v)
		return nil
	case upgradetauriversion.FieldTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	case upgradetauriversion.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case upgradetauriversion.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case upgradetauriversion.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradetauriversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradetauriversion.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradetauriversion.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeTauriVersionMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradetauriversion.FieldCompanyID)
	}
	if m.addtauri_id != nil {
		fields = append(fields, upgradetauriversion.FieldTauriID)
	}
	if m.addversion_code != nil {
		fields = append(fields, upgradetauriversion.FieldVersionCode)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradetauriversion.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeTauriVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradetauriversion.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradetauriversion.FieldTauriID:
		return m.AddedTauriID()
	case upgradetauriversion.FieldVersionCode:
		return m.AddedVersionCode()
	case upgradetauriversion.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTauriVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradetauriversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradetauriversion.FieldTauriID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTauriID(v)
		return nil
	case upgradetauriversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionCode(v)
		return nil
	case upgradetauriversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeTauriVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradetauriversion.FieldDescription) {
		fields = append(fields, upgradetauriversion.FieldDescription)
	}
	if m.FieldCleared(upgradetauriversion.FieldCreateAt) {
		fields = append(fields, upgradetauriversion.FieldCreateAt)
	}
	if m.FieldCleared(upgradetauriversion.FieldUpdateAt) {
		fields = append(fields, upgradetauriversion.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeTauriVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeTauriVersionMutation) ClearField(name string) error {
	switch name {
	case upgradetauriversion.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradetauriversion.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradetauriversion.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeTauriVersionMutation) ResetField(name string) error {
	switch name {
	case upgradetauriversion.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradetauriversion.FieldTauriID:
		m.ResetTauriID()
		return nil
	case upgradetauriversion.FieldCloudFileID:
		m.ResetCloudFileID()
		return nil
	case upgradetauriversion.FieldInstallCloudFileID:
		m.ResetInstallCloudFileID()
		return nil
	case upgradetauriversion.FieldVersionName:
		m.ResetVersionName()
		return nil
	case upgradetauriversion.FieldVersionCode:
		m.ResetVersionCode()
		return nil
	case upgradetauriversion.FieldTarget:
		m.ResetTarget()
		return nil
	case upgradetauriversion.FieldArch:
		m.ResetArch()
		return nil
	case upgradetauriversion.FieldSignature:
		m.ResetSignature()
		return nil
	case upgradetauriversion.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradetauriversion.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradetauriversion.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradetauriversion.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTauriVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeTauriVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeTauriVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeTauriVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeTauriVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeTauriVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeTauriVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeTauriVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeTauriVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTauriVersion edge %s", name)
}

// UpgradeTrafficPacketMutation represents an operation that mutates the UpgradeTrafficPacket nodes in the graph.
type UpgradeTrafficPacketMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	name          *string
	key           *string
	size          *int
	addsize       *int
	price         *int32
	addprice      *int32
	valid_days    *int32
	addvalid_days *int32
	status        *int32
	addstatus     *int32
	description   *string
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeTrafficPacket, error)
	predicates    []predicate.UpgradeTrafficPacket
}

var _ ent.Mutation = (*UpgradeTrafficPacketMutation)(nil)

// upgradetrafficpacketOption allows management of the mutation configuration using functional options.
type upgradetrafficpacketOption func(*UpgradeTrafficPacketMutation)

// newUpgradeTrafficPacketMutation creates new mutation for the UpgradeTrafficPacket entity.
func newUpgradeTrafficPacketMutation(c config, op Op, opts ...upgradetrafficpacketOption) *UpgradeTrafficPacketMutation {
	m := &UpgradeTrafficPacketMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeTrafficPacket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeTrafficPacketID sets the ID field of the mutation.
func withUpgradeTrafficPacketID(id uint64) upgradetrafficpacketOption {
	return func(m *UpgradeTrafficPacketMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeTrafficPacket
		)
		m.oldValue = func(ctx context.Context) (*UpgradeTrafficPacket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeTrafficPacket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeTrafficPacket sets the old UpgradeTrafficPacket of the mutation.
func withUpgradeTrafficPacket(node *UpgradeTrafficPacket) upgradetrafficpacketOption {
	return func(m *UpgradeTrafficPacketMutation) {
		m.oldValue = func(context.Context) (*UpgradeTrafficPacket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeTrafficPacketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeTrafficPacketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeTrafficPacket entities.
func (m *UpgradeTrafficPacketMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeTrafficPacketMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeTrafficPacketMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeTrafficPacket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UpgradeTrafficPacketMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeTrafficPacketMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeTrafficPacketMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *UpgradeTrafficPacketMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeTrafficPacketMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeTrafficPacketMutation) ResetKey() {
	m.key = nil
}

// SetSize sets the "size" field.
func (m *UpgradeTrafficPacketMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *UpgradeTrafficPacketMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *UpgradeTrafficPacketMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *UpgradeTrafficPacketMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *UpgradeTrafficPacketMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetPrice sets the "price" field.
func (m *UpgradeTrafficPacketMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *UpgradeTrafficPacketMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *UpgradeTrafficPacketMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *UpgradeTrafficPacketMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *UpgradeTrafficPacketMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetValidDays sets the "valid_days" field.
func (m *UpgradeTrafficPacketMutation) SetValidDays(i int32) {
	m.valid_days = &i
	m.addvalid_days = nil
}

// ValidDays returns the value of the "valid_days" field in the mutation.
func (m *UpgradeTrafficPacketMutation) ValidDays() (r int32, exists bool) {
	v := m.valid_days
	if v == nil {
		return
	}
	return *v, true
}

// OldValidDays returns the old "valid_days" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldValidDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidDays: %w", err)
	}
	return oldValue.ValidDays, nil
}

// AddValidDays adds i to the "valid_days" field.
func (m *UpgradeTrafficPacketMutation) AddValidDays(i int32) {
	if m.addvalid_days != nil {
		*m.addvalid_days += i
	} else {
		m.addvalid_days = &i
	}
}

// AddedValidDays returns the value that was added to the "valid_days" field in this mutation.
func (m *UpgradeTrafficPacketMutation) AddedValidDays() (r int32, exists bool) {
	v := m.addvalid_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidDays resets all changes to the "valid_days" field.
func (m *UpgradeTrafficPacketMutation) ResetValidDays() {
	m.valid_days = nil
	m.addvalid_days = nil
}

// SetStatus sets the "status" field.
func (m *UpgradeTrafficPacketMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UpgradeTrafficPacketMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UpgradeTrafficPacketMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UpgradeTrafficPacketMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UpgradeTrafficPacketMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeTrafficPacketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeTrafficPacketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeTrafficPacketMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradetrafficpacket.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeTrafficPacketMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradetrafficpacket.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeTrafficPacketMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradetrafficpacket.FieldDescription)
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeTrafficPacketMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeTrafficPacketMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeTrafficPacketMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradetrafficpacket.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeTrafficPacketMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradetrafficpacket.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeTrafficPacketMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradetrafficpacket.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeTrafficPacketMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeTrafficPacketMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeTrafficPacket entity.
// If the UpgradeTrafficPacket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeTrafficPacketMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeTrafficPacketMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradetrafficpacket.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeTrafficPacketMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradetrafficpacket.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeTrafficPacketMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradetrafficpacket.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeTrafficPacketMutation builder.
func (m *UpgradeTrafficPacketMutation) Where(ps ...predicate.UpgradeTrafficPacket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeTrafficPacketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeTrafficPacketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeTrafficPacket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeTrafficPacketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeTrafficPacketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeTrafficPacket).
func (m *UpgradeTrafficPacketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeTrafficPacketMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, upgradetrafficpacket.FieldName)
	}
	if m.key != nil {
		fields = append(fields, upgradetrafficpacket.FieldKey)
	}
	if m.size != nil {
		fields = append(fields, upgradetrafficpacket.FieldSize)
	}
	if m.price != nil {
		fields = append(fields, upgradetrafficpacket.FieldPrice)
	}
	if m.valid_days != nil {
		fields = append(fields, upgradetrafficpacket.FieldValidDays)
	}
	if m.status != nil {
		fields = append(fields, upgradetrafficpacket.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, upgradetrafficpacket.FieldDescription)
	}
	if m.create_at != nil {
		fields = append(fields, upgradetrafficpacket.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradetrafficpacket.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeTrafficPacketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradetrafficpacket.FieldName:
		return m.Name()
	case upgradetrafficpacket.FieldKey:
		return m.Key()
	case upgradetrafficpacket.FieldSize:
		return m.Size()
	case upgradetrafficpacket.FieldPrice:
		return m.Price()
	case upgradetrafficpacket.FieldValidDays:
		return m.ValidDays()
	case upgradetrafficpacket.FieldStatus:
		return m.Status()
	case upgradetrafficpacket.FieldDescription:
		return m.Description()
	case upgradetrafficpacket.FieldCreateAt:
		return m.CreateAt()
	case upgradetrafficpacket.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeTrafficPacketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradetrafficpacket.FieldName:
		return m.OldName(ctx)
	case upgradetrafficpacket.FieldKey:
		return m.OldKey(ctx)
	case upgradetrafficpacket.FieldSize:
		return m.OldSize(ctx)
	case upgradetrafficpacket.FieldPrice:
		return m.OldPrice(ctx)
	case upgradetrafficpacket.FieldValidDays:
		return m.OldValidDays(ctx)
	case upgradetrafficpacket.FieldStatus:
		return m.OldStatus(ctx)
	case upgradetrafficpacket.FieldDescription:
		return m.OldDescription(ctx)
	case upgradetrafficpacket.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradetrafficpacket.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeTrafficPacket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTrafficPacketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradetrafficpacket.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradetrafficpacket.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradetrafficpacket.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case upgradetrafficpacket.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case upgradetrafficpacket.FieldValidDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidDays(v)
		return nil
	case upgradetrafficpacket.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case upgradetrafficpacket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradetrafficpacket.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradetrafficpacket.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTrafficPacket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeTrafficPacketMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, upgradetrafficpacket.FieldSize)
	}
	if m.addprice != nil {
		fields = append(fields, upgradetrafficpacket.FieldPrice)
	}
	if m.addvalid_days != nil {
		fields = append(fields, upgradetrafficpacket.FieldValidDays)
	}
	if m.addstatus != nil {
		fields = append(fields, upgradetrafficpacket.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeTrafficPacketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradetrafficpacket.FieldSize:
		return m.AddedSize()
	case upgradetrafficpacket.FieldPrice:
		return m.AddedPrice()
	case upgradetrafficpacket.FieldValidDays:
		return m.AddedValidDays()
	case upgradetrafficpacket.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeTrafficPacketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradetrafficpacket.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case upgradetrafficpacket.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case upgradetrafficpacket.FieldValidDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidDays(v)
		return nil
	case upgradetrafficpacket.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeTrafficPacket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeTrafficPacketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradetrafficpacket.FieldDescription) {
		fields = append(fields, upgradetrafficpacket.FieldDescription)
	}
	if m.FieldCleared(upgradetrafficpacket.FieldCreateAt) {
		fields = append(fields, upgradetrafficpacket.FieldCreateAt)
	}
	if m.FieldCleared(upgradetrafficpacket.FieldUpdateAt) {
		fields = append(fields, upgradetrafficpacket.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeTrafficPacketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeTrafficPacketMutation) ClearField(name string) error {
	switch name {
	case upgradetrafficpacket.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradetrafficpacket.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradetrafficpacket.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTrafficPacket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeTrafficPacketMutation) ResetField(name string) error {
	switch name {
	case upgradetrafficpacket.FieldName:
		m.ResetName()
		return nil
	case upgradetrafficpacket.FieldKey:
		m.ResetKey()
		return nil
	case upgradetrafficpacket.FieldSize:
		m.ResetSize()
		return nil
	case upgradetrafficpacket.FieldPrice:
		m.ResetPrice()
		return nil
	case upgradetrafficpacket.FieldValidDays:
		m.ResetValidDays()
		return nil
	case upgradetrafficpacket.FieldStatus:
		m.ResetStatus()
		return nil
	case upgradetrafficpacket.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradetrafficpacket.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradetrafficpacket.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeTrafficPacket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeTrafficPacketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeTrafficPacketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeTrafficPacketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeTrafficPacketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeTrafficPacketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeTrafficPacketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeTrafficPacketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTrafficPacket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeTrafficPacketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeTrafficPacket edge %s", name)
}

// UpgradeUrlMutation represents an operation that mutates the UpgradeUrl nodes in the graph.
type UpgradeUrlMutation struct {
	config
	op            Op
	typ           string
	id            *int
	company_id    *int
	addcompany_id *int
	key           *string
	name          *string
	description   *string
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeUrl, error)
	predicates    []predicate.UpgradeUrl
}

var _ ent.Mutation = (*UpgradeUrlMutation)(nil)

// upgradeurlOption allows management of the mutation configuration using functional options.
type upgradeurlOption func(*UpgradeUrlMutation)

// newUpgradeUrlMutation creates new mutation for the UpgradeUrl entity.
func newUpgradeUrlMutation(c config, op Op, opts ...upgradeurlOption) *UpgradeUrlMutation {
	m := &UpgradeUrlMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeUrl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeUrlID sets the ID field of the mutation.
func withUpgradeUrlID(id int) upgradeurlOption {
	return func(m *UpgradeUrlMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeUrl
		)
		m.oldValue = func(ctx context.Context) (*UpgradeUrl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeUrl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeUrl sets the old UpgradeUrl of the mutation.
func withUpgradeUrl(node *UpgradeUrl) upgradeurlOption {
	return func(m *UpgradeUrlMutation) {
		m.oldValue = func(context.Context) (*UpgradeUrl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeUrlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeUrlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeUrl entities.
func (m *UpgradeUrlMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeUrlMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeUrlMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeUrl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeUrlMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeUrlMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeUrl entity.
// If the UpgradeUrl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeUrlMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeUrlMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeUrlMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetKey sets the "key" field.
func (m *UpgradeUrlMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UpgradeUrlMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UpgradeUrl entity.
// If the UpgradeUrl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UpgradeUrlMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UpgradeUrlMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeUrlMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeUrl entity.
// If the UpgradeUrl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeUrlMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeUrlMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeUrlMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeUrl entity.
// If the UpgradeUrl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeUrlMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeurl.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeUrlMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeurl.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeUrlMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeurl.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeUrlMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeUrlMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeUrl entity.
// If the UpgradeUrl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeUrlMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeUrlMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeUrlMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeUrlMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeUrlMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeUrl entity.
// If the UpgradeUrl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeUrlMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeurl.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeUrlMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurl.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeUrlMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeurl.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeUrlMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeUrlMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeUrl entity.
// If the UpgradeUrl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeUrlMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeurl.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeUrlMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurl.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeUrlMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeurl.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeUrlMutation builder.
func (m *UpgradeUrlMutation) Where(ps ...predicate.UpgradeUrl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeUrlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeUrlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeUrl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeUrlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeUrlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeUrl).
func (m *UpgradeUrlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeUrlMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.company_id != nil {
		fields = append(fields, upgradeurl.FieldCompanyID)
	}
	if m.key != nil {
		fields = append(fields, upgradeurl.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, upgradeurl.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradeurl.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeurl.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeurl.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeurl.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeUrlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeurl.FieldCompanyID:
		return m.CompanyID()
	case upgradeurl.FieldKey:
		return m.Key()
	case upgradeurl.FieldName:
		return m.Name()
	case upgradeurl.FieldDescription:
		return m.Description()
	case upgradeurl.FieldIsDel:
		return m.IsDel()
	case upgradeurl.FieldCreateAt:
		return m.CreateAt()
	case upgradeurl.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeUrlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeurl.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeurl.FieldKey:
		return m.OldKey(ctx)
	case upgradeurl.FieldName:
		return m.OldName(ctx)
	case upgradeurl.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeurl.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeurl.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeurl.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeUrl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeurl.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeurl.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case upgradeurl.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeurl.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeurl.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeurl.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeurl.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeUrlMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeurl.FieldCompanyID)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeurl.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeUrlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeurl.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeurl.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeurl.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeurl.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeUrlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeurl.FieldDescription) {
		fields = append(fields, upgradeurl.FieldDescription)
	}
	if m.FieldCleared(upgradeurl.FieldCreateAt) {
		fields = append(fields, upgradeurl.FieldCreateAt)
	}
	if m.FieldCleared(upgradeurl.FieldUpdateAt) {
		fields = append(fields, upgradeurl.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeUrlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeUrlMutation) ClearField(name string) error {
	switch name {
	case upgradeurl.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeurl.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeurl.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeUrlMutation) ResetField(name string) error {
	switch name {
	case upgradeurl.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeurl.FieldKey:
		m.ResetKey()
		return nil
	case upgradeurl.FieldName:
		m.ResetName()
		return nil
	case upgradeurl.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeurl.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeurl.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeurl.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeUrlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeUrlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeUrlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeUrlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeUrlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeUrlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeUrlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeUrlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrl edge %s", name)
}

// UpgradeUrlUpgradeStrategyMutation represents an operation that mutates the UpgradeUrlUpgradeStrategy nodes in the graph.
type UpgradeUrlUpgradeStrategyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	company_id              *int
	addcompany_id           *int
	enable                  *int32
	addenable               *int32
	name                    *string
	description             *string
	url_id                  *int
	addurl_id               *int
	url_version_id          *int
	addurl_version_id       *int
	begin_datetime          *time.Time
	end_datetime            *time.Time
	upgrade_type            *int32
	addupgrade_type         *int32
	prompt_upgrade_content  *string
	upgrade_dev_type        *int32
	addupgrade_dev_type     *int32
	upgrade_dev_data        *string
	upgrade_version_type    *int32
	addupgrade_version_type *int32
	upgrade_version_data    *string
	is_gray                 *int32
	addis_gray              *int32
	gray_data               *string
	is_flow_limit           *int32
	addis_flow_limit        *int32
	flow_limit_data         *string
	is_del                  *int32
	addis_del               *int32
	create_at               *time.Time
	update_at               *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*UpgradeUrlUpgradeStrategy, error)
	predicates              []predicate.UpgradeUrlUpgradeStrategy
}

var _ ent.Mutation = (*UpgradeUrlUpgradeStrategyMutation)(nil)

// upgradeurlupgradestrategyOption allows management of the mutation configuration using functional options.
type upgradeurlupgradestrategyOption func(*UpgradeUrlUpgradeStrategyMutation)

// newUpgradeUrlUpgradeStrategyMutation creates new mutation for the UpgradeUrlUpgradeStrategy entity.
func newUpgradeUrlUpgradeStrategyMutation(c config, op Op, opts ...upgradeurlupgradestrategyOption) *UpgradeUrlUpgradeStrategyMutation {
	m := &UpgradeUrlUpgradeStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeUrlUpgradeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeUrlUpgradeStrategyID sets the ID field of the mutation.
func withUpgradeUrlUpgradeStrategyID(id int) upgradeurlupgradestrategyOption {
	return func(m *UpgradeUrlUpgradeStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeUrlUpgradeStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeUrlUpgradeStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeUrlUpgradeStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeUrlUpgradeStrategy sets the old UpgradeUrlUpgradeStrategy of the mutation.
func withUpgradeUrlUpgradeStrategy(node *UpgradeUrlUpgradeStrategy) upgradeurlupgradestrategyOption {
	return func(m *UpgradeUrlUpgradeStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeUrlUpgradeStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeUrlUpgradeStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeUrlUpgradeStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeUrlUpgradeStrategy entities.
func (m *UpgradeUrlUpgradeStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeUrlUpgradeStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeUrlUpgradeStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetEnable sets the "enable" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetName sets the "name" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeurlupgradestrategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeurlupgradestrategy.FieldDescription)
}

// SetURLID sets the "url_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetURLID(i int) {
	m.url_id = &i
	m.addurl_id = nil
}

// URLID returns the value of the "url_id" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) URLID() (r int, exists bool) {
	v := m.url_id
	if v == nil {
		return
	}
	return *v, true
}

// OldURLID returns the old "url_id" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldURLID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLID: %w", err)
	}
	return oldValue.URLID, nil
}

// AddURLID adds i to the "url_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddURLID(i int) {
	if m.addurl_id != nil {
		*m.addurl_id += i
	} else {
		m.addurl_id = &i
	}
}

// AddedURLID returns the value that was added to the "url_id" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedURLID() (r int, exists bool) {
	v := m.addurl_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetURLID resets all changes to the "url_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetURLID() {
	m.url_id = nil
	m.addurl_id = nil
}

// SetURLVersionID sets the "url_version_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetURLVersionID(i int) {
	m.url_version_id = &i
	m.addurl_version_id = nil
}

// URLVersionID returns the value of the "url_version_id" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) URLVersionID() (r int, exists bool) {
	v := m.url_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldURLVersionID returns the old "url_version_id" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldURLVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLVersionID: %w", err)
	}
	return oldValue.URLVersionID, nil
}

// AddURLVersionID adds i to the "url_version_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddURLVersionID(i int) {
	if m.addurl_version_id != nil {
		*m.addurl_version_id += i
	} else {
		m.addurl_version_id = &i
	}
}

// AddedURLVersionID returns the value that was added to the "url_version_id" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedURLVersionID() (r int, exists bool) {
	v := m.addurl_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetURLVersionID resets all changes to the "url_version_id" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetURLVersionID() {
	m.url_version_id = nil
	m.addurl_version_id = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetUpgradeType sets the "upgrade_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetUpgradeType(i int32) {
	m.upgrade_type = &i
	m.addupgrade_type = nil
}

// UpgradeType returns the value of the "upgrade_type" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) UpgradeType() (r int32, exists bool) {
	v := m.upgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeType returns the old "upgrade_type" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldUpgradeType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeType: %w", err)
	}
	return oldValue.UpgradeType, nil
}

// AddUpgradeType adds i to the "upgrade_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddUpgradeType(i int32) {
	if m.addupgrade_type != nil {
		*m.addupgrade_type += i
	} else {
		m.addupgrade_type = &i
	}
}

// AddedUpgradeType returns the value that was added to the "upgrade_type" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedUpgradeType() (r int32, exists bool) {
	v := m.addupgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeType resets all changes to the "upgrade_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetUpgradeType() {
	m.upgrade_type = nil
	m.addupgrade_type = nil
}

// SetPromptUpgradeContent sets the "prompt_upgrade_content" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetPromptUpgradeContent(s string) {
	m.prompt_upgrade_content = &s
}

// PromptUpgradeContent returns the value of the "prompt_upgrade_content" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) PromptUpgradeContent() (r string, exists bool) {
	v := m.prompt_upgrade_content
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptUpgradeContent returns the old "prompt_upgrade_content" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldPromptUpgradeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptUpgradeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptUpgradeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptUpgradeContent: %w", err)
	}
	return oldValue.PromptUpgradeContent, nil
}

// ClearPromptUpgradeContent clears the value of the "prompt_upgrade_content" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	m.clearedFields[upgradeurlupgradestrategy.FieldPromptUpgradeContent] = struct{}{}
}

// PromptUpgradeContentCleared returns if the "prompt_upgrade_content" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) PromptUpgradeContentCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategy.FieldPromptUpgradeContent]
	return ok
}

// ResetPromptUpgradeContent resets all changes to the "prompt_upgrade_content" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetPromptUpgradeContent() {
	m.prompt_upgrade_content = nil
	delete(m.clearedFields, upgradeurlupgradestrategy.FieldPromptUpgradeContent)
}

// SetUpgradeDevType sets the "upgrade_dev_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetUpgradeDevType(i int32) {
	m.upgrade_dev_type = &i
	m.addupgrade_dev_type = nil
}

// UpgradeDevType returns the value of the "upgrade_dev_type" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) UpgradeDevType() (r int32, exists bool) {
	v := m.upgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevType returns the old "upgrade_dev_type" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldUpgradeDevType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevType: %w", err)
	}
	return oldValue.UpgradeDevType, nil
}

// AddUpgradeDevType adds i to the "upgrade_dev_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddUpgradeDevType(i int32) {
	if m.addupgrade_dev_type != nil {
		*m.addupgrade_dev_type += i
	} else {
		m.addupgrade_dev_type = &i
	}
}

// AddedUpgradeDevType returns the value that was added to the "upgrade_dev_type" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedUpgradeDevType() (r int32, exists bool) {
	v := m.addupgrade_dev_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeDevType resets all changes to the "upgrade_dev_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetUpgradeDevType() {
	m.upgrade_dev_type = nil
	m.addupgrade_dev_type = nil
}

// SetUpgradeDevData sets the "upgrade_dev_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetUpgradeDevData(s string) {
	m.upgrade_dev_data = &s
}

// UpgradeDevData returns the value of the "upgrade_dev_data" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) UpgradeDevData() (r string, exists bool) {
	v := m.upgrade_dev_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeDevData returns the old "upgrade_dev_data" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldUpgradeDevData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeDevData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeDevData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeDevData: %w", err)
	}
	return oldValue.UpgradeDevData, nil
}

// ResetUpgradeDevData resets all changes to the "upgrade_dev_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetUpgradeDevData() {
	m.upgrade_dev_data = nil
}

// SetUpgradeVersionType sets the "upgrade_version_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetUpgradeVersionType(i int32) {
	m.upgrade_version_type = &i
	m.addupgrade_version_type = nil
}

// UpgradeVersionType returns the value of the "upgrade_version_type" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) UpgradeVersionType() (r int32, exists bool) {
	v := m.upgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionType returns the old "upgrade_version_type" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldUpgradeVersionType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionType: %w", err)
	}
	return oldValue.UpgradeVersionType, nil
}

// AddUpgradeVersionType adds i to the "upgrade_version_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddUpgradeVersionType(i int32) {
	if m.addupgrade_version_type != nil {
		*m.addupgrade_version_type += i
	} else {
		m.addupgrade_version_type = &i
	}
}

// AddedUpgradeVersionType returns the value that was added to the "upgrade_version_type" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedUpgradeVersionType() (r int32, exists bool) {
	v := m.addupgrade_version_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpgradeVersionType resets all changes to the "upgrade_version_type" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetUpgradeVersionType() {
	m.upgrade_version_type = nil
	m.addupgrade_version_type = nil
}

// SetUpgradeVersionData sets the "upgrade_version_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetUpgradeVersionData(s string) {
	m.upgrade_version_data = &s
}

// UpgradeVersionData returns the value of the "upgrade_version_data" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) UpgradeVersionData() (r string, exists bool) {
	v := m.upgrade_version_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpgradeVersionData returns the old "upgrade_version_data" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldUpgradeVersionData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpgradeVersionData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpgradeVersionData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpgradeVersionData: %w", err)
	}
	return oldValue.UpgradeVersionData, nil
}

// ResetUpgradeVersionData resets all changes to the "upgrade_version_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetUpgradeVersionData() {
	m.upgrade_version_data = nil
}

// SetIsGray sets the "is_gray" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetIsGray(i int32) {
	m.is_gray = &i
	m.addis_gray = nil
}

// IsGray returns the value of the "is_gray" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) IsGray() (r int32, exists bool) {
	v := m.is_gray
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGray returns the old "is_gray" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldIsGray(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGray is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGray requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGray: %w", err)
	}
	return oldValue.IsGray, nil
}

// AddIsGray adds i to the "is_gray" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddIsGray(i int32) {
	if m.addis_gray != nil {
		*m.addis_gray += i
	} else {
		m.addis_gray = &i
	}
}

// AddedIsGray returns the value that was added to the "is_gray" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedIsGray() (r int32, exists bool) {
	v := m.addis_gray
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsGray resets all changes to the "is_gray" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetIsGray() {
	m.is_gray = nil
	m.addis_gray = nil
}

// SetGrayData sets the "gray_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetGrayData(s string) {
	m.gray_data = &s
}

// GrayData returns the value of the "gray_data" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) GrayData() (r string, exists bool) {
	v := m.gray_data
	if v == nil {
		return
	}
	return *v, true
}

// OldGrayData returns the old "gray_data" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldGrayData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrayData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrayData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrayData: %w", err)
	}
	return oldValue.GrayData, nil
}

// ResetGrayData resets all changes to the "gray_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetGrayData() {
	m.gray_data = nil
}

// SetIsFlowLimit sets the "is_flow_limit" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetIsFlowLimit(i int32) {
	m.is_flow_limit = &i
	m.addis_flow_limit = nil
}

// IsFlowLimit returns the value of the "is_flow_limit" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) IsFlowLimit() (r int32, exists bool) {
	v := m.is_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlowLimit returns the old "is_flow_limit" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldIsFlowLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlowLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlowLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlowLimit: %w", err)
	}
	return oldValue.IsFlowLimit, nil
}

// AddIsFlowLimit adds i to the "is_flow_limit" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddIsFlowLimit(i int32) {
	if m.addis_flow_limit != nil {
		*m.addis_flow_limit += i
	} else {
		m.addis_flow_limit = &i
	}
}

// AddedIsFlowLimit returns the value that was added to the "is_flow_limit" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedIsFlowLimit() (r int32, exists bool) {
	v := m.addis_flow_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFlowLimit resets all changes to the "is_flow_limit" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetIsFlowLimit() {
	m.is_flow_limit = nil
	m.addis_flow_limit = nil
}

// SetFlowLimitData sets the "flow_limit_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetFlowLimitData(s string) {
	m.flow_limit_data = &s
}

// FlowLimitData returns the value of the "flow_limit_data" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) FlowLimitData() (r string, exists bool) {
	v := m.flow_limit_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowLimitData returns the old "flow_limit_data" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldFlowLimitData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowLimitData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowLimitData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowLimitData: %w", err)
	}
	return oldValue.FlowLimitData, nil
}

// ResetFlowLimitData resets all changes to the "flow_limit_data" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetFlowLimitData() {
	m.flow_limit_data = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeurlupgradestrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeurlupgradestrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeUrlUpgradeStrategy entity.
// If the UpgradeUrlUpgradeStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeurlupgradestrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeurlupgradestrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeUrlUpgradeStrategyMutation builder.
func (m *UpgradeUrlUpgradeStrategyMutation) Where(ps ...predicate.UpgradeUrlUpgradeStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeUrlUpgradeStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeUrlUpgradeStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeUrlUpgradeStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeUrlUpgradeStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeUrlUpgradeStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeUrlUpgradeStrategy).
func (m *UpgradeUrlUpgradeStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeUrlUpgradeStrategyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.company_id != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldCompanyID)
	}
	if m.enable != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldDescription)
	}
	if m.url_id != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldURLID)
	}
	if m.url_version_id != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldURLVersionID)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldEndDatetime)
	}
	if m.upgrade_type != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeType)
	}
	if m.prompt_upgrade_content != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.upgrade_dev_type != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeDevType)
	}
	if m.upgrade_dev_data != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeDevData)
	}
	if m.upgrade_version_type != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeVersionType)
	}
	if m.upgrade_version_data != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeVersionData)
	}
	if m.is_gray != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldIsGray)
	}
	if m.gray_data != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldGrayData)
	}
	if m.is_flow_limit != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldIsFlowLimit)
	}
	if m.flow_limit_data != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldFlowLimitData)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeUrlUpgradeStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlupgradestrategy.FieldCompanyID:
		return m.CompanyID()
	case upgradeurlupgradestrategy.FieldEnable:
		return m.Enable()
	case upgradeurlupgradestrategy.FieldName:
		return m.Name()
	case upgradeurlupgradestrategy.FieldDescription:
		return m.Description()
	case upgradeurlupgradestrategy.FieldURLID:
		return m.URLID()
	case upgradeurlupgradestrategy.FieldURLVersionID:
		return m.URLVersionID()
	case upgradeurlupgradestrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeurlupgradestrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeurlupgradestrategy.FieldUpgradeType:
		return m.UpgradeType()
	case upgradeurlupgradestrategy.FieldPromptUpgradeContent:
		return m.PromptUpgradeContent()
	case upgradeurlupgradestrategy.FieldUpgradeDevType:
		return m.UpgradeDevType()
	case upgradeurlupgradestrategy.FieldUpgradeDevData:
		return m.UpgradeDevData()
	case upgradeurlupgradestrategy.FieldUpgradeVersionType:
		return m.UpgradeVersionType()
	case upgradeurlupgradestrategy.FieldUpgradeVersionData:
		return m.UpgradeVersionData()
	case upgradeurlupgradestrategy.FieldIsGray:
		return m.IsGray()
	case upgradeurlupgradestrategy.FieldGrayData:
		return m.GrayData()
	case upgradeurlupgradestrategy.FieldIsFlowLimit:
		return m.IsFlowLimit()
	case upgradeurlupgradestrategy.FieldFlowLimitData:
		return m.FlowLimitData()
	case upgradeurlupgradestrategy.FieldIsDel:
		return m.IsDel()
	case upgradeurlupgradestrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeurlupgradestrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeUrlUpgradeStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeurlupgradestrategy.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeurlupgradestrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeurlupgradestrategy.FieldName:
		return m.OldName(ctx)
	case upgradeurlupgradestrategy.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeurlupgradestrategy.FieldURLID:
		return m.OldURLID(ctx)
	case upgradeurlupgradestrategy.FieldURLVersionID:
		return m.OldURLVersionID(ctx)
	case upgradeurlupgradestrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeurlupgradestrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeurlupgradestrategy.FieldUpgradeType:
		return m.OldUpgradeType(ctx)
	case upgradeurlupgradestrategy.FieldPromptUpgradeContent:
		return m.OldPromptUpgradeContent(ctx)
	case upgradeurlupgradestrategy.FieldUpgradeDevType:
		return m.OldUpgradeDevType(ctx)
	case upgradeurlupgradestrategy.FieldUpgradeDevData:
		return m.OldUpgradeDevData(ctx)
	case upgradeurlupgradestrategy.FieldUpgradeVersionType:
		return m.OldUpgradeVersionType(ctx)
	case upgradeurlupgradestrategy.FieldUpgradeVersionData:
		return m.OldUpgradeVersionData(ctx)
	case upgradeurlupgradestrategy.FieldIsGray:
		return m.OldIsGray(ctx)
	case upgradeurlupgradestrategy.FieldGrayData:
		return m.OldGrayData(ctx)
	case upgradeurlupgradestrategy.FieldIsFlowLimit:
		return m.OldIsFlowLimit(ctx)
	case upgradeurlupgradestrategy.FieldFlowLimitData:
		return m.OldFlowLimitData(ctx)
	case upgradeurlupgradestrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeurlupgradestrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeurlupgradestrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeUrlUpgradeStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlUpgradeStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeurlupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeurlupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeurlupgradestrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upgradeurlupgradestrategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeurlupgradestrategy.FieldURLID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLID(v)
		return nil
	case upgradeurlupgradestrategy.FieldURLVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLVersionID(v)
		return nil
	case upgradeurlupgradestrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeurlupgradestrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeType(v)
		return nil
	case upgradeurlupgradestrategy.FieldPromptUpgradeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptUpgradeContent(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevType(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeDevData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeDevData(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionType(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeVersionData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpgradeVersionData(v)
		return nil
	case upgradeurlupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGray(v)
		return nil
	case upgradeurlupgradestrategy.FieldGrayData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrayData(v)
		return nil
	case upgradeurlupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlowLimit(v)
		return nil
	case upgradeurlupgradestrategy.FieldFlowLimitData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowLimitData(v)
		return nil
	case upgradeurlupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeurlupgradestrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldCompanyID)
	}
	if m.addenable != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldEnable)
	}
	if m.addurl_id != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldURLID)
	}
	if m.addurl_version_id != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldURLVersionID)
	}
	if m.addupgrade_type != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeType)
	}
	if m.addupgrade_dev_type != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeDevType)
	}
	if m.addupgrade_version_type != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpgradeVersionType)
	}
	if m.addis_gray != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldIsGray)
	}
	if m.addis_flow_limit != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldIsFlowLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeurlupgradestrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlupgradestrategy.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeurlupgradestrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeurlupgradestrategy.FieldURLID:
		return m.AddedURLID()
	case upgradeurlupgradestrategy.FieldURLVersionID:
		return m.AddedURLVersionID()
	case upgradeurlupgradestrategy.FieldUpgradeType:
		return m.AddedUpgradeType()
	case upgradeurlupgradestrategy.FieldUpgradeDevType:
		return m.AddedUpgradeDevType()
	case upgradeurlupgradestrategy.FieldUpgradeVersionType:
		return m.AddedUpgradeVersionType()
	case upgradeurlupgradestrategy.FieldIsGray:
		return m.AddedIsGray()
	case upgradeurlupgradestrategy.FieldIsFlowLimit:
		return m.AddedIsFlowLimit()
	case upgradeurlupgradestrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlUpgradeStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeurlupgradestrategy.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeurlupgradestrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeurlupgradestrategy.FieldURLID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddURLID(v)
		return nil
	case upgradeurlupgradestrategy.FieldURLVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddURLVersionID(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeType(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeDevType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeDevType(v)
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeVersionType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpgradeVersionType(v)
		return nil
	case upgradeurlupgradestrategy.FieldIsGray:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsGray(v)
		return nil
	case upgradeurlupgradestrategy.FieldIsFlowLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFlowLimit(v)
		return nil
	case upgradeurlupgradestrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeurlupgradestrategy.FieldDescription) {
		fields = append(fields, upgradeurlupgradestrategy.FieldDescription)
	}
	if m.FieldCleared(upgradeurlupgradestrategy.FieldPromptUpgradeContent) {
		fields = append(fields, upgradeurlupgradestrategy.FieldPromptUpgradeContent)
	}
	if m.FieldCleared(upgradeurlupgradestrategy.FieldCreateAt) {
		fields = append(fields, upgradeurlupgradestrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeurlupgradestrategy.FieldUpdateAt) {
		fields = append(fields, upgradeurlupgradestrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeurlupgradestrategy.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeurlupgradestrategy.FieldPromptUpgradeContent:
		m.ClearPromptUpgradeContent()
		return nil
	case upgradeurlupgradestrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeurlupgradestrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeurlupgradestrategy.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeurlupgradestrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeurlupgradestrategy.FieldName:
		m.ResetName()
		return nil
	case upgradeurlupgradestrategy.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeurlupgradestrategy.FieldURLID:
		m.ResetURLID()
		return nil
	case upgradeurlupgradestrategy.FieldURLVersionID:
		m.ResetURLVersionID()
		return nil
	case upgradeurlupgradestrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeurlupgradestrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeType:
		m.ResetUpgradeType()
		return nil
	case upgradeurlupgradestrategy.FieldPromptUpgradeContent:
		m.ResetPromptUpgradeContent()
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeDevType:
		m.ResetUpgradeDevType()
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeDevData:
		m.ResetUpgradeDevData()
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeVersionType:
		m.ResetUpgradeVersionType()
		return nil
	case upgradeurlupgradestrategy.FieldUpgradeVersionData:
		m.ResetUpgradeVersionData()
		return nil
	case upgradeurlupgradestrategy.FieldIsGray:
		m.ResetIsGray()
		return nil
	case upgradeurlupgradestrategy.FieldGrayData:
		m.ResetGrayData()
		return nil
	case upgradeurlupgradestrategy.FieldIsFlowLimit:
		m.ResetIsFlowLimit()
		return nil
	case upgradeurlupgradestrategy.FieldFlowLimitData:
		m.ResetFlowLimitData()
		return nil
	case upgradeurlupgradestrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeurlupgradestrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeurlupgradestrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategy edge %s", name)
}

// UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation represents an operation that mutates the UpgradeUrlUpgradeStrategyFlowLimitStrategy nodes in the graph.
type UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	enable        *int32
	addenable     *int32
	begin_time    *string
	end_time      *string
	dimension     *int32
	adddimension  *int32
	_limit        *int
	add_limit     *int
	is_del        *int32
	addis_del     *int32
	create_at     *time.Time
	update_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpgradeUrlUpgradeStrategyFlowLimitStrategy, error)
	predicates    []predicate.UpgradeUrlUpgradeStrategyFlowLimitStrategy
}

var _ ent.Mutation = (*UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation)(nil)

// upgradeurlupgradestrategyflowlimitstrategyOption allows management of the mutation configuration using functional options.
type upgradeurlupgradestrategyflowlimitstrategyOption func(*UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation)

// newUpgradeUrlUpgradeStrategyFlowLimitStrategyMutation creates new mutation for the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
func newUpgradeUrlUpgradeStrategyFlowLimitStrategyMutation(c config, op Op, opts ...upgradeurlupgradestrategyflowlimitstrategyOption) *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation {
	m := &UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeUrlUpgradeStrategyFlowLimitStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeUrlUpgradeStrategyFlowLimitStrategyID sets the ID field of the mutation.
func withUpgradeUrlUpgradeStrategyFlowLimitStrategyID(id int) upgradeurlupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeUrlUpgradeStrategyFlowLimitStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeUrlUpgradeStrategyFlowLimitStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeUrlUpgradeStrategyFlowLimitStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeUrlUpgradeStrategyFlowLimitStrategy sets the old UpgradeUrlUpgradeStrategyFlowLimitStrategy of the mutation.
func withUpgradeUrlUpgradeStrategyFlowLimitStrategy(node *UpgradeUrlUpgradeStrategyFlowLimitStrategy) upgradeurlupgradestrategyflowlimitstrategyOption {
	return func(m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeUrlUpgradeStrategyFlowLimitStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeUrlUpgradeStrategyFlowLimitStrategy entities.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeUrlUpgradeStrategyFlowLimitStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginTime sets the "begin_time" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetBeginTime(s string) {
	m.begin_time = &s
}

// BeginTime returns the value of the "begin_time" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) BeginTime() (r string, exists bool) {
	v := m.begin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "begin_time" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldBeginTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "begin_time" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetBeginTime() {
	m.begin_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDimension sets the "dimension" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetDimension(i int32) {
	m.dimension = &i
	m.adddimension = nil
}

// Dimension returns the value of the "dimension" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Dimension() (r int32, exists bool) {
	v := m.dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldDimension returns the old "dimension" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldDimension(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimension: %w", err)
	}
	return oldValue.Dimension, nil
}

// AddDimension adds i to the "dimension" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddDimension(i int32) {
	if m.adddimension != nil {
		*m.adddimension += i
	} else {
		m.adddimension = &i
	}
}

// AddedDimension returns the value that was added to the "dimension" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedDimension() (r int32, exists bool) {
	v := m.adddimension
	if v == nil {
		return
	}
	return *v, true
}

// ResetDimension resets all changes to the "dimension" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetDimension() {
	m.dimension = nil
	m.adddimension = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeUrlUpgradeStrategyFlowLimitStrategy entity.
// If the UpgradeUrlUpgradeStrategyFlowLimitStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation builder.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Where(ps ...predicate.UpgradeUrlUpgradeStrategyFlowLimitStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeUrlUpgradeStrategyFlowLimitStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeUrlUpgradeStrategyFlowLimitStrategy).
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.enable != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.begin_time != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldBeginTime)
	}
	if m.end_time != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldEndTime)
	}
	if m.dimension != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m._limit != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEnable:
		return m.Enable()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.BeginTime()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.EndTime()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldDimension:
		return m.Dimension()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldLimit:
		return m.Limit()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.IsDel()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeurlupgradestrategyflowlimitstrategy.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEndTime:
		return m.OldEndTime(ctx)
	case upgradeurlupgradestrategyflowlimitstrategy.FieldDimension:
		return m.OldDimension(ctx)
	case upgradeurlupgradestrategyflowlimitstrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeUrlUpgradeStrategyFlowLimitStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldBeginTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimension(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldEnable)
	}
	if m.adddimension != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldDimension)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldDimension:
		return m.AddedDimension()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldDimension:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimension(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyFlowLimitStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt) {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt) {
		fields = append(fields, upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyFlowLimitStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldEndTime:
		m.ResetEndTime()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldDimension:
		m.ResetDimension()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeurlupgradestrategyflowlimitstrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyFlowLimitStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyFlowLimitStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyFlowLimitStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyFlowLimitStrategy edge %s", name)
}

// UpgradeUrlUpgradeStrategyGrayStrategyMutation represents an operation that mutates the UpgradeUrlUpgradeStrategyGrayStrategy nodes in the graph.
type UpgradeUrlUpgradeStrategyGrayStrategyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	enable         *int32
	addenable      *int32
	begin_datetime *time.Time
	end_datetime   *time.Time
	_limit         *int
	add_limit      *int
	is_del         *int32
	addis_del      *int32
	create_at      *time.Time
	update_at      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UpgradeUrlUpgradeStrategyGrayStrategy, error)
	predicates     []predicate.UpgradeUrlUpgradeStrategyGrayStrategy
}

var _ ent.Mutation = (*UpgradeUrlUpgradeStrategyGrayStrategyMutation)(nil)

// upgradeurlupgradestrategygraystrategyOption allows management of the mutation configuration using functional options.
type upgradeurlupgradestrategygraystrategyOption func(*UpgradeUrlUpgradeStrategyGrayStrategyMutation)

// newUpgradeUrlUpgradeStrategyGrayStrategyMutation creates new mutation for the UpgradeUrlUpgradeStrategyGrayStrategy entity.
func newUpgradeUrlUpgradeStrategyGrayStrategyMutation(c config, op Op, opts ...upgradeurlupgradestrategygraystrategyOption) *UpgradeUrlUpgradeStrategyGrayStrategyMutation {
	m := &UpgradeUrlUpgradeStrategyGrayStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeUrlUpgradeStrategyGrayStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeUrlUpgradeStrategyGrayStrategyID sets the ID field of the mutation.
func withUpgradeUrlUpgradeStrategyGrayStrategyID(id int) upgradeurlupgradestrategygraystrategyOption {
	return func(m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeUrlUpgradeStrategyGrayStrategy
		)
		m.oldValue = func(ctx context.Context) (*UpgradeUrlUpgradeStrategyGrayStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeUrlUpgradeStrategyGrayStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeUrlUpgradeStrategyGrayStrategy sets the old UpgradeUrlUpgradeStrategyGrayStrategy of the mutation.
func withUpgradeUrlUpgradeStrategyGrayStrategy(node *UpgradeUrlUpgradeStrategyGrayStrategy) upgradeurlupgradestrategygraystrategyOption {
	return func(m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) {
		m.oldValue = func(context.Context) (*UpgradeUrlUpgradeStrategyGrayStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeUrlUpgradeStrategyGrayStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeUrlUpgradeStrategyGrayStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeUrlUpgradeStrategyGrayStrategy entities.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeUrlUpgradeStrategyGrayStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetEnable(i int32) {
	m.enable = &i
	m.addenable = nil
}

// Enable returns the value of the "enable" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) Enable() (r int32, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the UpgradeUrlUpgradeStrategyGrayStrategy entity.
// If the UpgradeUrlUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldEnable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// AddEnable adds i to the "enable" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddEnable(i int32) {
	if m.addenable != nil {
		*m.addenable += i
	} else {
		m.addenable = &i
	}
}

// AddedEnable returns the value that was added to the "enable" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddedEnable() (r int32, exists bool) {
	v := m.addenable
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnable resets all changes to the "enable" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetEnable() {
	m.enable = nil
	m.addenable = nil
}

// SetBeginDatetime sets the "begin_datetime" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetBeginDatetime(t time.Time) {
	m.begin_datetime = &t
}

// BeginDatetime returns the value of the "begin_datetime" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) BeginDatetime() (r time.Time, exists bool) {
	v := m.begin_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginDatetime returns the old "begin_datetime" field's value of the UpgradeUrlUpgradeStrategyGrayStrategy entity.
// If the UpgradeUrlUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldBeginDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginDatetime: %w", err)
	}
	return oldValue.BeginDatetime, nil
}

// ResetBeginDatetime resets all changes to the "begin_datetime" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetBeginDatetime() {
	m.begin_datetime = nil
}

// SetEndDatetime sets the "end_datetime" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetEndDatetime(t time.Time) {
	m.end_datetime = &t
}

// EndDatetime returns the value of the "end_datetime" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) EndDatetime() (r time.Time, exists bool) {
	v := m.end_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDatetime returns the old "end_datetime" field's value of the UpgradeUrlUpgradeStrategyGrayStrategy entity.
// If the UpgradeUrlUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldEndDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDatetime: %w", err)
	}
	return oldValue.EndDatetime, nil
}

// ResetEndDatetime resets all changes to the "end_datetime" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetEndDatetime() {
	m.end_datetime = nil
}

// SetLimit sets the "limit" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetLimit(i int) {
	m._limit = &i
	m.add_limit = nil
}

// Limit returns the value of the "limit" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) Limit() (r int, exists bool) {
	v := m._limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLimit returns the old "limit" field's value of the UpgradeUrlUpgradeStrategyGrayStrategy entity.
// If the UpgradeUrlUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimit: %w", err)
	}
	return oldValue.Limit, nil
}

// AddLimit adds i to the "limit" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddLimit(i int) {
	if m.add_limit != nil {
		*m.add_limit += i
	} else {
		m.add_limit = &i
	}
}

// AddedLimit returns the value that was added to the "limit" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddedLimit() (r int, exists bool) {
	v := m.add_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimit resets all changes to the "limit" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetLimit() {
	m._limit = nil
	m.add_limit = nil
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeUrlUpgradeStrategyGrayStrategy entity.
// If the UpgradeUrlUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeUrlUpgradeStrategyGrayStrategy entity.
// If the UpgradeUrlUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeurlupgradestrategygraystrategy.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategygraystrategy.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeurlupgradestrategygraystrategy.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeUrlUpgradeStrategyGrayStrategy entity.
// If the UpgradeUrlUpgradeStrategyGrayStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeurlupgradestrategygraystrategy.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlupgradestrategygraystrategy.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeurlupgradestrategygraystrategy.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeUrlUpgradeStrategyGrayStrategyMutation builder.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) Where(ps ...predicate.UpgradeUrlUpgradeStrategyGrayStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeUrlUpgradeStrategyGrayStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeUrlUpgradeStrategyGrayStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeUrlUpgradeStrategyGrayStrategy).
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.enable != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldEnable)
	}
	if m.begin_datetime != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldBeginDatetime)
	}
	if m.end_datetime != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldEndDatetime)
	}
	if m._limit != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldLimit)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlupgradestrategygraystrategy.FieldEnable:
		return m.Enable()
	case upgradeurlupgradestrategygraystrategy.FieldBeginDatetime:
		return m.BeginDatetime()
	case upgradeurlupgradestrategygraystrategy.FieldEndDatetime:
		return m.EndDatetime()
	case upgradeurlupgradestrategygraystrategy.FieldLimit:
		return m.Limit()
	case upgradeurlupgradestrategygraystrategy.FieldIsDel:
		return m.IsDel()
	case upgradeurlupgradestrategygraystrategy.FieldCreateAt:
		return m.CreateAt()
	case upgradeurlupgradestrategygraystrategy.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeurlupgradestrategygraystrategy.FieldEnable:
		return m.OldEnable(ctx)
	case upgradeurlupgradestrategygraystrategy.FieldBeginDatetime:
		return m.OldBeginDatetime(ctx)
	case upgradeurlupgradestrategygraystrategy.FieldEndDatetime:
		return m.OldEndDatetime(ctx)
	case upgradeurlupgradestrategygraystrategy.FieldLimit:
		return m.OldLimit(ctx)
	case upgradeurlupgradestrategygraystrategy.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeurlupgradestrategygraystrategy.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeurlupgradestrategygraystrategy.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeUrlUpgradeStrategyGrayStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeurlupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldBeginDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginDatetime(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldEndDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDatetime(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimit(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyGrayStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addenable != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldEnable)
	}
	if m.add_limit != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldLimit)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlupgradestrategygraystrategy.FieldEnable:
		return m.AddedEnable()
	case upgradeurlupgradestrategygraystrategy.FieldLimit:
		return m.AddedLimit()
	case upgradeurlupgradestrategygraystrategy.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeurlupgradestrategygraystrategy.FieldEnable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnable(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimit(v)
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyGrayStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeurlupgradestrategygraystrategy.FieldCreateAt) {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldCreateAt)
	}
	if m.FieldCleared(upgradeurlupgradestrategygraystrategy.FieldUpdateAt) {
		fields = append(fields, upgradeurlupgradestrategygraystrategy.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ClearField(name string) error {
	switch name {
	case upgradeurlupgradestrategygraystrategy.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyGrayStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetField(name string) error {
	switch name {
	case upgradeurlupgradestrategygraystrategy.FieldEnable:
		m.ResetEnable()
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldBeginDatetime:
		m.ResetBeginDatetime()
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldEndDatetime:
		m.ResetEndDatetime()
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldLimit:
		m.ResetLimit()
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeurlupgradestrategygraystrategy.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyGrayStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyGrayStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeUrlUpgradeStrategyGrayStrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlUpgradeStrategyGrayStrategy edge %s", name)
}

// UpgradeUrlVersionMutation represents an operation that mutates the UpgradeUrlVersion nodes in the graph.
type UpgradeUrlVersionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	company_id      *int
	addcompany_id   *int
	url_id          *int
	addurl_id       *int
	url_path        *string
	version_name    *string
	version_code    *int
	addversion_code *int
	description     *string
	is_del          *int32
	addis_del       *int32
	create_at       *time.Time
	update_at       *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UpgradeUrlVersion, error)
	predicates      []predicate.UpgradeUrlVersion
}

var _ ent.Mutation = (*UpgradeUrlVersionMutation)(nil)

// upgradeurlversionOption allows management of the mutation configuration using functional options.
type upgradeurlversionOption func(*UpgradeUrlVersionMutation)

// newUpgradeUrlVersionMutation creates new mutation for the UpgradeUrlVersion entity.
func newUpgradeUrlVersionMutation(c config, op Op, opts ...upgradeurlversionOption) *UpgradeUrlVersionMutation {
	m := &UpgradeUrlVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeUpgradeUrlVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpgradeUrlVersionID sets the ID field of the mutation.
func withUpgradeUrlVersionID(id int) upgradeurlversionOption {
	return func(m *UpgradeUrlVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *UpgradeUrlVersion
		)
		m.oldValue = func(ctx context.Context) (*UpgradeUrlVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpgradeUrlVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpgradeUrlVersion sets the old UpgradeUrlVersion of the mutation.
func withUpgradeUrlVersion(node *UpgradeUrlVersion) upgradeurlversionOption {
	return func(m *UpgradeUrlVersionMutation) {
		m.oldValue = func(context.Context) (*UpgradeUrlVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpgradeUrlVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpgradeUrlVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpgradeUrlVersion entities.
func (m *UpgradeUrlVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpgradeUrlVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpgradeUrlVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpgradeUrlVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *UpgradeUrlVersionMutation) SetCompanyID(i int) {
	m.company_id = &i
	m.addcompany_id = nil
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UpgradeUrlVersionMutation) CompanyID() (r int, exists bool) {
	v := m.company_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// AddCompanyID adds i to the "company_id" field.
func (m *UpgradeUrlVersionMutation) AddCompanyID(i int) {
	if m.addcompany_id != nil {
		*m.addcompany_id += i
	} else {
		m.addcompany_id = &i
	}
}

// AddedCompanyID returns the value that was added to the "company_id" field in this mutation.
func (m *UpgradeUrlVersionMutation) AddedCompanyID() (r int, exists bool) {
	v := m.addcompany_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UpgradeUrlVersionMutation) ResetCompanyID() {
	m.company_id = nil
	m.addcompany_id = nil
}

// SetURLID sets the "url_id" field.
func (m *UpgradeUrlVersionMutation) SetURLID(i int) {
	m.url_id = &i
	m.addurl_id = nil
}

// URLID returns the value of the "url_id" field in the mutation.
func (m *UpgradeUrlVersionMutation) URLID() (r int, exists bool) {
	v := m.url_id
	if v == nil {
		return
	}
	return *v, true
}

// OldURLID returns the old "url_id" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldURLID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLID: %w", err)
	}
	return oldValue.URLID, nil
}

// AddURLID adds i to the "url_id" field.
func (m *UpgradeUrlVersionMutation) AddURLID(i int) {
	if m.addurl_id != nil {
		*m.addurl_id += i
	} else {
		m.addurl_id = &i
	}
}

// AddedURLID returns the value that was added to the "url_id" field in this mutation.
func (m *UpgradeUrlVersionMutation) AddedURLID() (r int, exists bool) {
	v := m.addurl_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetURLID resets all changes to the "url_id" field.
func (m *UpgradeUrlVersionMutation) ResetURLID() {
	m.url_id = nil
	m.addurl_id = nil
}

// SetURLPath sets the "url_path" field.
func (m *UpgradeUrlVersionMutation) SetURLPath(s string) {
	m.url_path = &s
}

// URLPath returns the value of the "url_path" field in the mutation.
func (m *UpgradeUrlVersionMutation) URLPath() (r string, exists bool) {
	v := m.url_path
	if v == nil {
		return
	}
	return *v, true
}

// OldURLPath returns the old "url_path" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldURLPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLPath: %w", err)
	}
	return oldValue.URLPath, nil
}

// ResetURLPath resets all changes to the "url_path" field.
func (m *UpgradeUrlVersionMutation) ResetURLPath() {
	m.url_path = nil
}

// SetVersionName sets the "version_name" field.
func (m *UpgradeUrlVersionMutation) SetVersionName(s string) {
	m.version_name = &s
}

// VersionName returns the value of the "version_name" field in the mutation.
func (m *UpgradeUrlVersionMutation) VersionName() (r string, exists bool) {
	v := m.version_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionName returns the old "version_name" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldVersionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionName: %w", err)
	}
	return oldValue.VersionName, nil
}

// ResetVersionName resets all changes to the "version_name" field.
func (m *UpgradeUrlVersionMutation) ResetVersionName() {
	m.version_name = nil
}

// SetVersionCode sets the "version_code" field.
func (m *UpgradeUrlVersionMutation) SetVersionCode(i int) {
	m.version_code = &i
	m.addversion_code = nil
}

// VersionCode returns the value of the "version_code" field in the mutation.
func (m *UpgradeUrlVersionMutation) VersionCode() (r int, exists bool) {
	v := m.version_code
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionCode returns the old "version_code" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldVersionCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionCode: %w", err)
	}
	return oldValue.VersionCode, nil
}

// AddVersionCode adds i to the "version_code" field.
func (m *UpgradeUrlVersionMutation) AddVersionCode(i int) {
	if m.addversion_code != nil {
		*m.addversion_code += i
	} else {
		m.addversion_code = &i
	}
}

// AddedVersionCode returns the value that was added to the "version_code" field in this mutation.
func (m *UpgradeUrlVersionMutation) AddedVersionCode() (r int, exists bool) {
	v := m.addversion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionCode resets all changes to the "version_code" field.
func (m *UpgradeUrlVersionMutation) ResetVersionCode() {
	m.version_code = nil
	m.addversion_code = nil
}

// SetDescription sets the "description" field.
func (m *UpgradeUrlVersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpgradeUrlVersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UpgradeUrlVersionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[upgradeurlversion.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UpgradeUrlVersionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[upgradeurlversion.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UpgradeUrlVersionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, upgradeurlversion.FieldDescription)
}

// SetIsDel sets the "is_del" field.
func (m *UpgradeUrlVersionMutation) SetIsDel(i int32) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *UpgradeUrlVersionMutation) IsDel() (r int32, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldIsDel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *UpgradeUrlVersionMutation) AddIsDel(i int32) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *UpgradeUrlVersionMutation) AddedIsDel() (r int32, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *UpgradeUrlVersionMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
}

// SetCreateAt sets the "create_at" field.
func (m *UpgradeUrlVersionMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *UpgradeUrlVersionMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ClearCreateAt clears the value of the "create_at" field.
func (m *UpgradeUrlVersionMutation) ClearCreateAt() {
	m.create_at = nil
	m.clearedFields[upgradeurlversion.FieldCreateAt] = struct{}{}
}

// CreateAtCleared returns if the "create_at" field was cleared in this mutation.
func (m *UpgradeUrlVersionMutation) CreateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlversion.FieldCreateAt]
	return ok
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *UpgradeUrlVersionMutation) ResetCreateAt() {
	m.create_at = nil
	delete(m.clearedFields, upgradeurlversion.FieldCreateAt)
}

// SetUpdateAt sets the "update_at" field.
func (m *UpgradeUrlVersionMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *UpgradeUrlVersionMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the UpgradeUrlVersion entity.
// If the UpgradeUrlVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpgradeUrlVersionMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *UpgradeUrlVersionMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[upgradeurlversion.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *UpgradeUrlVersionMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[upgradeurlversion.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *UpgradeUrlVersionMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, upgradeurlversion.FieldUpdateAt)
}

// Where appends a list predicates to the UpgradeUrlVersionMutation builder.
func (m *UpgradeUrlVersionMutation) Where(ps ...predicate.UpgradeUrlVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpgradeUrlVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpgradeUrlVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpgradeUrlVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpgradeUrlVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpgradeUrlVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpgradeUrlVersion).
func (m *UpgradeUrlVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpgradeUrlVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.company_id != nil {
		fields = append(fields, upgradeurlversion.FieldCompanyID)
	}
	if m.url_id != nil {
		fields = append(fields, upgradeurlversion.FieldURLID)
	}
	if m.url_path != nil {
		fields = append(fields, upgradeurlversion.FieldURLPath)
	}
	if m.version_name != nil {
		fields = append(fields, upgradeurlversion.FieldVersionName)
	}
	if m.version_code != nil {
		fields = append(fields, upgradeurlversion.FieldVersionCode)
	}
	if m.description != nil {
		fields = append(fields, upgradeurlversion.FieldDescription)
	}
	if m.is_del != nil {
		fields = append(fields, upgradeurlversion.FieldIsDel)
	}
	if m.create_at != nil {
		fields = append(fields, upgradeurlversion.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, upgradeurlversion.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpgradeUrlVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlversion.FieldCompanyID:
		return m.CompanyID()
	case upgradeurlversion.FieldURLID:
		return m.URLID()
	case upgradeurlversion.FieldURLPath:
		return m.URLPath()
	case upgradeurlversion.FieldVersionName:
		return m.VersionName()
	case upgradeurlversion.FieldVersionCode:
		return m.VersionCode()
	case upgradeurlversion.FieldDescription:
		return m.Description()
	case upgradeurlversion.FieldIsDel:
		return m.IsDel()
	case upgradeurlversion.FieldCreateAt:
		return m.CreateAt()
	case upgradeurlversion.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpgradeUrlVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upgradeurlversion.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case upgradeurlversion.FieldURLID:
		return m.OldURLID(ctx)
	case upgradeurlversion.FieldURLPath:
		return m.OldURLPath(ctx)
	case upgradeurlversion.FieldVersionName:
		return m.OldVersionName(ctx)
	case upgradeurlversion.FieldVersionCode:
		return m.OldVersionCode(ctx)
	case upgradeurlversion.FieldDescription:
		return m.OldDescription(ctx)
	case upgradeurlversion.FieldIsDel:
		return m.OldIsDel(ctx)
	case upgradeurlversion.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case upgradeurlversion.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpgradeUrlVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upgradeurlversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case upgradeurlversion.FieldURLID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLID(v)
		return nil
	case upgradeurlversion.FieldURLPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLPath(v)
		return nil
	case upgradeurlversion.FieldVersionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionName(v)
		return nil
	case upgradeurlversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionCode(v)
		return nil
	case upgradeurlversion.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upgradeurlversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case upgradeurlversion.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case upgradeurlversion.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpgradeUrlVersionMutation) AddedFields() []string {
	var fields []string
	if m.addcompany_id != nil {
		fields = append(fields, upgradeurlversion.FieldCompanyID)
	}
	if m.addurl_id != nil {
		fields = append(fields, upgradeurlversion.FieldURLID)
	}
	if m.addversion_code != nil {
		fields = append(fields, upgradeurlversion.FieldVersionCode)
	}
	if m.addis_del != nil {
		fields = append(fields, upgradeurlversion.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpgradeUrlVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upgradeurlversion.FieldCompanyID:
		return m.AddedCompanyID()
	case upgradeurlversion.FieldURLID:
		return m.AddedURLID()
	case upgradeurlversion.FieldVersionCode:
		return m.AddedVersionCode()
	case upgradeurlversion.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpgradeUrlVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upgradeurlversion.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyID(v)
		return nil
	case upgradeurlversion.FieldURLID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddURLID(v)
		return nil
	case upgradeurlversion.FieldVersionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionCode(v)
		return nil
	case upgradeurlversion.FieldIsDel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpgradeUrlVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upgradeurlversion.FieldDescription) {
		fields = append(fields, upgradeurlversion.FieldDescription)
	}
	if m.FieldCleared(upgradeurlversion.FieldCreateAt) {
		fields = append(fields, upgradeurlversion.FieldCreateAt)
	}
	if m.FieldCleared(upgradeurlversion.FieldUpdateAt) {
		fields = append(fields, upgradeurlversion.FieldUpdateAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpgradeUrlVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpgradeUrlVersionMutation) ClearField(name string) error {
	switch name {
	case upgradeurlversion.FieldDescription:
		m.ClearDescription()
		return nil
	case upgradeurlversion.FieldCreateAt:
		m.ClearCreateAt()
		return nil
	case upgradeurlversion.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpgradeUrlVersionMutation) ResetField(name string) error {
	switch name {
	case upgradeurlversion.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case upgradeurlversion.FieldURLID:
		m.ResetURLID()
		return nil
	case upgradeurlversion.FieldURLPath:
		m.ResetURLPath()
		return nil
	case upgradeurlversion.FieldVersionName:
		m.ResetVersionName()
		return nil
	case upgradeurlversion.FieldVersionCode:
		m.ResetVersionCode()
		return nil
	case upgradeurlversion.FieldDescription:
		m.ResetDescription()
		return nil
	case upgradeurlversion.FieldIsDel:
		m.ResetIsDel()
		return nil
	case upgradeurlversion.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case upgradeurlversion.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown UpgradeUrlVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpgradeUrlVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpgradeUrlVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpgradeUrlVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpgradeUrlVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpgradeUrlVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpgradeUrlVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpgradeUrlVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpgradeUrlVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpgradeUrlVersion edge %s", name)
}
